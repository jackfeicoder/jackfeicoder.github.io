



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="杰克飞的博客" href="https://120115.xyz/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="杰克飞的博客" href="https://120115.xyz/atom.xml" />
<link rel="alternate" type="application/json" title="杰克飞的博客" href="https://120115.xyz/feed.json" />



<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Hexo,博客" />


<link rel="canonical" href="https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">



  <title>
java高频面试题 - 面试 - Java基础 |
梦想书架 = 杰克飞的博客 = 首页</title>
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css">
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">java高频面试题
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2025-07-21 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2025-07-21T00:00:00+08:00">2025-07-21</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">梦想书架</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
          <li class="item" data-background-image="https://image.cdn2.seaart.ai/2023-12-07/clp059p4msbc73dt2i50/18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 Java基础"><span itemprop="name">Java基础</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" itemprop="item" rel="index" title="分类于 面试"><span itemprop="name">面试</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/source/images/avatar.jpg">
    <meta itemprop="name" content="杰克飞">
    <meta itemprop="description" content="首页, 一个用Hexo搭建的个人博客">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="杰克飞的博客">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><h3 id="1-什么是JAVA"><a href="#1-什么是JAVA" class="headerlink" title="1. 什么是JAVA?"></a>1. 什么是JAVA?</h3><p>Java 是一门面向对象的编程语言，吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。比较重要的特点就是跨平台性，只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。还有面向对象、多线程，JVM等这些让Java变得高效。Java最适合用来做后端开发，有很多成熟的技术栈，比如Springboot,springcloud等。</p>
<h3 id="2-Java-有哪些数据类型？"><a href="#2-Java-有哪些数据类型？" class="headerlink" title="2. Java 有哪些数据类型？"></a>2. Java 有哪些数据类型？</h3><p>基本数据类型和引用数据类型两大类。基本数据类型有：数值型（byte,short,int,long）、浮点型(float,double)、布尔型boolean。引用数据类型有类，数组和接口。</p>
<h3 id="3-面向对象编程有哪些特性？"><a href="#3-面向对象编程有哪些特性？" class="headerlink" title="3. 面向对象编程有哪些特性？"></a>3. 面向对象编程有哪些特性？</h3><p>封装、继承和多态。封装就是把一些属性和方法捆在一起形成一个类，我们可以实例化这个类变成对象，对象可以设置和获取属性，调用方法。开发中就是对象之间的交互。继承就是子类获得父类的所有属性和方法，子类还可以进行扩充或者方法重写。多态就是java运行时可以根据对象类型产生不同的结果。子类需要继承父类并重写父类方法，父类引用指向子类对象。</p>
<h3 id="4-抽象类和接口有什么区别？"><a href="#4-抽象类和接口有什么区别？" class="headerlink" title="4. 抽象类和接口有什么区别？"></a>4. 抽象类和接口有什么区别？</h3><p>一个类只能继承一个抽象类；但一个类可以实现多个接口。比如我们创建线程类的时候一般用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。抽象类符合 is-a 的关系，而接口更像是 has-a 的关系。比如说一个类可以序列化的时候，它只需要实现 Serializable 接口，代表它有这个功能，而不是继承一个序列化类。</p>
<h3 id="5-和-equals-的区别？"><a href="#5-和-equals-的区别？" class="headerlink" title="5. &#x3D;&#x3D;和 equals 的区别？"></a>5. &#x3D;&#x3D;和 equals 的区别？</h3><p>&#x3D;&#x3D; 操作符和 equals() 方法用于比较两个对象：&#x3D;&#x3D;比较两个对象的引用，也就是说在内存中是不是同一份数据。对于基本数据类型（如 int, double, char 等），&#x3D;&#x3D; 比较的是值是否相等。equals比较的是两个对象的内容是否相等，默认跟&#x3D;&#x3D;相同，我们一般会对他重写来用于比较值（比如属性）是否相同而不是引用。</p>
<h3 id="6-为什么重写-equals-时必须重写-hashCode-⽅法？"><a href="#6-为什么重写-equals-时必须重写-hashCode-⽅法？" class="headerlink" title="6. 为什么重写 equals 时必须重写 hashCode ⽅法？"></a>6. 为什么重写 equals 时必须重写 hashCode ⽅法？</h3><p>因为基于哈希的集合类（如 HashMap）需要使用hashCode和equals方法来存储和查找对象。存储时首先根据键的hashCode计算出在数组中的存储位置，每个位置可以存单个值、链表和红黑树，如果没有重写hashCode方法，两个相同的键可能出现不同的hashCode导致它们被存在数组中的不同位置，获取时就发生错误。发生哈希冲突时，键会被存在数组的同一个桶中，通过链表和红黑树解决哈希冲突问题，发生哈希冲突的桶中元素的hashCode值相同，必须再用equals比较值才能找出对应元素，如果没有重写equals()方法就找不到需要的元素。</p>
<h3 id="7-String-和-StringBuilder、StringBuffer-的区别？"><a href="#7-String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="7. String 和 StringBuilder、StringBuffer 的区别？"></a>7. String 和 StringBuilder、StringBuffer 的区别？</h3><p>它们都是用于处理字符串的，String底层用了final修饰是不可变的，每次修改都会创建一个新对象，开销很大，如果要频繁修改字符串可以用StringBuilder，它是在原对象上修改。StringBuffer跟StringBuilder相似，但是它的方法上都加了 synchronized 关键字，是线程安全的，这在单线程下效率比较低。</p>
<h3 id="8-Java-中异常处理体系"><a href="#8-Java-中异常处理体系" class="headerlink" title="8. Java 中异常处理体系?"></a>8. Java 中异常处理体系?</h3><p>主要有两大类，错误和异常，错误指的是程序无法处理的严重错误，比如内存溢出，栈溢出，这些错误通常与 JVM 的运行状态有关。异常分为编译时异常和运行时异常，编译时异常可以被try-catch捕获处理或者throws抛出，比如IOException、SQLException，运行时异常通常是代码逻辑错误，比如数组越界，空指针等。</p>
<h3 id="9-BIO、NIO、AIO-之间的区别？"><a href="#9-BIO、NIO、AIO-之间的区别？" class="headerlink" title="9. BIO、NIO、AIO 之间的区别？"></a>9. BIO、NIO、AIO 之间的区别？</h3><p>BIO：采用阻塞式 I&#x2F;O 模型，基于字节流或字符流文件读写，基于 Socket 和 ServerSocket 进行网络通信，适用于连接数较少的场景，每个连接，都需要创建一个单独的线程来处理读写操作。<br>NIO：采用非阻塞 I&#x2F;O 模型，线程在等待 I&#x2F;O 时可执行其他任务，主要用在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，适用于连接数多但连接时间短的场景。<br>AIO：使用异步 I&#x2F;O 模型，线程发起 I&#x2F;O 请求后立即返回，不需要等待，当 I&#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p>
<h3 id="10-🌟什么是反射？应用？原理？"><a href="#10-🌟什么是反射？应用？原理？" class="headerlink" title="10. 🌟什么是反射？应用？原理？"></a>10. 🌟什么是反射？应用？原理？</h3><p>反射就是在运行时动态地获取类的信息，然后使用它的属性和方法的技术。Spring 框架动态加载和管理 Bean、AOP的动态代理，还有Junit测试框架这些都用到了反射，我们可以用Class.forName通过类名获取一个类，然后调用newInstance方法创建实例对象，getMethod，invoke方法可以获取和调用方法，getDeclaredField可以获取属性，对于私有属性可以调用setAccessible(true); 让它可见。原理就是Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="1-常见集合有哪些？"><a href="#1-常见集合有哪些？" class="headerlink" title="1. 常见集合有哪些？"></a>1. 常见集合有哪些？</h3><p>集合有两大类，Collection 接口和Map 接口。Collection 接口下有List、Set,和Queue, List包含有序可重复的元素。实现类包括 ArrayList、LinkedList。Set是无序不重复的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。Queue是队列。实现类包括 PriorityQueue、ArrayDeque 等。Map 是表示键值对的集合。键不能重复。实现类包括 HashMap、LinkedHashMap、TreeMap 等。</p>
<h3 id="2-哪些是线程安全的容器？"><a href="#2-哪些是线程安全的容器？" class="headerlink" title="2. 哪些是线程安全的容器？"></a>2. 哪些是线程安全的容器？</h3><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。</p>
<h3 id="3-ArrayList-和-LinkedList-有什么区别？"><a href="#3-ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="3. ArrayList 和 LinkedList 有什么区别？"></a>3. ArrayList 和 LinkedList 有什么区别？</h3><p>ArrayList 底层是动态数组，内存是连续的，查找快，增删慢，适合经常通过索引访问，在末尾增删的场景，LinkedList 底层是双向链表，查找慢，增删快，适合频繁增删的场景。</p>
<h3 id="4-ArrayList-的扩容机制了解吗？底层实现？"><a href="#4-ArrayList-的扩容机制了解吗？底层实现？" class="headerlink" title="4. ArrayList 的扩容机制了解吗？底层实现？"></a>4. ArrayList 的扩容机制了解吗？底层实现？</h3><p>当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就调用grow方法生成一个1.5倍容量的新数组，然后拷贝元素到新数组中。</p>
<h3 id="5-ArrayList-怎么序列化的知道吗？"><a href="#5-ArrayList-怎么序列化的知道吗？" class="headerlink" title="5. ArrayList 怎么序列化的知道吗？"></a>5. ArrayList 怎么序列化的知道吗？</h3><p>它重写了writeObject 方法用于自定义序列化：只序列化有效数据，因为实际存储的元素数量一般小于elementData 数组的容量，声明的时候也加了 transient 关键字防止被默认序列化。</p>
<h3 id="6-HashMap实现原理？-高频"><a href="#6-HashMap实现原理？-高频" class="headerlink" title="6. HashMap实现原理？(高频)"></a>6. HashMap实现原理？(高频)</h3><p>JDK8之前是数组+链表。之后是数组+链表+红黑树。存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：如果key相同，覆盖原值。 key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。它的初始容量16，加载因子0.75。创建时使用懒加载，不初始化容量。</p>
<h3 id="7-HashMap的put方法的具体流程？-高频"><a href="#7-HashMap的put方法的具体流程？-高频" class="headerlink" title="7. HashMap的put方法的具体流程？(高频)"></a>7. HashMap的put方法的具体流程？(高频)</h3><p>第一步检查数组是否为空，首次put时，调用resize()初始化数组，默认容量为 16，负载因子为0.75。<br>第二步，计算键的哈希值，具体是将 键的hashCode 异或 hashCode 右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。<br>第三步，根据键的哈希值计算数组索引，具体是将键的哈希值 与上 数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高所以用与运算代替模运算，但前提是数组长度是2的N次幂）。<br>第四步，检查数组索引对应槽位的情况。如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。</p>
<p>hashMap的寻址算法：扰动算法，通过hash方法，hashcode ^ hashcode &lt;&lt;&lt; 16。<br>首先计算键的hashCode,再调用hash方法进行二次哈希，hashCode右移16位再和hashCode进行异或运算，减少哈希冲突，最后用哈希值 与 容量 -1 得到索引。</p>
<h3 id="8-讲一讲HashMap的扩容机制-高频"><a href="#8-讲一讲HashMap的扩容机制-高频" class="headerlink" title="8. 讲一讲HashMap的扩容机制(高频)"></a>8. 讲一讲HashMap的扩容机制(高频)</h3><p>当哈希表中元素个数超过阈值时会触发扩容resize方法，这个阈值是 数组容量 * 负载因子,数组容量初始是16，负载因子默认是0.75。<br>扩容时：<br>第一步，创建一个新数组，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。<br>第二步，迁移元素，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过e.hash &amp; (newCap新容量 - 1)计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为低位链和高位链，避免重新哈希带来性能损耗，如果 e.hash &amp; oldCap &#x3D;&#x3D; 0（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。</p>
<p>为何HashMap的数组长度一定是2的次幂?<br>数组长度是 2 的幂次方时，hash % length和hash &amp; (length - 1)的计算结果是一样的。不过按位与运算在性能上更具优势。计算索引时效率更高，扩容时效率更高。</p>
<h3 id="9-HashMap-是线程安全的吗？"><a href="#9-HashMap-是线程安全的吗？" class="headerlink" title="9. HashMap 是线程安全的吗？"></a>9. HashMap 是线程安全的吗？</h3><p>不是。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。多线程在进行 put 元素的时候，可能会导致元素丢失。因为put操作不是原子的。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素先插入的元素被覆盖而丢失put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get就可能获取不到元素。线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引 元素可能就 get 不到了。</p>
<h3 id="1-怎么解决HashMap线程不安全问题？"><a href="#1-怎么解决HashMap线程不安全问题？" class="headerlink" title="1. 怎么解决HashMap线程不安全问题？"></a>1. 怎么解决HashMap线程不安全问题？</h3><p>早期的 JDK 版本中，可以用 <code>Hashtable</code> 来保证线程安全。<code>Hashtable</code> 在方法上加了 <code>synchronized</code> 关键字。但是它同步开销比较大、还不支持 null、扩容效率低，已经被淘汰。多线程场景下推荐使用 <code>ConcurrentHashMap</code>，它使用了分段锁优化，性能远超 <code>HashTable</code>。</p>
<hr>
<h2 id="并发与JUC高频面试题"><a href="#并发与JUC高频面试题" class="headerlink" title="并发与JUC高频面试题"></a>并发与JUC高频面试题</h2><h3 id="2-进程和线程的区别？"><a href="#2-进程和线程的区别？" class="headerlink" title="2. 进程和线程的区别？"></a>2. 进程和线程的区别？</h3><ul>
<li><strong>进程</strong>：程序在操作系统中的一次执行，是系统进行资源分配和调度的基本单位，拥有独立内存空间和系统资源，进程间切换开销大。</li>
<li><strong>线程</strong>：进程中的一个执行单元，是 CPU 调度的基本单位，共享所属进程的资源，线程间切换开销小。</li>
<li><strong>并行</strong>：多个任务同时执行。</li>
<li><strong>并发</strong>：多个任务通过时间片轮转在一段时间内交替执行。</li>
</ul>
<hr>
<h3 id="3-线程创建的方式有哪些？"><a href="#3-线程创建的方式有哪些？" class="headerlink" title="3. 线程创建的方式有哪些？"></a>3. 线程创建的方式有哪些？</h3><p>有四种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口，线程池创建。</p>
<p><strong>1. 继承 Thread 类</strong>：需要重写父类 Thread 的 run() 方法，然后调用 start() 方法启动线程。缺点是，如果 ThreadTask 已经继承了另外一个类，就不能再继承 Thread 类了，因为 Java 不支持多重继承。</p>
<p><strong>2. 实现 Runnable 接口</strong>：重写 Runnable 接口的 run() 方法，然后把它作为参数传给 Thread类，最后调用 start() 方法启动线程。这种方式的优点是可以避免 Java 的单继承限制，缺点是没有返回值，拿不到线程执行结果并且不能抛出异常。</p>
<p><strong>3. 实现 Callable 接口</strong>：重写 Callable 接口的 call() 方法，然后创建一个 CallableTask 对象，然后创建 FutureTask 对象，构造方法中以 CallableTask 实例传参；然后创建 Thread 对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CallableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableTask</span>();</span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>4. 线程池创建</strong>：实现 Runnable 或 Callable 接口后，提交给线程池执行。</p>
<hr>
<h3 id="4-线程包括哪些状态，状态之间是如何变化的？"><a href="#4-线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="4. 线程包括哪些状态，状态之间是如何变化的？"></a>4. 线程包括哪些状态，状态之间是如何变化的？</h3><p>Thread类中有一个枚举类State，一共6种：</p>
<ul>
<li>新建(NEW)</li>
<li>可运行(RUNNABLE)</li>
<li>阻塞(BLOCKED)</li>
<li>等待（WAITING）</li>
<li>时间等待(TIMED_WAITING)</li>
<li>终止(TERMINATED)</li>
</ul>
<p>状态转换：</p>
<ul>
<li>创建线程对象是新建状态</li>
<li>调用了start()方法转变为可执行状态</li>
<li>线程获取到了CPU的执行权，执行结束是终止状态</li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态</li>
<li>如果没有获取锁(synchronized或lock)进入阻塞状态，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入等待状态，其他线程调用notify(唤醒后可切换为可执行状态)</li>
<li>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</li>
</ul>
<hr>
<h3 id="5-在java中wait和sleep方法的不同"><a href="#5-在java中wait和sleep方法的不同" class="headerlink" title="5. 在java中wait和sleep方法的不同"></a>5. 在java中wait和sleep方法的不同</h3><ul>
<li>都能让线程进入阻塞状态，并且都可以传一个时间参数等待相应毫秒数醒来，也都能被打断唤醒。</li>
<li><strong>sleep方法</strong>是Thread类的静态方法，而<strong>wait方法</strong>是Object类的成员方法。</li>
<li>wait方法可以被notify方法唤醒，如果没传时间参数也没被唤醒就一直等待。</li>
<li><strong>锁不同</strong>：<ul>
<li>wait方法的调用必须先获取wait对象的锁，wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu，但你们还可以用）。</li>
<li>sleep调用不用获取锁，sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-如何停止一个正在运行的线程"><a href="#6-如何停止一个正在运行的线程" class="headerlink" title="6. 如何停止一个正在运行的线程"></a>6. 如何停止一个正在运行的线程</h3><p>三种方式：</p>
<ul>
<li><strong>使用退出标志</strong>，使线程正常退出，也就是当run方法完成后线程终止。</li>
<li>使用<strong>stop方法强行终止</strong>（不推荐，方法已作废）。</li>
<li>使用<strong>interrupt方法</strong>中断线程。<ul>
<li>打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常。</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-线程中并发安全（高频，难答）"><a href="#7-线程中并发安全（高频，难答）" class="headerlink" title="7. 线程中并发安全（高频，难答）"></a>7. 线程中并发安全（高频，难答）</h3><h4 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h4><ul>
<li>在jdk1.6之前，<code>synchronized</code>被称为<strong>重量级锁</strong>。底层核心是<strong>monitor（监视器）</strong>，它是 JVM 层面的对象，每个 Java 对象都会关联一个 monitor。当线程获取 synchronized 锁时，本质是获取对象关联的 monitor 所有权，其核心属性是owner、entrylist、waitset。</li>
<li>owner关联当前持有锁的线程（同一时刻仅一个线程可持有）。</li>
<li>entrylist关联等待获取锁的线程队列（这些线程处于阻塞状态）。</li>
<li>waitset关联的调用<code>wait()</code>后进入等待状态的线程队列（需被<code>notify/notifyAll</code>唤醒后才会进入 entryList）。</li>
</ul>
<p><strong>锁升级：</strong></p>
<ul>
<li>jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了<strong>偏向锁</strong>和<strong>轻量级锁</strong>。</li>
<li><strong>偏向锁</strong>：在对象头的<code>Mark Word</code>中记录获取锁的线程 ID，后续该线程再次获取锁时，只需判断 ID 是否在Mark Word，无需 CAS 操作。适用于锁长期被同一线程持有，无竞争的场景。当其他线程尝试获取锁时，偏向锁会被撤销，通过 CAS 竞争升级为轻量级锁。</li>
<li><strong>轻量级锁</strong>：通过CAS操作在当前线程栈帧中创建“锁记录（Lock Record）”，将<code>Mark Word</code>复制到锁记录中，再尝试用CAS将<code>Mark Word</code>替换为指向锁记录的指针：<ul>
<li>成功：获取轻量级锁，<code>Mark Word</code>标志位为<code>00</code>。</li>
<li>失败：进入“自旋优化”（线程不阻塞，循环尝试获取锁，避免内核态切换）。<ul>
<li><strong>自旋优化</strong>：若自旋一定次数（默认10次）后仍失败，升级为重量级锁。</li>
</ul>
</li>
</ul>
</li>
<li><strong>重量级锁</strong>：底层使用的Monitor实现，Monitor依赖操作系统互斥量（Mutex）实现，所以也叫互斥锁，涉及到了用户态和内核态的切换，开销巨大，适用于锁竞争激烈或持有锁时间长的场景。</li>
</ul>
<hr>
<h3 id="8-你谈谈JMM-Java内存模型）"><a href="#8-你谈谈JMM-Java内存模型）" class="headerlink" title="8. 你谈谈JMM(Java内存模型）"></a>8. 你谈谈JMM(Java内存模型）</h3><p>JMM（Java 内存模型）是 JVM 定义的<strong>共享内存中多线程读写操作规范</strong>，保证指令正确性，它把内存分为主内存和本地内存。主内存公共区域存储共享变量，本地内存是线程私有存储共享变量的副本，线程间隔离，交互通过主内存。当某个线程更改了本地内存中共享变量的副本，jvm会写入主内存让所有线程可见。</p>
<hr>
<h3 id="9-CAS-你知道吗"><a href="#9-CAS-你知道吗" class="headerlink" title="9. CAS 你知道吗"></a>9. CAS 你知道吗</h3><p>CAS的全称是：CompareAndSwap(比较再交换);它体现的一种<strong>乐观锁</strong>的思想，在无锁状态下保证线程操作数据的<strong>原子性</strong>。CAS使用到的地方很多：AQS框架、AtomicXXX类，在操作共享变量的时候使用的<strong>自旋锁</strong>效率上更高一些，CAS的底层是调用的<strong>Unsafe类</strong>中的本地方法由C&#x2F;C++实现。</p>
<hr>
<h3 id="10-乐观锁和悲观锁的区别？"><a href="#10-乐观锁和悲观锁的区别？" class="headerlink" title="10. 乐观锁和悲观锁的区别？"></a>10. 乐观锁和悲观锁的区别？</h3><ul>
<li><strong>乐观锁</strong>：操作数据时非常乐观，认为别的线程不会同时修改数据，因此不会上锁。通常在执行更新时，会判断在此期间数据是否被别人修改，若未修改则执行操作，否则放弃操作。主要实现方式有 CAS 机制和版本号机制，适用于<strong>竞争不激烈、读多写少</strong>的场景，如 Java 中<code>AtomicInteger</code>等原子类就运用了乐观锁思想。</li>
<li><strong>悲观锁</strong>：操作数据时比较悲观，认为其他线程会同时修改数据，所以在操作数据前直接把数据锁住，直到操作完成后才释放锁，上锁期间其他线程不能修改数据。Java 中的<code>synchronized</code>关键字和<code>ReentrantLock</code>等都是悲观锁的实现，适合<strong>并发写入多、竞争激烈</strong>的场景。</li>
</ul>
<hr>
<h3 id="11-什么是AQS？"><a href="#11-什么是AQS？" class="headerlink" title="11. 什么是AQS？"></a>11. 什么是AQS？</h3><p>AQS 是一个抽象类，一个共享变量 state 和一个线程等待队列，为 ReentrantLock 等类提供底层支持。如果被请求的<strong>共享资源</strong>处于空闲状态，当前线程就能成功<strong>获取锁</strong>；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。</p>
<p>AQS 的源码阅读：</p>
<ul>
<li>状态 state 由 volatile 变量修饰，用于保证多线程之间的可见性。</li>
<li><strong>同步队列</strong>由内部定义的 Node 类实现，每个 Node 包含了等待状态、前后节点、线程的引用等，是一个先进先出的双向链表。</li>
<li>AQS 支持两种同步方式：<ul>
<li>独占模式下：每次只能有一个线程持有锁，例如 ReentrantLock。</li>
<li>共享模式下：多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。</li>
</ul>
</li>
<li>acquire ：获取锁，失败进入等待队列；</li>
<li>release ：释放锁，唤醒等待队列中的线程；</li>
<li>acquireShared ：共享模式获取锁</li>
<li>releaseShared ：共享模式释放锁。</li>
<li>AQS 使用一个 CLH 队列来维护等待线程，是一种基于链表的自旋锁。当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。</li>
</ul>
<hr>
<h3 id="12-ReentrantLock的实现原理"><a href="#12-ReentrantLock的实现原理" class="headerlink" title="12. ReentrantLock的实现原理"></a>12. ReentrantLock的实现原理</h3><p>ReentrantLock表示可重入锁，调用lock方法获取了锁之后，再次调用lock，是不会再阻塞。ReentrantLock主要利用CAS+AQS队列来实现，支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。</p>
<hr>
<h3 id="13-synchronized-和-ReentrantLock-的区别"><a href="#13-synchronized-和-ReentrantLock-的区别" class="headerlink" title="13. synchronized 和 ReentrantLock 的区别"></a>13. synchronized 和 ReentrantLock 的区别</h3><ul>
<li>synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。</li>
<li>ReentrantLock 可以实现多路选择通知，绑定多个 Condition，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；</li>
<li>synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。</li>
<li>并发量大的情况下，推荐使用 ReentrantLock，因为：<ul>
<li>提供了超时和公平锁等特性，可以应对更复杂的并发场景。</li>
<li>允许更细粒度的锁控制，能有效减少锁竞争。</li>
<li>支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="14-Lock-了解吗？"><a href="#14-Lock-了解吗？" class="headerlink" title="14. Lock 了解吗？"></a>14. Lock 了解吗？</h3><p>Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等。</p>
<hr>
<h3 id="15-ReentrantLock-的-lock-方法实现逻辑了解吗？"><a href="#15-ReentrantLock-的-lock-方法实现逻辑了解吗？" class="headerlink" title="15. ReentrantLock 的 lock() 方法实现逻辑了解吗？"></a>15. ReentrantLock 的 lock() 方法实现逻辑了解吗？</h3><p>lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS 的等待队列中。</p>
<hr>
<h3 id="16-请谈谈你对volatile的理解"><a href="#16-请谈谈你对volatile的理解" class="headerlink" title="16. 请谈谈你对volatile的理解"></a>16. 请谈谈你对volatile的理解</h3><ul>
<li>JVM中的JIT即时编译器会对指令进行优化重排序，这可能导致一个线程对共享变量的修改其他线程不可见，用volatile修饰共享变量后，能够防止编译器等优化发生，保证共享变量的可见性。</li>
<li>禁止进行指令重排序：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</li>
<li>volatile使用技巧：写变量让volatile修饰的变量的在代码最后位置，读变量让volatile修饰的变量的在代码最开始位置。</li>
</ul>
<hr>
<h3 id="17-聊一下ConcurrentHashMap-？（高频很重要）"><a href="#17-聊一下ConcurrentHashMap-？（高频很重要）" class="headerlink" title="17. 聊一下ConcurrentHashMap ？（高频很重要）"></a>17. 聊一下ConcurrentHashMap ？（高频很重要）</h3><p>ConcurrentHashMap 是 HashMap 的线程安全版本。</p>
<ul>
<li>JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable，维护一个键值对数组HashEntry 它是一个单向链表。段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。</li>
<li>JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。</li>
<li>对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。</li>
</ul>
<hr>
<h4 id="JDK-7-中-ConcurrentHashMap-的-put-get-流程"><a href="#JDK-7-中-ConcurrentHashMap-的-put-get-流程" class="headerlink" title="JDK 7 中 ConcurrentHashMap 的 put&#x2F;get 流程"></a>JDK 7 中 ConcurrentHashMap 的 put&#x2F;get 流程</h4><ol>
<li>计算 key 的 hash，定位到段，段如果是空就先初始化；</li>
<li>使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；</li>
<li>遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。</li>
<li>释放锁。</li>
</ol>
<p>Get时先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。<br>get 不用加锁，因为 value 是 volatile 的，所以线程读取 value 时不会出现可见性问题。</p>
<hr>
<h4 id="JDK-8-中-ConcurrentHashMap-的-put-get-流程"><a href="#JDK-8-中-ConcurrentHashMap-的-put-get-流程" class="headerlink" title="JDK 8 中 ConcurrentHashMap 的 put&#x2F;get 流程"></a>JDK 8 中 ConcurrentHashMap 的 put&#x2F;get 流程</h4><ul>
<li>JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比 JDK 7 有了很大的提升。</li>
<li>Put: 第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。插入的过程中会判断桶的哈希是否小于 0（f.hash &gt;&#x3D; 0），小于 0 说明是红黑树，大于等于 0 说明是链表。第三步，如果链表长度超过 8，转换为红黑树。第四步，在插入新节点后，会调用 addCount() 方法检查是否需要扩容。</li>
<li>Get: get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用find方法查找。否则遍历链表查找匹配的键。如果都没找到，返回 null。</li>
</ul>
<hr>
<h4 id="项目中怎么使用-ConcurrentHashMap-的？"><a href="#项目中怎么使用-ConcurrentHashMap-的？" class="headerlink" title="项目中怎么使用 ConcurrentHashMap 的？"></a>项目中怎么使用 ConcurrentHashMap 的？</h4><p>在技术派实战项目中，用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用了 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。</p>
<hr>
<h4 id="ConcurrentHashMap-怎么保证可见性？"><a href="#ConcurrentHashMap-怎么保证可见性？" class="headerlink" title="ConcurrentHashMap 怎么保证可见性？"></a>ConcurrentHashMap 怎么保证可见性？</h4><p>ConcurrentHashMap 中的 Node 节点中，value 和 next 都是 volatile 的，这样就可以保证对 value 或 next 的更新会被其他线程立即看到。</p>
<hr>
<h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高？"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高？" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高？"></a>为什么 ConcurrentHashMap 比 Hashtable 效率高？</h4><p>Hashtable 在任何时刻只允许一个线程访问整个 Map，是通过对整个 Map 加锁来实现线程安全的。比如 get 和 put 方法，是直接在方法上加的 synchronized 关键字。而 ConcurrentHashMap 在 JDK 8 中是采用 CAS + synchronized 实现的，仅在必要时加锁。比如说 put 的时候优先使用 CAS 尝试插入，如果失败再使用 synchronized 代码块加锁。get 的时候是完全无锁的，因为 value 是 volatile 变量 修饰的，保证了内存可见性。</p>
<hr>
<h4 id="CopyOnWriteArrayList-的实现原理"><a href="#CopyOnWriteArrayList-的实现原理" class="headerlink" title="CopyOnWriteArrayList 的实现原理"></a>CopyOnWriteArrayList 的实现原理</h4><p>CopyOnWriteArrayList 是 ArrayList 的线程安全版本，适用于读多写少的场景。它的核心思想是写操作时创建一个新数组，修改后再替换原数组，这样就能够确保读操作无锁，从而提高并发性能。内部使用 volatile 变量来修饰数组 array，以读操作的内存可见性。写操作的时候使用 ReentrantLock 来保证线程安全。缺点就是写操作的时候会复制一个新数组，如果数组很大，写操作的性能会受到影响。</p>
<h3 id="1-阻塞队列的实现方式？"><a href="#1-阻塞队列的实现方式？" class="headerlink" title="1. 阻塞队列的实现方式？"></a>1. 阻塞队列的实现方式？</h3><p>阻塞队列是多线程环境下常用的数据结构，支持阻塞式的插入和删除，当队列满时，生产者线程会被阻塞直到有空间；当队列空时，消费者线程会被阻塞直到有元素。这种特性使其非常适合实现生产者 - 消费者模式。主要实现方式有3种：</p>
<ul>
<li>基于 synchronized+wait&#x2F;notify ，利用 Java 内置锁和 Object 类的等待机制。队列的 put 和 take 方法用 synchronized 修饰，当队列满时，生产者通过 wait () 进入等待状态；当队列空时，消费者同样 wait ()。操作完成后通过 notifyAll () 唤醒等待线程。优点是实现简单，缺点是功能单一，不支持公平性，且只有一个条件队列。</li>
<li>基于 ReentrantLock+Condition 的实现。这是 JDK 标准库（如ArrayBlockingQueue）采用的方式，比 synchronized 更灵活。通过 ReentrantLock 保证线程安全，同时创建两个 Condition 对象（notEmpty 和 notFull）分别管理消费者和生产者的等待队列。当队列满时，生产者在 notFull 上 await ()；当队列空时，消费者在 notEmpty 上 await ()。操作完成后针对性地 signal () 对应条件队列的线程。这种方式支持公平锁配置，且能精确唤醒特定类型的线程。</li>
<li>基于 CAS 操作的非阻塞实现。利用原子类（如 AtomicReference）通过 CAS 操作实现无锁化的并发控制，比如 ConcurrentLinkedQueue。通过循环重试的方式处理并发冲突，避免了线程阻塞和唤醒的开销，高并发场景下性能更好，但实现逻辑复杂，适合对性能要求极高的场景。</li>
</ul>
<p>这几种实现各有侧重：synchronized 方式适合简单场景；ReentrantLock+Condition 兼顾功能与性能，是 JDK 标准实现的首选；CAS 方式适合高并发低延迟的场景。实际开发中通常用 JDK 提供的阻塞队列（如 ArrayBlockingQueue、LinkedBlockingQueue），它们内部基于 ReentrantLock+Condition 实现，已经过充分优化和测试，能满足绝大多数并发场景的需求。</p>
<hr>
<h2 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h2><h3 id="1-先做个简单的自我介绍吧！"><a href="#1-先做个简单的自我介绍吧！" class="headerlink" title="1. 先做个简单的自我介绍吧！"></a>1. 先做个简单的自我介绍吧！</h3><p>面试官您好！我叫郝泽飞，是哈尔滨工程大学计算机专业的学生，现在在读研一，在校期间，我成绩专业排名前10%，大学期间参加了多个竞赛并取得奖项，通过了英语四六级。技术方面，大一期间我学习了计算机的基础知识，像数据结构，C++和JAVA的基础语法，大二以后开始学Java技术栈，比如Spring Boot、MyBatis-Plus、MySQL、Redis、RabbitMQ等，后来又做了一些项目，微服务架构的Pm-hub,大模型应用开发的派聪明。生活中我是一个比较积极乐观的人，我非常期待能在贵公司的开发岗位中，将所学的技术应用于实际业务，我的介绍完毕，谢谢！</p>
<h3 id="2-说说你的这个pm-hub项目吧？"><a href="#2-说说你的这个pm-hub项目吧？" class="headerlink" title="2. 说说你的这个pm-hub项目吧？"></a>2. 说说你的这个pm-hub项目吧？</h3><p>（项目背景、解决问题、职责任务。2项目使用的技术栈、技术架构、是否使用微服务，项目具体功能细节。技术具体实现细节。项目存在的问题和完善解决方案。项目具体功能的优化（如查询是在数据库中扫表查询吗）项目最有挑战的模块，如何解决，项目增大10倍的qps，如何设计？项目上线后出现频繁fullGc，怎么解决？）<br>好的，这个项目是我（跟室友&#x2F;同学&#x2F;老师一起做的。&#x2F;参考开源项目做的一个二次开发），做这个项目是为了……，考虑到—所以项目中用到了***，当时我负责的部分是。发现速度&#x2F;可用性不够，进行了SQL优化，分布式锁，seata事务,skywalking监控等。第二个项目是……，因为最近AI比较流行，我就想学一些新技术，跟上时代的步伐，这个项目是参考开源项目，用了……技术栈，实现了……功能，优化，解决……问题。以上是我的项目介绍。</p>
<h3 id="3-项目中遇到最大的困难？怎么解决的？"><a href="#3-项目中遇到最大的困难？怎么解决的？" class="headerlink" title="3. 项目中遇到最大的困难？怎么解决的？"></a>3. 项目中遇到最大的困难？怎么解决的？</h3><hr>
<h3 id="4-平时是怎么学习的？"><a href="#4-平时是怎么学习的？" class="headerlink" title="4. 平时是怎么学习的？"></a>4. 平时是怎么学习的？</h3><p>比如我学一门新技术吧，首先看官方文档，如果晦涩难懂就会找教程&#x2F;视频，还会使用AI工具（豆包，chatGPT）详细解释辅助理解，然后做个demo用到项目中，大学期间我大多是在开源社区学习还有网课。</p>
<h3 id="5-人生发展、最近五年职业规划"><a href="#5-人生发展、最近五年职业规划" class="headerlink" title="5. 人生发展、最近五年职业规划"></a>5. 人生发展、最近五年职业规划</h3><hr>
<h3 id="6-什么时候能到岗？"><a href="#6-什么时候能到岗？" class="headerlink" title="6. 什么时候能到岗？"></a>6. 什么时候能到岗？</h3><h3 id="7-薪资要求？"><a href="#7-薪资要求？" class="headerlink" title="7. 薪资要求？"></a>7. 薪资要求？</h3><h2 id="反问："><a href="#反问：" class="headerlink" title="反问："></a>反问：</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol>
<li>部门主营业务和使用的技术栈是什么？</li>
<li>您觉得我的专业能力有哪些需要提升的？</li>
<li>刚才关于xx问题，我想问下您的思路。</li>
<li>面试一般多久会出通知和结果呢？</li>
</ol>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol>
<li>面试候选人，尤其是校招生的时候，最看重什么？</li>
<li>您对进入您团队的成员的要求是什么？或者说需要怎样的品质胜任这个职位？</li>
<li>我很好奇职位的晋升机制和发展路径。公司对信任的培养是怎么样的？</li>
</ol>
<h3 id="HR面-三面"><a href="#HR面-三面" class="headerlink" title="HR面&#x2F;三面"></a>HR面&#x2F;三面</h3><ul>
<li>企业文化</li>
<li>代表性产品</li>
<li>历年薪资</li>
</ul>

      <div class="tags">
          <a href="/tags/Hexo/" rel="tag"><i class="ic i-tag"></i> Hexo</a>
          <a href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag"><i class="ic i-tag"></i> 博客</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2025-07-23 19:04:34" itemprop="dateModified" datetime="2025-07-23T19:04:34+08:00">2025-07-23</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="杰克飞 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="杰克飞 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="杰克飞 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>杰克飞 <i class="ic i-at"><em>@</em></i>杰克飞的博客
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="java高频面试题">https://120115.xyz/2025/07/21/java高频面试题/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url" rel="prev" data-background-image="&#x2F;&#x2F;images&#x2F;avatar.jpg" title="ArrayList底层的实现原理是什么？">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 数据结构</span>
  <h3>ArrayList底层的实现原理是什么？</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E6%95%B4%E7%90%86%E7%89%88/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;image.cdn2.seaart.ai&#x2F;2023-12-07&#x2F;clp059p4msbc73dt2i50&#x2F;18c4316589861f4d7b009f8da7a5978a148b4faf_high.webp" title="力扣算法Hot100刷题路线">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 力扣</span>
  <h3>力扣算法Hot100刷题路线</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaSE"><span class="toc-number">1.</span> <span class="toc-text">JavaSE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJAVA"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是JAVA?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. Java 有哪些数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 面向对象编程有哪些特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 抽象类和接口有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5. &#x3D;&#x3D;和 equals 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6. 为什么重写 equals 时必须重写 hashCode ⽅法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-String-%E5%92%8C-StringBuilder%E3%80%81StringBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7. String 和 StringBuilder、StringBuffer 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Java-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB"><span class="toc-number">1.8.</span> <span class="toc-text">8. Java 中异常处理体系?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-BIO%E3%80%81NIO%E3%80%81AIO-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. BIO、NIO、AIO 之间的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%F0%9F%8C%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10. 🌟什么是反射？应用？原理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1. 常见集合有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 哪些是线程安全的容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3. ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ArrayList-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4. ArrayList 的扩容机制了解吗？底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ArrayList-%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5. ArrayList 怎么序列化的知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F-%E9%AB%98%E9%A2%91"><span class="toc-number">2.6.</span> <span class="toc-text">6. HashMap实现原理？(高频)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F-%E9%AB%98%E9%A2%91"><span class="toc-number">2.7.</span> <span class="toc-text">7. HashMap的put方法的具体流程？(高频)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-%E9%AB%98%E9%A2%91"><span class="toc-number">2.8.</span> <span class="toc-text">8. 讲一讲HashMap的扩容机制(高频)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9. HashMap 是线程安全的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">1. 怎么解决HashMap线程不安全问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8EJUC%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">并发与JUC高频面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">2. 进程和线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">3. 线程创建的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">4. 线程包括哪些状态，状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8java%E4%B8%ADwait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">3.4.</span> <span class="toc-text">5. 在java中wait和sleep方法的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">6. 如何停止一个正在运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%8C%E9%9A%BE%E7%AD%94%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">7. 线程中并发安全（高频，难答）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">synchronized关键字的底层原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%A0%E8%B0%88%E8%B0%88JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">8. 你谈谈JMM(Java内存模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-CAS-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">3.8.</span> <span class="toc-text">9. CAS 你知道吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">10. 乐观锁和悲观锁的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">11. 什么是AQS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.</span> <span class="toc-text">12. ReentrantLock的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.</span> <span class="toc-text">13. synchronized 和 ReentrantLock 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Lock-%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">14. Lock 了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-ReentrantLock-%E7%9A%84-lock-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">15. ReentrantLock 的 lock() 方法实现逻辑了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%AF%B7%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.15.</span> <span class="toc-text">16. 请谈谈你对volatile的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap-%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">3.16.</span> <span class="toc-text">17. 聊一下ConcurrentHashMap ？（高频很重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-7-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-put-get-%E6%B5%81%E7%A8%8B"><span class="toc-number">3.16.1.</span> <span class="toc-text">JDK 7 中 ConcurrentHashMap 的 put&#x2F;get 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-8-%E4%B8%AD-ConcurrentHashMap-%E7%9A%84-put-get-%E6%B5%81%E7%A8%8B"><span class="toc-number">3.16.2.</span> <span class="toc-text">JDK 8 中 ConcurrentHashMap 的 put&#x2F;get 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-ConcurrentHashMap-%E7%9A%84%EF%BC%9F"><span class="toc-number">3.16.3.</span> <span class="toc-text">项目中怎么使用 ConcurrentHashMap 的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="toc-number">3.16.4.</span> <span class="toc-text">ConcurrentHashMap 怎么保证可见性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F"><span class="toc-number">3.16.5.</span> <span class="toc-text">为什么 ConcurrentHashMap 比 Hashtable 效率高？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.16.6.</span> <span class="toc-text">CopyOnWriteArrayList 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">1. 阻塞队列的实现方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">开放性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%88%E5%81%9A%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%90%A7%EF%BC%81"><span class="toc-number">4.1.</span> <span class="toc-text">1. 先做个简单的自我介绍吧！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E8%BF%99%E4%B8%AApm-hub%E9%A1%B9%E7%9B%AE%E5%90%A7%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2. 说说你的这个pm-hub项目吧？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9B%B0%E9%9A%BE%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3. 项目中遇到最大的困难？怎么解决的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4. 平时是怎么学习的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%BA%E7%94%9F%E5%8F%91%E5%B1%95%E3%80%81%E6%9C%80%E8%BF%91%E4%BA%94%E5%B9%B4%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-number">4.5.</span> <span class="toc-text">5. 人生发展、最近五年职业规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%83%BD%E5%88%B0%E5%B2%97%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">6. 什么时候能到岗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%96%AA%E8%B5%84%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">7. 薪资要求？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">反问：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2"><span class="toc-number">5.1.</span> <span class="toc-text">一面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%9D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">二面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HR%E9%9D%A2-%E4%B8%89%E9%9D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">HR面&#x2F;三面</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="java高频面试题">java高频面试题</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="杰克飞"
      data-src="/images/source/images/avatar.jpg">
  <p class="name" itemprop="name">杰克飞</p>
  <div class="description" itemprop="description">一个用Hexo搭建的个人博客</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">13</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">10</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">22</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

    
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-feather"></i>文章</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a>
  </li>

    
  <li class="item">
    <a href="/fixed-license-plate-lottery.html" rel="section"><i class="ic i-car"></i>车牌号选号</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E6%95%B4%E7%90%86%E7%89%88/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%9A%8F%E7%AC%94/" title="分类于 随笔">随笔</a>
</div>

    <span><a href="/2025/07/18/hello-world/" title="你好，世界">你好，世界</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%9B%E6%89%A3/" title="分类于 力扣">力扣</a>
</div>

    <span><a href="/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E7%AE%80%E6%B4%81%E7%89%88/" title="力扣算法Hot100刷题路线">力扣算法Hot100刷题路线</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/java%E9%9D%A2%E8%AF%95/" title="分类于 java面试">java面试</a>
</div>

    <span><a href="/2024/07/21/%E7%89%9B%E5%AE%A2%E7%A5%9E%E5%93%81%E5%85%AB%E8%82%A1/" title="神品八股-付费14元">神品八股-付费14元</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
</div>

    <span><a href="/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/" title="LangChain4j实战教程-Java开发AI项目，太爽了！">LangChain4j实战教程-Java开发AI项目，太爽了！</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a>
</div>

    <span><a href="/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" title="java高频面试题">java高频面试题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a>
</div>

    <span><a href="/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" title="ArrayList底层的实现原理是什么？">ArrayList底层的实现原理是什么？</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/" title="分类于 集合">集合</a>
</div>

    <span><a href="/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/" title="讲一讲HashMap的扩容机制">讲一讲HashMap的扩容机制</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/" title="分类于 并发">并发</a>
</div>

    <span><a href="/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/" title="HashMap 是线程安全的吗？">HashMap 是线程安全的吗？</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java%E5%9F%BA%E7%A1%80/" title="分类于 Java基础">Java基础</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a>
</div>

    <span><a href="/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/" title="HashMap的put方法的具体流程？">HashMap的put方法的具体流程？</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%B8%B8%E6%88%8F/" title="分类于 游戏">游戏</a>
</div>

    <span><a href="/2024/07/21/%E5%AD%A6%E4%B9%A0%E7%89%88%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/" title="学习版游戏网站">学习版游戏网站</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment">
    <li><span class="comment-author">小明 @ 1天前：</span> 写得真棒！</li>
    <li><span class="comment-author">小红 @ 1天前：</span> 学习了！</li>
    <li><span class="comment-author">路人甲 @ 1天前：</span> 感谢分享！</li>
    <li><span class="comment-author">小王 @ 2天前：</span> 有源码吗？</li>
    <li><span class="comment-author">小李 @ 2天前：</span> 希望多写点Java相关内容！</li>
    <li><span class="comment-author">小张 @ 2天前：</span> 收藏了！</li>
    <li><span class="comment-author">小赵 @ 3天前：</span> 能讲讲ConcurrentHashMap吗？</li>
    <li><span class="comment-author">小陈 @ 3天前：</span> 期待新文章！</li>
    <li><span class="comment-author">小刘 @ 3天前：</span> 讲得很清楚！</li>
    <li><span class="comment-author">小孙 @ 4天前：</span> 能出个Spring专题吗？</li>
    <li><span class="comment-author">小周 @ 4天前：</span> HashMap和HashTable的区别讲得很明白！</li>
    <li><span class="comment-author">小吴 @ 5天前：</span> 面试必备，感谢！</li>
    <li><span class="comment-author">小郑 @ 5天前：</span> 能讲讲JVM吗？</li>
    <li><span class="comment-author">小冯 @ 6天前：</span> 希望多点实战案例！</li>
    <li><span class="comment-author">小朱 @ 6天前：</span> 支持原创！</li>
    <li><span class="comment-author">小何 @ 7天前：</span> 博主回复好快！</li>
    <li><span class="comment-author">小吕 @ 7天前：</span> 内容很详细，赞！</li>
    <li><span class="comment-author">小施 @ 8天前：</span> 请问xxx怎么实现？</li>
    <li><span class="comment-author">小沈 @ 8天前：</span> 文章排版很舒服！</li>
    <li><span class="comment-author">小韩 @ 9天前：</span> 祝博主越来越好！</li>
  </ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">杰克飞 @ 梦想书架</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2025/07/21/java高频面试题/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>
<script src="/js/lib/lozad.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.0/anime.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script>
<script src="/js/lib/quicklink.umd.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
