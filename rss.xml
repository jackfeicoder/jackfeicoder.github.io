<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>杰克飞的博客</title>
        <link>http://example.com</link>
        <description>一个用Hexo搭建的个人博客</description>
        <language>zh-CN</language>
        <pubDate>Mon, 21 Jul 2025 00:00:00 +0800</pubDate>
        <lastBuildDate>Mon, 21 Jul 2025 00:00:00 +0800</lastBuildDate>
        <category>HashMap</category>
        <category>线程安全</category>
        <category>HashSet</category>
        <category>HashTable</category>
        <category>Hexo</category>
        <category>博客</category>
        <category>实现原理</category>
        <category>ArrayList</category>
        <category>put方法</category>
        <category>扩容</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
            <title>java高频面试题</title>
            <link>http://example.com/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
            <category>Hexo</category>
            <category>博客</category>
            <pubDate>Mon, 21 Jul 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;JavaSE&#34;&gt;&lt;a href=&#34;#JavaSE&#34; class=&#34;headerlink&#34; title=&#34;JavaSE&#34;&gt;&lt;/a&gt;JavaSE&lt;/h2&gt;&lt;h3 id=&#34;1-什么是JAVA&#34;&gt;&lt;a href=&#34;#1-什么是JAVA&#34; class=&#34;headerlink&#34; title=&#34;1. 什么是JAVA?&#34;&gt;&lt;/a&gt;1. 什么是JAVA?&lt;/h3&gt;&lt;p&gt;Java 是一门面向对象的编程语言，吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。比较重要的特点就是跨平台性，只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。还有面向对象，多线程，JVM等这些让Java变得高效。Java最适合用来做后端开发，有很多成熟的技术栈，比如Springboot,springcloud等,&lt;/p&gt;
&lt;h3 id=&#34;2-Java-有哪些数据类型？&#34;&gt;&lt;a href=&#34;#2-Java-有哪些数据类型？&#34; class=&#34;headerlink&#34; title=&#34;2. Java 有哪些数据类型？&#34;&gt;&lt;/a&gt;2. Java 有哪些数据类型？&lt;/h3&gt;&lt;p&gt;基本数据类型和引用数据类型两大类。基本数据类型有：数值型（byte,short,int,long）、浮点型(float,double)、布尔型boolean.引用数据类型有类，数组和接口&lt;/p&gt;
&lt;h3 id=&#34;3-面向对象编程有哪些特性？&#34;&gt;&lt;a href=&#34;#3-面向对象编程有哪些特性？&#34; class=&#34;headerlink&#34; title=&#34;3. 面向对象编程有哪些特性？&#34;&gt;&lt;/a&gt;3. 面向对象编程有哪些特性？&lt;/h3&gt;&lt;p&gt;封装、继承和多态。封装就是把一些属性和方法捆在一起形成一个类，我们可以实例化这个类变成对象，对象可以设置和获取属性，调用方法。开发中就是对象之间的交互。继承就是子类获得父类的所有属性和方法，子类还可以进行扩充或者方法重写。多态就是java运行时可以根据对象类型产生不同的结果。子类需要继承父类并重写父类方法，父类引用指向子类对象。&lt;/p&gt;
&lt;h3 id=&#34;4-抽象类和接口有什么区别？&#34;&gt;&lt;a href=&#34;#4-抽象类和接口有什么区别？&#34; class=&#34;headerlink&#34; title=&#34;4. 抽象类和接口有什么区别？&#34;&gt;&lt;/a&gt;4. 抽象类和接口有什么区别？&lt;/h3&gt;&lt;p&gt;一个类只能继承一个抽象类；但一个类可以实现多个接口。比如我们创建线程类的时候一般用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。抽象类符合 is-a 的关系，而接口更像是 has-a 的关系。比如说一个类可以序列化的时候，它只需要实现 Serializable 接口，代表它有这个功能，而不是继承一个序列化类。&lt;/p&gt;
&lt;h3 id=&#34;5-和-equals-的区别？&#34;&gt;&lt;a href=&#34;#5-和-equals-的区别？&#34; class=&#34;headerlink&#34; title=&#34;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&#34;&gt;&lt;/a&gt;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&lt;/h3&gt;&lt;h2 id=&#34;开放性问题&#34;&gt;&lt;a href=&#34;#开放性问题&#34; class=&#34;headerlink&#34; title=&#34;开放性问题&#34;&gt;&lt;/a&gt;开放性问题&lt;/h2&gt;&lt;h3 id=&#34;1-先做个简单的自我介绍吧！&#34;&gt;&lt;a href=&#34;#1-先做个简单的自我介绍吧！&#34; class=&#34;headerlink&#34; title=&#34;1. 先做个简单的自我介绍吧！&#34;&gt;&lt;/a&gt;1. 先做个简单的自我介绍吧！&lt;/h3&gt;&lt;p&gt;面试官您好！我叫郝泽飞，是哈尔滨工程大学计算机专业的学生，现在在读研一，在校期间，我成绩专业排名前10%,大学期间参加了多个竞赛并取得奖项，通过了英语四六级。技术方面，大一期间我学习了计算机的基础知识，像数据结构，C++和JAVA的基础语法，大二以后开始学Java技术栈，比如Spring Boot、MyBatis-Plus、MySQL、Redis、RabbitMQ等，后来又做了一些项目，微服务架构的Pm-hub,大模型应用开发的派聪明。生活中我是一个比较积极乐观的人，我非常期待能在贵公司的开发岗位中，将所学的技术应用于实际业务，我的介绍完毕，谢谢！&lt;/p&gt;
&lt;h3 id=&#34;2-说说你的这个pm-hub项目吧？&#34;&gt;&lt;a href=&#34;#2-说说你的这个pm-hub项目吧？&#34; class=&#34;headerlink&#34; title=&#34;2. 说说你的这个pm-hub项目吧？&#34;&gt;&lt;/a&gt;2. 说说你的这个pm-hub项目吧？&lt;/h3&gt;&lt;p&gt;（项目背景、解决问题、职责任务。2项目使用的技术栈、技术架构、是否使用微服务，项目具体功能细节。技术具体实现细节。项目存在的问题和完善解决方案&lt;br&gt;项目具体功能的优化（如查询是在数据库中扫表查询吗）项目最有挑战的模块，如何解决，项目增大10倍的qps，如何设计？项目上线后出现频繁fullGc，怎么解决？）&lt;br&gt;好的，这个项目是我（跟室友&amp;#x2F;同学&amp;#x2F;老师一起做的。&amp;#x2F;参考开源项目做的一个二次开发），做这个项目是为了。。。，考虑到—所以项目中用到了***，，当时我负责的部分是。发现速度&amp;#x2F;可用性不够，进行了SQL优化，分布式锁，seata事务,skywalking监控等。第二个项目是。。，因为最近AI比较流行，我就想学一些新技术，跟上时代的步伐，这个项目是参考开源项目，用了，，技术栈，实现了，，功能，优化，解决，，问题。以上是我的项目介绍。&lt;/p&gt;
&lt;h3 id=&#34;3-项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;a href=&#34;#3-项目中遇到最大的困难？怎么解决的？&#34; class=&#34;headerlink&#34; title=&#34;3. 项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;/a&gt;3. 项目中遇到最大的困难？怎么解决的？&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;4-平时是怎么学习的？&#34;&gt;&lt;a href=&#34;#4-平时是怎么学习的？&#34; class=&#34;headerlink&#34; title=&#34;4. 平时是怎么学习的？&#34;&gt;&lt;/a&gt;4. 平时是怎么学习的？&lt;/h3&gt;&lt;p&gt;比如我学一门新技术吧，首先看官方文档，如果晦涩难懂就会找教程&amp;#x2F;视频，还会使用AI工具（豆包，chatGPT）详细解释辅助理解，然后做个demo用到项目中，大学期间我大多是在开源社区学习还有网课。&lt;/p&gt;
&lt;h3 id=&#34;5-人生发展、最近五年职业规划&#34;&gt;&lt;a href=&#34;#5-人生发展、最近五年职业规划&#34; class=&#34;headerlink&#34; title=&#34;5. 人生发展、最近五年职业规划&#34;&gt;&lt;/a&gt;5. 人生发展、最近五年职业规划&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;6-什么时候能到岗？&#34;&gt;&lt;a href=&#34;#6-什么时候能到岗？&#34; class=&#34;headerlink&#34; title=&#34;6. 什么时候能到岗？&#34;&gt;&lt;/a&gt;6. 什么时候能到岗？&lt;/h3&gt;&lt;h3 id=&#34;7-薪资要求？&#34;&gt;&lt;a href=&#34;#7-薪资要求？&#34; class=&#34;headerlink&#34; title=&#34;7. 薪资要求？&#34;&gt;&lt;/a&gt;7. 薪资要求？&lt;/h3&gt;&lt;h2 id=&#34;反问：&#34;&gt;&lt;a href=&#34;#反问：&#34; class=&#34;headerlink&#34; title=&#34;反问：&#34;&gt;&lt;/a&gt;反问：&lt;/h2&gt;&lt;h3 id=&#34;一面&#34;&gt;&lt;a href=&#34;#一面&#34; class=&#34;headerlink&#34; title=&#34;一面&#34;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;部门主营业务和使用的技术栈是什么？&lt;/li&gt;
&lt;li&gt;您觉得我的专业能力有哪些需要提升的&lt;/li&gt;
&lt;li&gt;刚才关于xx问题，我想问下您的思路。&lt;/li&gt;
&lt;li&gt;面试一般多久会出通知和结果呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二面&#34;&gt;&lt;a href=&#34;#二面&#34; class=&#34;headerlink&#34; title=&#34;二面&#34;&gt;&lt;/a&gt;二面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面试候选人，尤其是校招生的时候，最看重什么？&lt;/li&gt;
&lt;li&gt;您对进入您团队的成员的要求是什么？或者说需要怎样的品质胜任这个职位？&lt;/li&gt;
&lt;li&gt;我很好奇职位的晋升机制和发展路径。公司对信任的培养是怎么样的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;HR面-三面&#34;&gt;&lt;a href=&#34;#HR面-三面&#34; class=&#34;headerlink&#34; title=&#34;HR面&amp;#x2F;三面&#34;&gt;&lt;/a&gt;HR面&amp;#x2F;三面&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;企业文化&lt;/li&gt;
&lt;li&gt;代表性产品&lt;/li&gt;
&lt;li&gt;历年薪资&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</guid>
            <title>ArrayList底层的实现原理是什么？</title>
            <link>http://example.com/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</link>
            <category>实现原理</category>
            <category>ArrayList</category>
            <pubDate>Sat, 19 Jul 2025 16:55:58 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;ArrayList底层是动态数组，支持自动扩容和高效随机访问。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;ArrayList底层是一个&lt;strong&gt;动态数组&lt;/strong&gt;，&lt;strong&gt;初始容量是0&lt;/strong&gt;，&lt;strong&gt;当第一次添加数据&lt;/strong&gt;才会初始化容量为10，&lt;strong&gt;扩容&lt;/strong&gt;是原来容量的1.5倍，每次扩容都需要&lt;strong&gt;拷贝数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;添加数据时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断元素个数size+1后是否大于总容量，如果大于就调用grow方法扩容，把旧数组拷贝到扩容后的新数组中，再把新元素放在size位置上，返回true。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ArrayList list&amp;#x3D;new ArrayList(10)中的list扩容几次?&lt;/strong&gt;&lt;br&gt;声明和实例了一个ArrayList，指定了容量为10，未扩容。构造方法中传参initCapcity,是多少就初始化多少容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现数组和List之间的转换？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组转List:           &lt;strong&gt;Arrays工具类的asList方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;List转数组，使用&lt;strong&gt;List的toArray方法&lt;/strong&gt;。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试官再问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Arrays.asList转List后，如果修改了数组内容，list受影响吗？&lt;/li&gt;
&lt;li&gt;List用toArray转数组后，如果修改了List内容，数组受影响吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数组转List受影响&lt;/strong&gt;，因为它的&lt;strong&gt;底层使用的Arrays类中的一个内部类ArrayList来构造的集合&lt;/strong&gt;，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，&lt;strong&gt;最终指向的都是同一个内存地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List转数组不受影响&lt;/strong&gt;，在底层是它是进行了数组的拷贝。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
            <title>HashSet，HashTable与HashMap的区别</title>
            <link>http://example.com/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
            <category>HashMap</category>
            <category>HashSet</category>
            <category>HashTable</category>
            <pubDate>Sat, 19 Jul 2025 16:55:48 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;对比HashSet、HashMap、HashTable三者的底层结构、线程安全性、常用方法及应用场景。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;数据结构上HashSet底层是一个HashMap，只存储键不存储值；HashMap是一个哈希表，由数组+链表+红黑树组成，存储键值对。HashSet不能重复，只允许一个null元素，实现了Set接口；HashMap键只有一个null值，值可以有多个，实现Map接口，它们性能一致。&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashSet：add, remove, contains, size&lt;/li&gt;
&lt;li&gt;HashMap: put(), get(), remove(), containsKey(), size()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HashTable 是 Java 早期的线程安全哈希表实现，因同步开销大、设计局限性（如不支持 null、扩容效率低），已逐渐被淘汰。HashMap 作为更现代的实现，性能更优、功能更灵活，而多线程场景下推荐使用 ConcurrentHashMap（分段锁优化，性能远超 HashTable）。&lt;/p&gt;
&lt;p&gt;你能自己设计实现一个 HashMap 吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，实现一个 hash 函数，对键的 hashCode 进行扰动&lt;/li&gt;
&lt;li&gt;第二步，实现一个拉链法的方法来解决哈希冲突&lt;/li&gt;
&lt;li&gt;第三步，扩容后，重新计算哈希值，将元素放到新的数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;讲讲 LinkedHashMap 怎么实现有序的？&lt;br&gt;在 HashMap 的基础上维护了一个双向链表，通过 before 和 after 标识前置节点和后置节点。从而实现插入和访问有序。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</guid>
            <title>HashMap 是线程安全的吗？</title>
            <link>http://example.com/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</link>
            <category>HashMap</category>
            <category>线程安全</category>
            <pubDate>Sat, 19 Jul 2025 16:55:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap 不是线程安全的，多线程环境下可能出现死循环、数据丢失等问题。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap 不是线程安全的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JDK7 中的 HashMap 使用的是&lt;strong&gt;头插法&lt;/strong&gt;来处理链表，在&lt;strong&gt;多线程环境下扩容会出现环形链表，造成死循环&lt;/strong&gt;。JDK 8 时通过&lt;strong&gt;尾插法修复&lt;/strong&gt;了这个问题，扩容时会保持链表原来的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程在进行 &lt;strong&gt;put 元素&lt;/strong&gt;的时候，&lt;strong&gt;可能会导致元素丢失&lt;/strong&gt;。因为put操作&lt;strong&gt;不是原子的&lt;/strong&gt;。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素&lt;strong&gt;先插入的元素被覆盖而丢失&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元&lt;strong&gt;素个数超出阈值而扩容&lt;/strong&gt;，线程 2 此时执行 get 就可能获取不到元素。线程 1 执行完 table &amp;#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引元素可能就 get 不到了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</guid>
            <title>HashMap的put方法的具体流程？</title>
            <link>http://example.com/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</link>
            <category>HashMap</category>
            <category>put方法</category>
            <pubDate>Sat, 19 Jul 2025 16:55:24 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;详细解析HashMap的put方法执行流程，包括哈希计算、索引定位、冲突处理、链表与红黑树转换等。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;&lt;strong&gt;第一步：检查数组是否为空&lt;/strong&gt;&lt;br&gt;首次&lt;code&gt;put&lt;/code&gt;时，调用&lt;code&gt;resize()&lt;/code&gt;初始化数组，默认容量为16，负载因子为0.75。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：计算键的哈希值&lt;/strong&gt;&lt;br&gt;具体是将键的hashCode异或hashCode右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：根据键的哈希值计算数组索引&lt;/strong&gt;&lt;br&gt;具体是将键的哈希值与上数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高，所以用与运算代替模运算，但前提是数组长度是2的N次幂）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：检查数组索引对应槽位的情况&lt;/strong&gt;&lt;br&gt;如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只重写元素的equals方法没重写hashCode，put的时候会发生什么？&lt;/strong&gt;&lt;br&gt;如果只重写equals方法，没有重写hashCode方法，那么会导致equals相等的两个对象，hashCode不相等，这样的话，两个对象会被put到数组中不同的位置，导致get的时候，无法获取到正确的值。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</guid>
            <title>HashMap实现原理？</title>
            <link>http://example.com/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</link>
            <category>HashMap</category>
            <category>实现原理</category>
            <pubDate>Sat, 19 Jul 2025 16:55:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前是数组+链表，之后是数组+链表+红黑树。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前，是数组+链表。之后是数组+链表+红黑树。&lt;/p&gt;
&lt;p&gt;存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果key相同，覆盖原值。&lt;/li&gt;
&lt;li&gt;key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。&lt;/p&gt;
&lt;p&gt;源码：初始容量16，加载因子0.75，扩容&amp;#x3D;之积。懒加载，不初始化容量。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid>
            <title>讲一讲HashMap的扩容机制</title>
            <link>http://example.com/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link>
            <category>HashMap</category>
            <category>扩容</category>
            <pubDate>Sat, 19 Jul 2025 16:28:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap 在元素个数超过阈值时会触发扩容（resize）操作，这个阈值是数组容量 * 负载因子。扩容的过程包括新数组创建和元素迁移。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;当哈希表中元素个数超过阈值时会触发扩容 resize 方法，这个阈值是 数组容量 * 负载因子，数组容量初始是16，负载因子默认是0.75。&lt;/p&gt;
&lt;p&gt;扩容时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建一个新数组&lt;/strong&gt;，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移元素&lt;/strong&gt;，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过 &lt;code&gt;e.hash &amp;amp; (newCap新容量 - 1)&lt;/code&gt; 计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为&lt;strong&gt;低位链&lt;/strong&gt;和&lt;strong&gt;高位链&lt;/strong&gt;，避免重新哈希带来性能损耗。如果 &lt;code&gt;e.hash &amp;amp; oldCap == 0&lt;/code&gt;（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种方式，HashMap 能够高效地完成扩容和数据迁移，保证查询和插入的性能。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/18/hello-world/</guid>
            <title>你好，世界</title>
            <link>http://example.com/2025/07/18/hello-world/</link>
            <category>Hexo</category>
            <category>博客</category>
            <pubDate>Fri, 18 Jul 2025 17:26:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;欢迎使用 Hexo！这是你的第一篇博客文章。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;你好，欢迎来到我的个人博客！&lt;/p&gt;
&lt;p&gt;这是我用 Hexo 搭建的第一个博客页面。你可以在这里记录生活、学习、技术心得等内容。&lt;/p&gt;
&lt;p&gt;如果你遇到任何问题，可以查阅 Hexo 官方文档，或者在评论区留言交流。&lt;/p&gt;
&lt;p&gt;祝你写作愉快！&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
