<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>杰克飞的博客</title>
        <link>http://example.com</link>
        <description>一个用Hexo搭建的个人博客</description>
        <language>zh-CN</language>
        <pubDate>Fri, 01 Aug 2025 10:25:29 +0800</pubDate>
        <lastBuildDate>Fri, 01 Aug 2025 10:25:29 +0800</lastBuildDate>
        <category>ArrayList</category>
        <category>实现原理</category>
        <category>HashMap</category>
        <category>put方法</category>
        <category>线程安全</category>
        <category>HashSet</category>
        <category>HashTable</category>
        <category>AI</category>
        <category>Java</category>
        <category>LangChain4j</category>
        <category>实战教程</category>
        <category>Hexo</category>
        <category>博客</category>
        <category>八股</category>
        <category>牛客</category>
        <category>游戏</category>
        <category>Steam</category>
        <category>算法</category>
        <category>力扣</category>
        <category>扩容</category>
        <item>
            <guid isPermalink="true">http://example.com/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F/</guid>
            <title>力扣算法hot100刷题路线</title>
            <link>http://example.com/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F/</link>
            <category>算法</category>
            <category>力扣</category>
            <pubDate>Fri, 01 Aug 2025 10:25:29 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;对于算法题，按题型类别刷题才会更有成效，因此我这里在网上搜索并参考了下 “🔥 LeetCode 热题 HOT 100” 的题型归类，并在其基础上做了一定的完善，希望能够记录自己的刷题历程，有所收获！具体参考如下文章：
    【热题】LeetCode 热题 HOT 100分类+题解
    leetcode HOT100总结
    leetcode算法总结 —— HOT 100分类整理
我这里只做了LeetCode 热题 HOT 100中的 e a s y \color&amp;#123;green&amp;#125;&amp;#123;easy&amp;#125; easy 和 m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 的题， h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 的题难度较大暂时都跳过了（题目上都有 删除线 标识），大部分面试也不会考察，后面有精力再做研究。
题目后带有 ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★ 标识的表示后续还要继续反复练习，题目可能不难，但有时可能会忽略其中的一些刷题细节而导致错误
每一种类型的题目，并不绝对是按照题号递增的顺序来排列的（当然大部分都是按题号大小排好序的）。
因为有些题目其实很相似，放在一起更好，便单独对他们做了调整，比如 [647. 回文子串] 和 [5. 最长回文子串]
这里面的每一道题，都有相对应我自己日常整理的题解，具体可参考：我的博客-LeetCode专栏题解，在里面搜对应题号即可 ~
大家在浏览时，可以通过下方⬇️按题型分类汇总后的【目录】来实现快速跳转，更方便、更快捷的刷题。
同时这篇文章我也是我花费了很长的时间，对比多篇文章来总结和编写的，希望对大家有所帮助。
在这里插入图片描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文章目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    介绍
    一、链表（共11题）
            [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?favorite=2cktkvj)
            [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?favorite=2cktkvj)
            [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/?favorite=2cktkvj)
            [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/?favorite=2cktkvj)
            [148. 排序链表](https://leetcode.cn/problems/sort-list/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?favorite=2cktkvj)
            [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/description/)
            [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
    二、二叉树（共14题，含2道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            做题心得：
            [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/?favorite=2cktkvj)
            [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/?favorite=2cktkvj) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
            [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?favorite=2cktkvj)
            [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?favorite=2cktkvj) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            ~~[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/?favorite=2cktkvj)
            [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/?favorite=2cktkvj)
        新版 hot100 题目扩充（以下题目列表不断更新ing~）：
            [LeetCode 108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)
    三、DFS/BFS（共6题，含3道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            [79. 单词搜索](https://leetcode.cn/problems/word-search/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/description/)
            ~~[207. 课程表](https://leetcode.cn/problems/course-schedule/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            ~~[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/solutions/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    四、递归/回溯（共6题，含1道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)
            [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [39. 组合总和](https://leetcode.cn/problems/combination-sum/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [46. 全排列](https://leetcode.cn/problems/permutations/?favorite=2cktkvj) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [78. 子集](https://leetcode.cn/problems/subsets/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[399. 除法求值](https://leetcode.cn/problems/evaluate-division/description/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
    五、Hash表/map（共3题）
            [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)
            [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)
            [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?favorite=2cktkvj)
    六、位运算（共3题）
            [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/description/)
            [338. 比特位计数](https://leetcode.cn/problems/counting-bits/description/)
            [461. 汉明距离](https://leetcode.cn/problems/hamming-distance/description/)
    七、数组（共5题）
            ~~[15. 三数之和](https://leetcode.cn/problems/3sum/description/?favorite=2cktkvj)~~ 待研究
            [31. 下一个排列](https://leetcode.cn/problems/next-permutation/description/) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            [169. 多数元素](https://leetcode.cn/problems/majority-element/description/)
            [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    八、二分查找（共5题，含1道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/) （ h a r d 题 \color&amp;#123;red&amp;#125;&amp;#123;hard题&amp;#125; hard题）
            [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/) ★★ \color&amp;#123;red&amp;#125;&amp;#123;★★&amp;#125; ★★
            [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?favorite=2cktkvj)
            [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/) ★★ \color&amp;#123;red&amp;#125;&amp;#123;★★&amp;#125; ★★
        新版 hot100 题目扩充（以下题目列表不断更新ing~）：
            [LeetCode 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)
    九、双指针/三指针（共3题）
            [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/)
            [75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/) ★★ \color&amp;#123;red&amp;#125;&amp;#123;★★&amp;#125; ★★
            [283. 移动零](https://leetcode.cn/problems/move-zeroes/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    十、栈/单调栈（共6题，含2道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
            ~~[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            ~~[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/?favorite=2cktkvj)~~ （ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [155. 最小栈](https://leetcode.cn/problems/min-stack/description/)
            [394. 字符串解码](https://leetcode.cn/problems/decode-string/description/) ★★ \color&amp;#123;red&amp;#125;&amp;#123;★★&amp;#125; ★★
            [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    十一、排序（共4题）
            [56. 合并区间](https://leetcode.cn/problems/merge-intervals/description/?favorite=2cktkvj) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/description/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
    十二、前缀和（共1题）
            [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/)
    十三、字典树/前缀树（共1题）
            [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
    十四、LRU缓存（共1题）
            [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/?favorite=2cktkvj) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
    十五、动态规划（共23题，含6道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            ~~[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/description/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            ~~[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)
            [62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)
            [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/?favorite=2cktkvj)
            [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
            ~~[72. 编辑距离](https://leetcode.cn/problems/edit-distance/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)
            [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)
            [139. 单词拆分](https://leetcode.cn/problems/word-break/?favorite=2cktkvj) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
            [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)
            ~~[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/description/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
            [221. 最大正方形](https://leetcode.cn/problems/maximal-square/description/)
            [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/?favorite=2cktkvj) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            ~~[312. 戳气球](https://leetcode.cn/problems/burst-balloons/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            ~~[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
            [494. 目标和](https://leetcode.cn/problems/target-sum/description/) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
            [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/description/?favorite=2cktkvj) ★★ \color&amp;#123;red&amp;#125;&amp;#123;★★&amp;#125; ★★
            [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)
    十六、滑动窗口（共4题，含2道 h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题）
            [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) ★★★ \color&amp;#123;red&amp;#125;&amp;#123;★★★&amp;#125; ★★★
            ~~[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            ~~[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/?favorite=2cktkvj)~~（ h a r d \color&amp;#123;red&amp;#125;&amp;#123;hard&amp;#125; hard 题，暂时跳过）
            [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?favorite=2cktkvj) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    十七、贪心（共1题）
            [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/description/)
    十八、数学（共1题）
            [48. 旋转图像](https://leetcode.cn/problems/rotate-image/solutions/?favorite=2cktkvj) ★ \color&amp;#123;red&amp;#125;&amp;#123;★&amp;#125; ★
    十九、其它（共2题，含1道 力扣 V I P 专属 \color&amp;#123;red&amp;#125;&amp;#123;力扣VIP专属&amp;#125; 力扣VIP专属 题）
            ~~[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/?favorite=2cktkvj)~~（ 力扣 V I P 专属 \color&amp;#123;red&amp;#125;&amp;#123;力扣VIP专属&amp;#125; 力扣VIP专属 题，暂时跳过）
            ~~[621. 任务调度器](https://leetcode.cn/problems/task-scheduler/solutions/?favorite=2cktkvj)~~（ m i d d l e \color&amp;#123;orange&amp;#125;&amp;#123;middle&amp;#125; middle 题，暂时跳过）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一、链表（共11题）&lt;br&gt;2. 两数相加 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;注意分别处理 【相同数位上的两数之和 val1 + val2，并加上上一轮新产生的进位值 carry：sum &amp;#x3D; val1 + val2 + carry】 与 【这一轮新产生的进位值 carry &amp;#x3D; carry &amp;#x2F; 10】。&lt;/p&gt;
&lt;p&gt;并且当两链表 l1 和 l2 都遍历完后，记得额外处理最后的一次进位。例如：99+9&amp;#x3D;108，这里需要单独处理百位最后的1。&lt;br&gt;19. 删除链表的倒数第 N 个结点 ★ \color{red}{★} ★&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意 先创建虚拟头节点 dummy，且 dummy.Next = head。防止当链表头节点head为待删除节点时，删除该节点后链表头head为空的情况（边界情况）
    如果我们能得到倒数第n个节点的前驱节点而不是倒数第n个节点，那么删除操作会更加方便。因此我们可以考虑在初始时创建 快慢指针 fast和 slow，并将这两个指针指向哑节点 dummy，其余操作不变。这样一来，当 fast遍历到链表末尾时，slow的下一个节点就是我们需要删除的节点。
快指针先走n步，然后快指针和慢指针再每次各走一步
删除倒数第n个节点：slow.Next = slow.Next.Next，注意不是 slow.Next = fast
最后返回虚拟头节点的后继节点：dummy.Next

类似题目有：

    237. 删除链表中的节点
    剑指 Offer 18. 删除链表的节点
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;21&#34;&gt;
&lt;li&gt;合并两个有序链表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种方法：递归 和 迭代 。&lt;br&gt;23. 合并K个升序链表&lt;/p&gt;
&lt;p&gt;在 21. 合并两个有序链表 的基础上，使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;递归法（推荐，时间复杂度更优），参考 LeetCode题解-分治法
    时间复杂度：O(nlog⁡k)，其中 k 为 lists 的长度，n 为所有链表的节点数之和。每个节点参与链表合并的次数为 O(log⁡k) 次，一共有 n 个节点，所以总的时间复杂度为 O(nlog⁡k)。
    空间复杂度：O(log⁡k) 递归深度为 O(log⁡k)，需要用到 O(log⁡k)的栈空间。
迭代法（不推荐，时间复杂度较高）：遍历链表数组，两两合并。
    时间复杂度 O(nk)，时间复杂度高于递归法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有两个细节需要特别注意：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在方法 mergeKLists()中，初始化链表时，采用如下写法：

var res *ListNode
// res := &amp;amp;ListNode&amp;#123;&amp;#125; // 错误写法，会初始化res为0值，导致结果集多一个0值
for i := 0; i &amp;lt; len(lists); i++ &amp;#123;
    res = mergeTwoLists(res, lists[i])
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6

而在方法 mergeTwoLists()中，初始化虚拟节点 head时，则为：

// var head *ListNode // 错误写法 会空指针异常
head := &amp;amp;ListNode&amp;#123;&amp;#125;
cur := head
...
 return head.Next
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;141&#34;&gt;
&lt;li&gt;环形链表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;判断快慢指针是否相遇（快指针两步，慢指针一步）&lt;br&gt;142. 环形链表 II&lt;/p&gt;
&lt;p&gt;先判断快慢指针是否相遇（快指针两步，慢指针一步），若相遇则将快指针重置到头结点，然后快慢指针每次各走一步，直至相遇&lt;br&gt;148. 排序链表 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;题目要求时间复杂度为：O(NlogN)，故采用归并排序的思想（拆分→排序→合并）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;先通过快慢指针找到链表中点，并切割为前后两部分
不断递归上述过程，直至最终将链表切割为多个长度为1的链表
最后不断合并这多个长度为1的链表（此比较大小并合并的过程，与 21. 合并两个有序链表 一样）
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;160&#34;&gt;
&lt;li&gt;相交链表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用双指针pA 、pB分别遍历两个链表，pA对链表A遍历结束后就去遍历链表B，pB对链表B遍历结束后就遍历链表A。当 pA &amp;#x3D;&amp;#x3D; pB 时，相遇节点即为交点，因为两个指针分别移动的步数是一样的。&lt;br&gt;206. 反转链表&lt;/p&gt;
&lt;p&gt;注意go中要用该方式初始化 var pre, mid, end *ListNode &amp;#x3D; nil, head, nil，而不是 pre, mid, end :&amp;#x3D; &amp;amp;ListNode{}, head, &amp;amp;ListNode{}，否则会在反转后的尾节点添加值为0的 “空节点”，导致错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类似题目：

    92. 反转链表 II，反转指定区间内的链表
    25. K 个一组翻转链表，肃然是困难题，但是也是常考的高频题
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;234&#34;&gt;
&lt;li&gt;回文链表 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;先通过快慢指针找链表中点，划分为前半部分和后半部分；注意寻找链表中点时的判断条件：for fast.Next != nil &amp;amp;&amp;amp; fast.Next.Next != nil &amp;#123;...&amp;#125;
再反转后半部分链表；
最后将两部分链表的节点逐个比较
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;406&#34;&gt;
&lt;li&gt;根据身高重建队列（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;br&gt;二、二叉树（共14题，含2道 h a r d \color{red}{hard} hard 题）&lt;br&gt;做题心得：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了
是的，只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。
跟树相关的题，一般有两种解法：递归&amp;amp;迭代：递归用dfs，而迭代用bfs（队列）
Go 语言的深度优先遍历算法可以采用闭包函数实现，这样省去了许多参数的传递与全局变量的声明。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，关于递归，看到该题讨论区有一个评论，对于递归的理解很有帮助，特意截图留念。&lt;br&gt;在这里插入图片描述&lt;br&gt;94. 二叉树的中序遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;递归 or 迭代（利用栈的先进后出特性），必会

类似题目：

    144. 二叉树的前序遍历 利用栈，类似于中序遍历
    145. 二叉树的后序遍历 利用栈，有一个标记根节点的flagMap，用来标记第几次经过某个根节点root，只有第二次经过某个根节点时，才存储其结果，并将其出栈置空。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;98&#34;&gt;
&lt;li&gt;验证二叉搜索树 ★★★ \color{red}{★★★} ★★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用二叉搜索树的中序遍历为升序序列这一性质，来递归验证。&lt;/p&gt;
&lt;p&gt;方法一：官方题解 通过限制每个子树中的上下界（lower和upper）来判断，需额外引入常量：math.MinInt64, math.MaxInt64，不推荐，也没必要。&lt;/p&gt;
&lt;p&gt;方法二：双指针比较法（pre和node），参考 B站视频题解，不需额外引入常量，而只需通过一个pre指针，在向上回溯的过程中，不断保存之前的节点用于比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先【不断向左子树递归】直至最后空节点：left := dfs(node.Left)
然后再自底向上【回溯】的过程中，pre每次保存的都是之前上一层栈空间中的根节点，并不断将当前node节点和pre节点的值做比较：if pre != nil &amp;amp;&amp;amp; node.Val &amp;lt;= pre.Val &amp;#123; return false &amp;#125;
    当 node = root 时，pre = root.Left，pre的值应永远小于node的值（满足二叉搜索树中，左子节点值 &amp;lt; 根节点值）
    当 node = root.Right时，pre = root，pre的值应永远小于node的值（满足二叉搜索树中，根节点值 &amp;lt; 右子节点值）
保存当前节点node到pre中，用于下层递归中做比较
然后不断向右子树递归：right := dfs(node.Right)
最后返回：return left &amp;amp;&amp;amp; right，判断当前节点的左右子树是否分别是二叉搜索树
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;101&#34;&gt;
&lt;li&gt;对称二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;解法1 递归：
    if 左节点和右节点均为空，说明遍历完了，返回 true
    否则说明左右两个节点并非同时为空，那么判断：if 左节点和右节点其中一个为空（也就是一个为空，一个非空，那肯定不对称），或者左节点值不等于右节点值（不对称），返回 false
    最后继续递归下探：
    return recur(左节点的左子节点，右节点的右子节点) &amp;amp;&amp;amp; recur(左节点的右子节点，右节点的左子节点)
解法2 迭代：
层序遍历：通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，其中的条件判断和递归的逻辑是一样的。如动画所示：
101. 对称二叉树（迭代法）
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;102&#34;&gt;
&lt;li&gt;二叉树的层序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BFS层序遍历使用 queue 队列（先进先出）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;初始化队列，并将非空根节点 root入队
判断队列大小是否非零，非零则进入外层for循环 for len(queue) &amp;gt; 0 &amp;#123;

    由于需要按层返回二维数组结果集，因此要提前缓存当前这一层的节点数 length := len(queue)，并创建用于保存这一层结果的临时数组 subRes。

    进入内循环 for i := 0; i &amp;lt; length; i++ &amp;#123;
        获取队头节点 root = queue[0]，将其 root.Val值保存到临时数组 subRes中，再将该节点出队（它的使命已完成）
        将 root的非空左子节点 root.Left和非空右子节点 root.Right入队

    将保存当前这一层结果集的临时数组 subRes追加到二维数组 res中
返回保存最终结果集的二维数组 res
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;104&#34;&gt;
&lt;li&gt;二叉树的最大深度 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;递归法（dfs）
迭代法（bfs）：利用队列（先进先出）。内层for循环保留上一层节点数，避免内层循环因为对queue进行append操作，导致队列元素个数发生变化
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;105&#34;&gt;
&lt;li&gt;从前序与中序遍历序列构造二叉树 ★★★ \color{red}{★★★} ★★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐掌握递归法，迭代法比较难理解，不过都需要作图理解和推敲：左右子树分别在 前序&amp;#x2F;中序 遍历中的左右边界。具体代码可参考：我的题解&lt;/p&gt;
&lt;p&gt;递归法：&lt;br&gt;先通过遍历inorder数组，找到根节点（值为preorder[0]）位于中序遍历中的下标位置 i。然后，根据中序遍历中根节点的下标位置 i，分别构建root的左右子树 …&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 分别确定&amp;quot;左子树&amp;quot;在前序和中序遍历中的左右边界
    1.1 确定前序遍历中左子树的左右边界：
        root = preorder[0]是根节点，所以前序遍历中左子树的左边界是1；
        然后根据根节点在中序遍历中的下标 i，可知【中序遍历中左子树的范围是0~ i】，由此可确定中序遍历中左子树的长度是 i（其实 i 的值也等于 len(inorder[:i])，但为了便于理解及简化代码量，就使用 i 来作为左子树的长度），又因为前序遍历中左子树的左边界为1，所以可得前序遍历中左子树的右边界为：i+1（或 len(inorder[:i])+1）
    确定中序遍历中左子树的左右边界：由上面的分析中的【中序遍历中左子树的范围是0~ i】可得：inorder[:i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后可得：root.Left &amp;#x3D; buildTree(preorder[1:i+1], inorder[:i])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 分别确定&amp;quot;右子树&amp;quot;在前序和中序遍历中的左右边界
    2.1 确定前序遍历中右子树的左右边界：
        由 1.1 可知当前左子树的长度是 i（其实 i 的值也等于 len(inorder[:i])，但为了便于理解及简化代码量，就使用 i 来作为左子树的长度），且根节点也占一个位置，因此可得前序遍历中右子树的左边界为：i+1（或 len(inorder[:i])+1），右子树右边界一直到preorder末尾
    2.2 确定中序遍历中右子树的左右边界：
    由于之前已经找出根节点位于中序遍历中的下标位置是 i，所以 i+1就是中序遍历中右子树的左边界，右边界一直到inorder末尾
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后可得：root.Right &amp;#x3D; buildTree(preorder[i+1:], inorder[i+1:])&lt;/p&gt;
&lt;p&gt;迭代法：&lt;br&gt;preorder第一个元素为root，在inorder里面找到root，在它之前的为左子树（长l1），之后为右子树（长l2）。preorder[1]到preorder[l1]为左子树,之后为右子树，分别递归。&lt;/p&gt;
&lt;p&gt;主要难点在于需要分别确定前序遍历和中序遍历中的左右子树的左右边界对应关系。。。&lt;br&gt;在这里插入图片描述&lt;br&gt;114. 二叉树展开为链表 ★★★ \color{red}{★★★} ★★★&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法1：先前序遍历 获得各节点被访问到的顺序，然后更新每个节点的左右子节点的信息，将二叉树展开为单链表。
方法2：没理解这个递归逻辑，继续研究在这里插入图片描述
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;124&#34;&gt;
&lt;li&gt;二叉树中的最大路径和（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;翻转二叉树&lt;/li&gt;
&lt;li&gt;二叉树的最近公共祖先 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求最小公共祖先，需要从底向上遍历。那么二叉树 只能通过后序遍历（即：回溯）实现从底向上的遍历方式。附上一个LeetCode评论区大佬图解，方便理解：&lt;br&gt;在这里插入图片描述&lt;br&gt;297. 二叉树的序列化与反序列化（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;br&gt;538. 把二叉搜索树转换为累加树 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;以 反中序遍历（右中左）的方式不断累加并更新每个节点值即可&lt;br&gt;543. 二叉树的直径 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;【前序遍历】思想：任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。&lt;br&gt;617. 合并二叉树&lt;/p&gt;
&lt;p&gt;可用两种方式操作树：原地修改 or 新建树，可参考：我的题解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;新版 hot100 题目扩充（以下题目列表不断更新ing~）：
LeetCode 108. 将有序数组转换为二叉搜索树

    二叉搜索树BST 的【中序遍历】是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树
    虽然我们可以以升序序列中的任一个元素作为根节点
    但是因为本题要求【高度平衡】，因此我们需要选择升序序列的【中间元素】作为根节点奥～
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、DFS&amp;#x2F;BFS（共6题，含3道 h a r d \color{red}{hard} hard 题）&lt;/p&gt;
&lt;p&gt;部分二叉树相关题目也包含DFS&amp;#x2F;BFS&lt;br&gt;79. 单词搜索 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;遍历二维数组，将每个坐标点分别作为起点进行dfs上下左右遍历。在遍历过程中走过的格子标记为空格 ‘ ‘，但要记得，在最后回溯时将之前被标记过的格子恢复为原字符，避免当前递归结果影响到其他的递归过程。&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; i, j：当前遍历的起点坐标&lt;br&gt;&amp;#x2F;&amp;#x2F; k: 当前目标字符在 word 中的索引 k，初始为0&lt;br&gt;&amp;#x2F;&amp;#x2F; m，n：二维数组的长和宽&lt;br&gt;m, n :&amp;#x3D; len(board), len(board[0])&lt;br&gt;var dfs func(i, j, k int) bool&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该题与 剑指 Offer 12. 矩阵中的路径 相同&lt;br&gt;85. 最大矩形 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;br&gt;200. 岛屿数量&lt;/p&gt;
&lt;p&gt;遍历二维数组，以 grid[i][j] &amp;#x3D;&amp;#x3D; 1的格子为起点，开始向其 上下左右 dfs遍历，并在遍历过程中将遍历过为1的格子标记为 ‘0’，避免重复遍历。&lt;/p&gt;
&lt;p&gt;注意 79题和200题很相似，都需遍历二维数组的网格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;但是上面第79题中，每个网格中的字符是可以复用的，用于组成新的单词。所以需要将被标记过的网格进行回溯处理，恢复为标记前的值，避免当前递归结果影响到其他递归过程。
而该题则略有不同，这里每个网格在遍历完后，标记为 ‘0’（水），由于仅统计连接的陆地数，后续不会再复用，因此无需进行回溯的恢复处理。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;207&#34;&gt;
&lt;li&gt;课程表 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;删除无效的括号 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;路径总和 III ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;dfs递归，将每个节点都当做起始的根节点对待&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;该题可以通过在子函数中增加额外入参 【sum累加和】来做加法，通过比较【当前累加和】是否和【目标和】相等： if sum + node.Val == targetSum
也可以通过对已有入参 targetSum做减法，来比较【当前节点值】是否和【不断消减的目标和】相等： if node.Val == target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：处理中间层逻辑时，即使找到了一条目标路径，也不立即 return，继续找。因为 Node.val 有可能为负数，后续有可能再减为目标和 targetSum。&lt;/p&gt;
&lt;p&gt;var res int&lt;/p&gt;
&lt;p&gt;func pathSum(root *TreeNode, targetSum int) int {&lt;br&gt;    res &amp;#x3D; 0 &amp;#x2F;&amp;#x2F; 务必初始化。多个测试用例时，避免当前结果被后续测试用例的结果覆盖&lt;br&gt;    if root &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return 0&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return dfs(root, targetSum, 0) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func dfs(node *TreeNode, targetSum, sum int) int {&lt;br&gt;    if node &amp;#x3D;&amp;#x3D; nil {&lt;br&gt;        return 0&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum += node.Val
if sum == targetSum &amp;#123;
    res++
&amp;#125;

dfs(node.Left, targetSum, sum)
dfs(node.Right, targetSum, sum)

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;br&gt;&amp;#x2F;&amp;#x2F; 更多不同种的递归形式，可跳转 CSDN-我的题解 部分（最开始介绍部分有链接）&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四、递归&amp;#x2F;回溯（共6题，含1道 h a r d \color{red}{hard} hard 题）&lt;br&gt;17. 电话号码的字母组合&lt;/p&gt;
&lt;p&gt;使用map保存按键数字和对应字母的映射关系，然后利用递归去追加各种字母…&lt;br&gt;22. 括号生成 ★ \color{red}{★} ★&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方式1 递归，尝试对括号数做减法。left：【剩余】左括号数；right：【剩余】右括号数
方式2 递归，尝试对括号数做加法。left：【已使用】左括号数；right：【已使用】右括号数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可参考：我的题解&lt;br&gt;39. 组合总和 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 从下标i&amp;#x3D;0开始不断尝试添加新元素，通过dfs回溯搜索最终找到满足要求的方案。&lt;br&gt;func combinationSum(candidates []int, target int) [][]int {&lt;br&gt;    res :&amp;#x3D; make([][]int, 0) &amp;#x2F;&amp;#x2F; 一定要加这一行，初始化res，否则不同用例在跑的时候 res会被覆盖导致 res值为上次的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dfs func(arr []int, sum, index int)
dfs = func(arr []int, sum, index int) &amp;#123;
    if sum &amp;gt; target &amp;#123;
        return
    &amp;#125;
    
    if sum == target &amp;#123;
        tmpArr := make([]int, len(arr))
        copy(tmpArr, arr)
        res = append(res, tmpArr)
        return
    &amp;#125;

    // 当sum &amp;lt; target时：
    // 避免每次遍历candidates时从i=0开始，导致结果重复
    // 比如2,2,3和2,3,2：后者2,3,2在选取3之后又再次选择了之前的2，导致结果重复
    for i := index; i &amp;lt; len(candidates); i++ &amp;#123;
        // arr = append(arr, candidates[i])// 追加
        // dfs(arr, sum + candidates[i], i)
        // arr = arr[:len(arr)-1]          // 回溯

        dfs(append(arr, candidates[i]), sum + candidates[i], i)
    &amp;#125;
&amp;#125;

dfs([]int&amp;#123;&amp;#125;, 0, 0)
return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;46&#34;&gt;
&lt;li&gt;全排列 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;将每个元素分别都固定一次到首位置上
以 k+1（即视频中的p）为起点，len(nums-1)（即视频中的q）为终点的新子数组，再次进行下一层新子数组的递归
在这里插入图片描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 1、固定首位置k（0 &amp;lt;&amp;#x3D; k &amp;lt; len(nums)），首位置会在每层递归中不断后移（每次自增1）&lt;br&gt;&amp;#x2F;&amp;#x2F; 2、固定首位置k后，每次将首位置k之后的子数组进行重排列&lt;br&gt;&amp;#x2F;&amp;#x2F; 即遍历首位置k之后的子数组nums[k+1:]，将其中的每个元素与首位置下标为k的元素进行swap&lt;br&gt;&amp;#x2F;&amp;#x2F; 3、然后进入下一层递归，继续固定首位置k+1（dfs(k+1)）&lt;br&gt;&amp;#x2F;&amp;#x2F; 4、固定首位置k+1后，每次将首位置之后的子数组进行重排列&lt;br&gt;&amp;#x2F;&amp;#x2F; 以此类推 重复上述过程，从而得到不同的全排列…&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 例如：&lt;br&gt;&amp;#x2F;&amp;#x2F; 先固定 k&amp;#x3D;0 的下标值，然后试着重排列k之后的子数组 nums[k+1:]，即nums[1:]&lt;br&gt;&amp;#x2F;&amp;#x2F; 紧接着，基于上层的递归结果，开启下一层dfs递归：dfs(k+1)&lt;br&gt;&amp;#x2F;&amp;#x2F; 再固定 k&amp;#x3D;1 的下标值，然后试着重排列k之后的子数组  nums[k+1:]，即nums[2:]&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 参考b站视频：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWR4NDExUzdXUj9zcG1faWRfZnJvbT0zMzMuMzM3LnNlYXJjaC1jYXJkLmFsbC5jbGljayZ2ZF9zb3VyY2U9MmMyNjhlMjVmZmExMDIyYjcwM2FlMDM0OWUzNjU5ZTQ=&#34;&gt;https://www.bilibili.com/video/BV1dx411S7WR?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=2c268e25ffa1022b703ae0349e3659e4&lt;/span&gt;&lt;br&gt;func permute(nums []int) [][]int {&lt;br&gt;    res :&amp;#x3D; make([][]int, 0)&lt;br&gt;    n :&amp;#x3D; len(nums)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dfs func(k int)
dfs = func(k int) &amp;#123;
    if k == n &amp;#123;
        tmpNums := make([]int, n)   // 注意：使用copy()方法时，要提前分配好数组长度len，否则copy结果为空
        copy(tmpNums, nums)
        res = append(res, tmpNums)
        return
    &amp;#125;

    for i := k; i &amp;lt; n; i++ &amp;#123;
        nums[k], nums[i] = nums[i], nums[k] // 将每个元素分别都固定一次到首位置上
        dfs(k+1)  // 以k+1为起点，n为终点的新子数组，再次进行下一层新子数组的递归
        nums[k], nums[i] = nums[i], nums[k] // 还原回溯，避免上一层递归结果影响到下一层递归
    &amp;#125;
&amp;#125;

dfs(0)
return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37

46. 全排列 和 78. 子集 的区别在于：

    [46. 全排列] 这道题在dfs时，不需要创建 subRes = []int&amp;#123;&amp;#125;，以及尝试在空数组的基础上对其不断追加nums[i]。因为在这道题的最终结果集数组 res = [][]int&amp;#123;&amp;#125;中，其中每个一维数组的长度大小都是固定的，为n = len(nums)，我们只需不断交换一维数组中每个数字的相对顺序即可，而不需要通过一个个数字追加来生成。但是交换完一维数组中每个数字的相对顺序后，记得回溯来还原nums，避免影响其他递归分支的结果。
    而 [78. 子集] 这道题在dfs时，则需要创建 subRes = []int&amp;#123;&amp;#125;，并尝试在空数组的基础上对其不断追加nums[i]。因为需要从空数组的基础上，尝试追加各种nums数组中的元素，来生成不同长度的subRes子集。但也要注意，在这里题目要求：解集不能 包含重复的子集，比如 [1,2] 和 [2, 1] 就属于重复子集，只是相对顺序不同罢了，不满足题意。
    另外 两道题的dfs递归终止条件中，追加结果集时的逻辑也不同：
        如果说返回结果集为所给nums的不同全排列，则为 len(nums)；
        如果说返回结果集为所给nums的不同子集，则为 len(subRes)。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;78&#34;&gt;
&lt;li&gt;子集 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;单看每个元素，都有两种选择：【选入子集】，或【不选入子集】。&lt;br&gt;考察当前枚举的数，基于选它而继续，是一个递归分支；基于不选它而继续，又是一个分支。&lt;br&gt;比如[1,2,3]，先看1，选1或不选1；再看2，选2或不选2，以此类推…&lt;br&gt;在这里插入图片描述&lt;/p&gt;
&lt;p&gt;func subsets(nums []int) [][]int {&lt;br&gt;    res :&amp;#x3D; make([][]int, 0)&lt;br&gt;    var dfs func(i int, subRes []int)&lt;br&gt;    dfs &amp;#x3D; func(i int, subRes []int) {&lt;br&gt;        &amp;#x2F;&amp;#x2F; 如果说返回结果集为所给nums的不同全排列，则为len(nums)&lt;br&gt;        &amp;#x2F;&amp;#x2F; 如果说返回结果集为所给nums的不同子集，则为len(subRes)&lt;br&gt;        if i &amp;#x3D;&amp;#x3D; len(nums) { &amp;#x2F;&amp;#x2F; 当遍历完nums长度后，return&lt;br&gt;            tmpRes :&amp;#x3D; make([]int, len(subRes))&lt;br&gt;            copy(tmpRes, subRes)&lt;br&gt;            res &amp;#x3D; append(res, tmpRes)&lt;br&gt;            return&lt;br&gt;        }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // 两种情况：状态树: 追加当前第i个元素或者不追加
    // // 方式1：先不追加，然后追加：
    dfs(i + 1, subRes)  // 追加：
    subRes = append(subRes, nums[i])
    dfs(i + 1, subRes)

    // 方式2：先追加，然后回溯取消追加
    // list = append(list, nums[i])
    // dfs(i + 1, list)
    // list = list[:len(list) - 1]
    // dfs(i + 1, list)
&amp;#125;
dfs(0, []int&amp;#123;&amp;#125;) // 从第0个元素开始，触发递归；且赋值空数组

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;399&#34;&gt;
&lt;li&gt;除法求值 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;br&gt;五、Hash表&amp;#x2F;map（共3题）&lt;/li&gt;
&lt;li&gt;两数之和&lt;/li&gt;
&lt;li&gt;字母异位词分组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建一个map，key为string类型，val为string类型数组。&lt;/p&gt;
&lt;p&gt;对给定字符串数组strs中的每个字符串排序，将其排序结果统一作为map的key。并将原本未排序的字符串追加到map的val数组中。目的是通过排序后的key来将字符串数组strs中的字符串str做归类。&lt;br&gt;128. 最长连续序列&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，将 nums 数组初始化到map中，以便于在O(1)时间内查找元素
其次，遍历 map（map是存有nums数组元素去重后的结果集。这里不能遍历nums，因为当nums中有大量重复元素时，遍历nums会导致超时），判断当前 num 是否能够作为某个连续序列的首元素（也就是 num-1 不存在）
    如果当前 num 能作为某个连续序列的首元素：
    那就继续找以当前 num 为首的后续连续序列，并累加当前连续序列的长度 length，并更新最长连续序列的长度 maxLength。
    如果当前 num 不能作为某个连续序列的首元素：
    直接跳过，继续找 …
返回最长连续序列的长度 maxLength
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;六、位运算（共3题）&lt;br&gt;136. 只出现一次的数字&lt;/p&gt;
&lt;p&gt;对数组所有元素进行异或^的值就是最终结果。&lt;br&gt;注：两个值不同，则异或结果为1；两个值相同，异或结果为0。&lt;br&gt;338. 比特位计数&lt;br&gt;461. 汉明距离&lt;/p&gt;
&lt;p&gt;在x与y 异或 后的二进制结果中，不断右移并判断对应二进制位为1的个数。&lt;br&gt;七、数组（共5题）&lt;br&gt;15. 三数之和 待研究&lt;br&gt;31. 下一个排列 ★★★ \color{red}{★★★} ★★★&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LeetCode题解，评论区一个大佬的解释很通俗易懂，我摘抄了过来。先看下举例，再结合代码可能更容易理解解题思路
 
一直觉得排列的题目很有趣，终于想通了根据当前排列计算出下一个排列的方法，在这里记录一下。 例如 2, 6, 3, 5, 4, 1 这个排列， 我们想要找到下一个刚好比他大的排列，于是可以从后往前看 我们先看后两位 4, 1 能否组成更大的排列，答案是不可以，同理 5, 4, 1也不可以 直到3, 5, 4, 1这个排列，因为 3 &amp;lt; 5， 我们可以通过重新排列这一段数字，来得到下一个排列 因为我们需要使得新的排列尽量小，所以我们从后往前找第一个比3更大的数字，发现是4 然后，我们调换3和4的位置，得到4, 5, 3, 1这个数列 因为我们需要使得新生成的数列尽量小，于是我们可以对5, 3, 1进行排序，可以发现在这个算法中，我们得到的末尾数字一定是倒序排列的，于是我们只需要把它反转即可 最终，我们得到了4, 1, 3, 5这个数列 完整的数列则是2, 6, 4, 1, 3, 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，这里应该针对 nums数组可能出现的情况分开讨论：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一种 从左至右不包含递增序列的数组（也就是纯递减数组），例如：
[3, 2, 1]的下一个排列是 [1, 2, 3]，因为 [3, 2, 1] 不存在一个字典序更大的排列。
第二种 从左至右包含递增序列的数组，细分的话有三种情况，但我们只关心 下一个更大的排列，这里逻辑上实则可以合并无需细分处理，分别举几个示例：
    从左至右一直递增的数组，[1,2,3]的下一个排列是 [1,3,2]
    先递增后递减的数组，[2,3,1]的下一个排列是 [3,1,2]
    先递减后递增的数组，[3,1,2]的下一个排列是 [3,2,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里需要对以上两种可能出现的数组分情况处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一步：从后向前 循环遍历数组，找到第一个满足条件 nums[i] &amp;lt; nums[j]的下标 i，j。
注：当然对于第一种从左至右不包含递增序列的数组（也就是纯递减数组），是找不到题目要求的 下一个更大的排列 的。因为类似 [3,2,1] 这种本身就是字典序最大的排列，是不存在一个字典序更大的排列的。
因此这里只能在第二种 从左至右包含递增序列的数组 中找到满足条件的下标 i，j了。
    继续，若在上述第二种情况中找到了满足条件 nums[i] &amp;lt; nums[j]的下标 i，j（也表明 此时 nums[i]的值是要小于其右边的任意一个数的），那么再次从数组尾元素开始，从后向前找到比当前 nums[i]大的倒数第一个数 nums[k]。交换 nums[i]和 nums[k]的值。
第二步：经过上面 第一步 【找到第一个满足条件 nums[i] &amp;lt; nums[j]的下标 i，j】后，此时的 nums[j:len(nums)]这后一段子数组其实是降序的。
因为在第一步中，跳出第一个for循环之前，一直都是满足条件 nums[i] &amp;gt; nums[j]的，也就是前一个数大于后一个数，为降序。
第三步：将上面降序的 后一段子数组 进行反转使其升序，即可得到 下一个排列 ~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体Golang版代码示例如下：&lt;/p&gt;
&lt;p&gt;func nextPermutation(nums []int) {&lt;br&gt;    if len(nums) &amp;lt;&amp;#x3D; 1 {&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i, j, k := len(nums)-2, len(nums)-1, len(nums)-1

// 第一步：从后向前 循环遍历数组，试图找到第一个满足条件 nums[i] &amp;lt; nums[j]的下标 i，j
// 如果是[3 2 1]这种纯递减数组，i会一直减到-1，就进不去下面的if判断逻辑
// 注意：在跳出该for循环前 nums[i] &amp;gt;= nums[j]，就已经能保证nums[j:len(nums)]后半段子数组为【降序】
for i &amp;gt;= 0 &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j] &amp;#123;
    i--
    j--
&amp;#125;

// i &amp;gt;= 0 保证不是纯降序排列，避免越界
// 再次从数组尾元素开始，从后向前找到比当前 nums[i]大的倒数第一个数 nums[k]，并交换值
if i &amp;gt;= 0 &amp;#123;
    for nums[k] &amp;lt;= nums[i] &amp;amp;&amp;amp; k &amp;gt; j &amp;#123;
        k--
    &amp;#125;

    nums[i], nums[k] = nums[k], nums[i]
&amp;#125;

// 将 “后半段【降序】的子数组” 反转使其升序，即可得到 下一个排列 ~
for a, b := j, len(nums)-1; a &amp;lt; b; a, b = a+1, b-1 &amp;#123;
    nums[a], nums[b] = nums[b], nums[a]
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;169&#34;&gt;
&lt;li&gt;多数元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常规的 hash表（空间复杂度为O(n)）和 排序算法（时间复杂度为O(nlogn)），都不满足题目的进阶要求：时间复杂度为 O(n)、空间复杂度为 O(1) ，这里不做展开，具体可以参考LeetCode官方题解。&lt;/p&gt;
&lt;p&gt;这里学到一种新的算法 摩尔投票法，具体思路如下图，也可以看 我的题解&lt;br&gt;在这里插入图片描述&lt;br&gt;238. 除自身以外数组的乘积 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;思路：除自身以外数组的乘积 &amp;#x3D; 自身的左侧数组 * 自身的右侧数组&lt;/p&gt;
&lt;p&gt;题目进阶要求：在 O(1) 的额外空间复杂度内完成这个题目，因此复用待返回的res数组即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;初始化 左侧/右侧 数组：res[0] = 1
处理左侧数组乘积：i从 [ 1, len(nums) ) 递增，res[i] = res[i-1] * nums[i-1]
处理右侧数组乘积：i从 [ len(nums)-2, 0 ] 递减，用一个变量 right 来跟踪右边元素的乘积，并初始化为1。然后内部循环中不断更新 right 和 res 的值：right *= nums[i+1]，res[i] *= right
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此外，注意边界条件的处理即可。&lt;br&gt;448. 找到所有数组中消失的数字 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;题目进阶要求：在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题。&lt;/p&gt;
&lt;p&gt;因此这里不考虑使用 hash表 来统计次数的方法，而是使用数组元素标记法，具体如下：&lt;br&gt;本质上是把原数组上对应index的值取负来标识某个值出现过，最后再次遍历标识过的数组找出其中非负的元素，其对应 【下标+1】 即为消失的数字。&lt;br&gt;八、二分查找（共5题，含1道 h a r d \color{red}{hard} hard 题）&lt;/p&gt;
&lt;p&gt;使用场景：题目要找的是一个 整数 target，并且这个整数有明确的范围，该情况下可使用「二分查找」。&lt;br&gt;4. 寻找两个正序数组的中位数 （ h a r d 题 \color{red}{hard题} hard题）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法1 先将两个数组有序合并至新数组中，然后根据奇偶情况返回中位数。较简单，但时间复杂度不满足题目要求的 O(log (m+n))。
时间复杂度 O(m+n)，空间复杂度 O(m+n)
方法2 先找到中位数可能的下标值 left 和 right，然后遍历数组得到nums[left], nums[right]，再根据奇偶情况返回中位数。较复杂，对于奇偶情况的判断逻辑容易出错，且时间复杂度不满足题目要求的 O(log (m+n))。
时间复杂度 O(m+n)，空间复杂度：O(1)
方法3 二分法 待研究 \color&amp;#123;red&amp;#125;&amp;#123;待研究&amp;#125; 待研究
时间复杂度 O(log (m+n))，空间复杂度：O(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;33&#34;&gt;
&lt;li&gt;搜索旋转排序数组 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此题运用二分法的特殊变种情况来区分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if nums[mid] == target
if nums[left] &amp;lt;= nums[mid]，mid的左侧是单调递增区间。注意，当nums中元素较少时，可能left和mid的下标值相同，因此这里的 nums[left] 也可能等于 nums[mid]。
    if nums[left] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt; nums[mid]
        right = mid - 1
    else
        left = mid + 1
else /*if nums[left] &amp;gt; nums[mid]*/，mid的左侧不是单调递增区间，说明右侧是单调递增区间
    if nums[mid] &amp;lt; target &amp;amp;&amp;amp; target &amp;lt;= nums[right]
        left = mid + 1
    else
        right = mid - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;34&#34;&gt;
&lt;li&gt;在排序数组中查找元素的第一个和最后一个位置 ★★ \color{red}{★★} ★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在nums中找到了一个target，则继续在此基础上有两种处理方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法1：通过左右滑动指针，来找到符合题意的区间
方法2：二分法 + 左右滑动指针
方法3（推荐）：继续用二分法分别查找左右边界，而不是用左右滑动指针来逐个遍历
    注意：
        通过新增变量leftOrRight，leftOrRight为true找左边界，leftOrRight为false找右边界
        searchRange要分别调用两次 binarySearch() 方法，获取第一个和最后一个位置return []int&amp;#123;binarySearch(nums, target, true), binarySearch(nums, target, false)&amp;#125;
        binarySearch方法是保存上一轮循环中target == nums[mid]时，对应的mid值，其初始值设为 -1，而不能为0，因为可能会与下标0冲突
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法1 双指针：不推荐&lt;br&gt;&amp;#x2F;&amp;#x2F; 时间复杂度：O(n)&lt;br&gt;func searchRange(nums []int, target int) []int {&lt;br&gt;    &amp;#x2F;&amp;#x2F; if len(nums) &amp;#x3D;&amp;#x3D; 0 {&lt;br&gt;    &amp;#x2F;&amp;#x2F;     return []int{-1, -1}&lt;br&gt;    &amp;#x2F;&amp;#x2F; }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;left, right := 0, 0

// 注意：要避免left和right越界
for ; left &amp;lt; len(nums) &amp;amp;&amp;amp; nums[left] != target; left++ &amp;#123;
&amp;#125;

// 如果在nums中没找到target，则直接返回-1
if left &amp;gt;= len(nums) &amp;#123;
    return []int&amp;#123;-1, -1&amp;#125;
&amp;#125;

// 注意：要避免left和right越界
for right = left; right &amp;lt; len(nums) &amp;amp;&amp;amp; nums[right] == target; right++ &amp;#123;
&amp;#125;

right-- // 因为最后right多加了一次，所以减回去

return []int&amp;#123;left, right&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法2 二分法 + 左右滑动指针：不推荐&lt;br&gt;&amp;#x2F;&amp;#x2F; 思路：如果在nums中找到了一个target，则继续在此基础上，通过左右滑动指针，来找到符合题意的区间&lt;br&gt;&amp;#x2F;&amp;#x2F; 平均时间复杂度：O(logn)，最坏情况下如果数组中的所有元素都一样，那最坏时间复杂度为O(n)&lt;br&gt;func searchRange(nums []int, target int) []int {&lt;br&gt;   left, right :&amp;#x3D; 0, len(nums) - 1&lt;br&gt;   for left &amp;lt;&amp;#x3D; right {&lt;br&gt;       mid :&amp;#x3D; left + (right - left) &amp;#x2F; 2&lt;br&gt;       if nums[mid] &amp;#x3D;&amp;#x3D; target {&lt;br&gt;            &amp;#x2F;&amp;#x2F; 找到target位置后，分别 向左&amp;#x2F;向右 寻找左右边界&lt;br&gt;            pre, end :&amp;#x3D; mid, mid&lt;br&gt;            for pre &amp;gt;&amp;#x3D; 0 &amp;amp;&amp;amp; nums[pre] &amp;#x3D;&amp;#x3D; target {&lt;br&gt;                pre–&lt;br&gt;            }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        for end &amp;lt; len(nums) &amp;amp;&amp;amp; nums[end] == target &amp;#123;
            end++
        &amp;#125;

        return []int&amp;#123;pre + 1, end - 1&amp;#125; // l在循环中多减了一次，要加回来；r在循环中多加了一次，要减回去
   &amp;#125; else if nums[mid] &amp;lt; target &amp;#123;
       left = mid + 1
   &amp;#125; else &amp;#123;
       right = mid - 1
   &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   return []int{-1, -1}&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法3 二分法：推荐&lt;br&gt;&amp;#x2F;&amp;#x2F; 思路：如果在nums中找到了一个target，则继续在此基础上用二分法分别查找左右边界，而不是用左右滑动指针来逐个遍历&lt;br&gt;func searchRange(nums []int, target int) []int {&lt;br&gt;    return []int{ binarySearch(nums, target, true), binarySearch(nums, target, false) }&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; leftOrRight为true找左边界，leftOrRight为false找右边界&lt;br&gt;func binarySearch(nums []int, target int, leftOrRight bool) int {&lt;br&gt;    left, right, res :&amp;#x3D; 0, len(nums) - 1, -1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for left &amp;lt;= right &amp;#123;
    mid := left + (right - left) / 2
    if target == nums[mid] &amp;#123;
        res = mid // 保存上一轮循环中target == nums[mid]时，对应的mid值
        // leftOrRight = true，继续寻找target的左边界，所以要缩小当前的右边界，right需要往左移
        if leftOrRight &amp;#123;
            right = mid - 1

        // leftOrRight = false，继续寻找target的右边界，所以要增大当前的左边界，left需要往右移
        &amp;#125; else &amp;#123;
            left = mid + 1
        &amp;#125;
    &amp;#125; else if target &amp;gt; nums[mid] &amp;#123;
        left = mid + 1
    &amp;#125; else &amp;#123; // target &amp;lt; nums[mid]
        right = mid - 1
    &amp;#125;
&amp;#125;

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;240&#34;&gt;
&lt;li&gt;搜索二维矩阵 II&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;题目给出 m x n 矩阵从左到右升序排列，从上到下升序排列。&lt;/p&gt;
&lt;p&gt;因此以矩阵右上角的元素 nums[i][j)]为起点，若target小于当前值，则j–，若target大于当前值则i++。&lt;br&gt;时间复杂度O(m+n)：i 最多能被增加 m 次，j 最多能被减少 n 次，总搜索次数为 m+n&lt;/p&gt;
&lt;p&gt;另外此题的更优解是 二分法查找 …&lt;br&gt;287. 寻找重复数 ★★ \color{red}{★★} ★★&lt;/p&gt;
&lt;p&gt;在这里插入图片描述&lt;br&gt;此题的进阶要求在新版本LeetCode中有做更新，之前是要求O(1)空间复杂度，因此不能使用hash表计数。因此采用 二分法。&lt;/p&gt;
&lt;p&gt;二分法查找：&lt;br&gt;每一次找中间值，考虑到1-n之间的数一定都会出现，如果非重复情况下每个数只会出现一次，故我们判断小于等于中间值元素个数如果超过了中间值则说明重复的数在左半边，否则去右半边找。（注意：这里的左半边和右半边，是指非重复情况下的有序数组的左右两侧）&lt;/p&gt;
&lt;p&gt;具体可参考：我的题解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;新版 hot100 题目扩充（以下题目列表不断更新ing~）：
LeetCode 35. 搜索插入位置

    与普通的二分查找类似，只不过对于target不存在的情况，需要返回left
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;九、双指针&amp;#x2F;三指针（共3题）&lt;/p&gt;
&lt;p&gt;双指针问题和上述的【八、二分查找】问题类似，都是通过各种方式去操作左右两侧的数组下标 left 和 right …&lt;br&gt;11. 盛最多水的容器&lt;/p&gt;
&lt;p&gt;设置双指针 i， j 分别位于容器壁两端。那么为了获取到更大的面积，i 和 j 中较短的一边向中间靠拢（才有可能获取到更大的面积），直至 i 和 j 相遇。&lt;br&gt;75. 颜色分类 ★★ \color{red}{★★} ★★&lt;/p&gt;
&lt;p&gt;思路：三指针法，left左侧永远都是0，right右侧永远都是2，左右侧都确定好了，那么中间的就自然全是1了（此问题是 荷兰国旗 问题：0 - 红，1 - 白，2 - 蓝 排序）。&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义三指针 left, right, i := 0, len(nums) - 1, 0，遍历数组 for i &amp;lt;= right。
注意循环条件：原本是 i &amp;lt;= len(nums)，但 right 指针右侧已经都是2了，没必要继续寻找。因此以越过右指针为终止条件，减少查找次数。

判断 nums[i]的值：
    若是 0，则移动到表头：swap(nums[i], nums[left])，left++，i++
    注意：nums[left]已经在 i 向右遍历的过程中早就验证过了，所以i要加加右移
    若是 1，则继续：i++
    若是 2，则移动到表尾：swap(nums[i], nums[right])，right--。
    注意：这里不用 i++，因为 nums[right])交换到 nums[i]上的数还没有验证（有可能是0或2），所以 i 不用右移。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;283&#34;&gt;
&lt;li&gt;移动零 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义 双指针 left, right :&amp;#x3D; 0, 0。left左侧的数都是非零值，而right则不断的右移以跟踪0值。&lt;br&gt;如果nums[right] !&amp;#x3D; 0，则left和right对应值交换，且left和right都右移；反之则仅仅right右移。&lt;br&gt;十、栈&amp;#x2F;单调栈（共6题，含2道 h a r d \color{red}{hard} hard 题）&lt;br&gt;20. 有效的括号&lt;/p&gt;
&lt;p&gt;创建辅助栈，利用 栈 先进后出的特性来对每组括号进行匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;左括号：入栈
右括号：与栈顶元素比较，判断是否匹配
最后判断栈是否为空，非空不匹配则false，反之true
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;42&#34;&gt;
&lt;li&gt;接雨水 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;柱状图中最大的矩形 （ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;最小栈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;空间换时间的思想，分别构建 数据栈 stack 和 最小栈 minStack（辅助栈），使得能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;主要注意push操作即可。&lt;br&gt;394. 字符串解码 ★★ \color{red}{★★} ★★&lt;/p&gt;
&lt;p&gt;外层的解码需要等待内层解码的结果。先扫描的字符还用不上，但不能忘了它们。&lt;br&gt;我们准备由内到外，层层解决[ ]，需要保持对字符的记忆，于是用栈。&lt;/p&gt;
&lt;p&gt;需要两个栈来记录外层字符串的状态：倍数栈 numStack、字符串栈 strStack&lt;br&gt;创建几个变量：result不断追加每一层新得到的子串，str保存每一层的子串，num保存每一层的倍数&lt;/p&gt;
&lt;p&gt;遍历字符串s，每次得到的字符c存在以下几种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c &amp;gt;= ‘0’ &amp;amp;&amp;amp; c &amp;lt;= ‘9’：处理当前层倍数
获取每一层子串要重复的倍数：例如 12[ab]，那么就需要获取到12(1*10+2)这个完整的数字
c == ‘[’：分别保存外层 倍数 及 子串 到栈中，准备进入下一层
将上一层的 result和 num分别入栈保存，并清空对应记录，避免干扰下一层 result和 num的统计
c == ‘]’：内外层拼接
处理完当前层，获取栈顶数据，并将外层及当前层字符串相拼接
c &amp;gt;= ‘a’ &amp;amp;&amp;amp; c &amp;lt;= ‘z’：处理当前层子串
不断追加每层的 result结果：例如ab[…]，那么就要拼接获取到这一层ab这个完整的字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;739&#34;&gt;
&lt;li&gt;每日温度 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：参考LeetCode视频题解 - 单调栈&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单调递减栈：注意题目要求的是升温的天数，而不是升温后的温度，因此栈中应存储下标，而非温度
    若当前遍历到的温度 &amp;lt; 栈顶温度，则将当前温度对应的天数下标入栈
    若当前遍历到的温度 &amp;gt; 栈顶天数所对应的温度，则计算天数差值：后者减去前者
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建单调栈（递减）
外部for循环，遍历 temperatures数组
    ① 内部for循环：
    若栈非空len(stack) &amp;gt; 0，且【当前第 i天的温度 temperatures[i]&amp;gt; 栈顶第 stack[len(stack)-1]天所对应的温度 temperatures[stack[len(stack)-1]】，直接求出二者的下标差（天数差值）就可得到 下一个更高温度出现在几天后，将结果保存到结果数组res中：res[stack[len(stack)-1]] = i - stack[len(stack)-1]，并将栈顶元素出栈。
    循环处理该过程，继续看新的栈顶元素，直到不满足上述条件时而退出内部for循环。因为当前温度 temperature[i]可能大于之前早已入栈的多个温度，需逐个处理…
    ② 若由于不满足上述条件而退出内部for循环，则表示 当前栈为空 或 当前温度 temperatures[i]&amp;lt;= 栈顶第 stack[len(stack)-1]天所对应温度 temperatures[stack[len(stack)-1]]，那么直接将当天的下标 i入栈。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：①②两种情况并不是互斥关系，无需 if-else 处理，直接写逻辑即可。&lt;/p&gt;
&lt;p&gt;这样就可以一直保持单调递减栈，且每个元素和后面第一个大于它的元素的距离天数也可以算出来。&lt;br&gt;十一、排序（共4题）&lt;br&gt;56. 合并区间 ★ \color{red}{★} ★&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;先对二维数组下的所有一维数组的首元素（左边界）进行升序排序，使每个一维子数组的左边界为升序排列：
sort.Slice(intervals, func(i, j int) bool &amp;#123;
  return intervals[i][0] &amp;lt; intervals[j][0]
&amp;#125;)
避免后面合并时出现无序的 intervals数组，例如：[[1,4],[0,4]]，导致合并结果出错为：[1,4]而非[0,4]
遍历题目给定的二维数组 for i := 1; i &amp;lt; len(intervals); i++ &amp;#123;，然后合并区间（经过上面排序后，此时每个一维子数组的左边界都已是升序排列。在此前提下，我们只需再比较每个一维子数组的右边界并判断是否能合并即可）：
    可合并：若前一个区间右边界 &amp;gt;= 后一个区间左边界，则可将前一个区间 intervals[i-1]合并到当前区间 intervals[i]中。另外，还要注意比较并选择前后区间中较大的右边界作为合并后 intervals[i]的右边界。
    当前新合并后的区间将继续作为下一轮遍历中的 前一个区间 。
    无法合并：若前一个区间右边界 &amp;lt; 后一个区间左边界，则无法合并，直接追加【前一个区间】到结果集 res中
最后，要追加 intervals的最后一个元素到结果集 res中：因为在之前每次的循环中，append的是前一个区间，导致 intervals的最后一个区间一直没来得及添加到结果集数组 res中
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;215&#34;&gt;
&lt;li&gt;数组中的第K个最大元素 ★★★ \color{red}{★★★} ★★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用快排 或 堆排（小顶堆时间复杂度更优），具体参考 我的题解&lt;br&gt;347. 前 K 个高频元素 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;方法1 内置排序法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;利用map统计每个元素出现频次：key = num, val = cnt
将map中的key加入新数组 res 中，也就是对nums去重后的数组集
根据map中【出现频次cnt】对【去重后的res数组】排序，返回前k个
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; sort.Slice(res, func(i, j int) bool {&lt;br&gt;        return m[res[i]] &amp;gt; m[res[j]]&lt;br&gt;    })&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法2 小顶堆（推荐）：&lt;/p&gt;
&lt;p&gt;前面对元素出现频次的统计和上面方法1一样。&lt;br&gt;接下来是利用小顶堆，因为要统计最大前k个高频元素，只有小顶堆每次将频次最小的元素弹出，最后小顶堆里积累的才是前k个高频元素。&lt;/p&gt;
&lt;p&gt;那为什么不能用大顶堆呢？&lt;br&gt;你想啊，如果定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把当前最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。&lt;/p&gt;
&lt;p&gt;方法3 桶排序&lt;br&gt;参考 LeetCode题解-桶排序算法&lt;/p&gt;
&lt;p&gt;func topKFrequent1(nums []int, k int) (ans []int) {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 确定每个数的频率&lt;br&gt;    freq :&amp;#x3D; make(map[int]int)&lt;br&gt;    for _, v :&amp;#x3D; range nums {&lt;br&gt;        freq[v]++&lt;br&gt;    }&lt;br&gt;    &amp;#x2F;&amp;#x2F; fmt.Println(freq)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 将不同频率的元素放入不同桶
buckts := make([][]int, len(nums)+1) // 创建桶
for k, v := range freq &amp;#123;
    buckts[v] = append(buckts[v], k)
&amp;#125;
// fmt.Println(buckts, buckts[3], buckts[2], buckts[1])

// 从最大桶开始逐步取出高频元素
for i := len(buckts)-1; k &amp;gt; 0; i-- &amp;#123;
    for _, v := range buckts[i] &amp;#123;
        ans = append(ans, v)
        k--
    &amp;#125;
&amp;#125;

return
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;581&#34;&gt;
&lt;li&gt;最短无序连续子数组（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;br&gt;十二、前缀和（共1题）&lt;/li&gt;
&lt;li&gt;和为 K 的子数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：nums中可能存在负数，sum累加和可能更大也可能更小，因此，即使累加和等于k，也不能提前break退出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法1 双层循环暴力求解
    思路：内层循环中，分别以不同元素作为起点，分别计算sum
    注意：即使当前累加值与目标值相等（sum == k），也不能提前break退出循环，因为测试用例可能给出负数。
    比如：nums = [1,-1,0]，k = 0，有三种符合的子数组：[1, -1]、[0]、[1,-1,0]，注意最后一种 1 + (-1) + 0 = 0 也是满足题目要求的子数组，因此不能提前break结束循环。
    时间复杂度：O(n^2)，不推荐
    空间复杂度：O(1)
方法2 前缀和，参考：大佬题解
利用空间换时间的思想，思路整体类似于 LeetCode 1. 两数之和。
    具体步骤如下：
        遍历 nums 数组，对每个nums[i]求其前缀和（作为map的key），并累加该前缀和的出现次数（作为map的val），以键值对存入 map。注意 初始边界值：开始时前缀和为0出现过1次，所以将 0:1 存入map。
        边存边检查 map，如果 map 中存在 key 为「当前前缀和 - k」，说明这个之前出现的前缀和，满足通项式：「当前i所对应的前缀和 - 之前出现的前缀和 == k」。最后，将「当前前缀和 - k」出现的次数，累加到最后的结果中即可。
        通俗的说，已知当前 i 所对应的前缀和为 prefixSum[i]，我们想找出 prefixSum[i] 减去之前的某些连续子数组和之后的差值等于 k 的这么一些连续子数组。
        那么应满足条件：当前 i 所对应的前缀和 prefixSum[i]- 之前出现的前缀和 x= k，那么这个 x= prefixSum[i]- k。接下来我们要判断这个 x 在之前是否出现过，因此将求得的每一项前缀和，以及对应的出现次数，以键值对形式存入 map中，以便后续判断。
    时间复杂度：O(n)
    空间复杂度：O(n)，map所占空间为O(n)
    在这里插入图片描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法2 前缀和&lt;br&gt;&amp;#x2F;&amp;#x2F; 参考：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsvc29sdXRpb24vZGFpLW5pLWRhLXRvbmctcWlhbi16aHVpLWhlLWNvbmctenVpLWJlbi1mYW5nLWZhLXkv&#34;&gt;https://leetcode.cn/problems/subarray-sum-equals-k/solution/dai-ni-da-tong-qian-zhui-he-cong-zui-ben-fang-fa-y/&lt;/span&gt;&lt;br&gt;&amp;#x2F;&amp;#x2F; 思路：类似于【1、两数之和】&lt;br&gt;&amp;#x2F;&amp;#x2F; 1、遍历 nums 数组，求每一项前缀和，统计对应出现次数，以键值对存入 map&lt;br&gt;&amp;#x2F;&amp;#x2F; 2、边存边检查 map，如果 map 中存在 key 为「当前前缀和 - k」&lt;br&gt;&amp;#x2F;&amp;#x2F; 说明这个之前出现的前缀和，满足「当前前缀和 - 该前缀和 &amp;#x3D;&amp;#x3D; k」&lt;br&gt;&amp;#x2F;&amp;#x2F; 将它出现的次数，累加给 count&lt;br&gt;func subarraySum(nums []int, k int) int {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 初始值：一开始，0个元素和为0，出现次数为1&lt;br&gt;    m :&amp;#x3D; map[int]int{0:1}&lt;br&gt;    sum, res :&amp;#x3D; 0, 0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; len(nums); i++ &amp;#123;
    sum += nums[i]

    // 如果满足条件：
    // 【之前某前缀和 = 当前前缀和sum - k】
    if cnt, ok := m[sum - k]; ok &amp;#123;
        res += cnt
    &amp;#125;
    m[sum] += 1
&amp;#125;

return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十三、字典树&amp;#x2F;前缀树（共1题）&lt;br&gt;208. 实现 Trie (前缀树)) ★★★ \color{red}{★★★} ★★★&lt;/p&gt;
&lt;p&gt;前缀树：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;功能优点：用于高效地存储和检索字符串数据集中的键
应用场景：搜索引擎、自动补全、拼写检查、Golang Gin web框架的路由匹配模块。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前缀树节点的结构体类型：&lt;/p&gt;
&lt;p&gt;type Trie struct {&lt;br&gt;    child  [26]*Trie &amp;#x2F;&amp;#x2F; 26叉树，注意是指针类型&lt;br&gt;    isEnd bool       &amp;#x2F;&amp;#x2F; 标记当前节点是否是一个完整单词的末尾位置&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个方法中，都有一个对应的 this指针，通过移动这个 this指针，可以实现对 新字符串的插入 与 旧字符串的查找。&lt;/p&gt;
&lt;p&gt;先遍历给定字符串的每个字符，并计算其对应的下标：chIndex :&amp;#x3D; word[i] - ‘a’，通过判断 该字符在当前数组中是否为空 if this.child[chIndex] &amp;#x3D;&amp;#x3D; nil，来决定 insert 和 search 等后续操作。insert 时若为空，则新建 &amp;amp;Trie结构，否则直接移动指针 this &amp;#x3D; this.child[chIndex]即可。&lt;/p&gt;
&lt;p&gt;另外 注意：&lt;br&gt;Search(word string)和 StartsWith(prefix string)方法虽然类似，但是也有区别。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Search()方法是用于查找完整 word 单词的，所以最后需要额外判断下 this.isEnd是否为 true。
而 StartsWith()只要匹配到 prefix 前缀即可，不需要是完整的单词，所以不需要额外判断 this.isEnd是否为 true。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十四、LRU缓存（共1题）&lt;br&gt;146. LRU 缓存 ★★★ \color{red}{★★★} ★★★&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; LRUCache缓存结构体类型&lt;br&gt;type LRUCache struct {&lt;br&gt;    cap        int&lt;br&gt;    head, tail *Node&lt;br&gt;    m          map[int]*Node&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先解释下结构体 LRUCache 的各个字段：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建 head和 tail（这两个虚拟节点不存真实数据）原因：
仅用于标记双向链表的首尾位置，使得在【加入新节点】和【删除旧节点】可通过 head和 tail更方便操作
使用map原因：
    Get()和 Put()需要根据入参key，从map中查找和更新对应节点信息，且以 O(1) 平均时间复杂度运行
    map的另一个作用是避免加入重复的key到链表中去，可以对key去重
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外 补充一点：将一个活跃节点移动到链表头部可以拆分为两步：moveToHead()&amp;#x3D;deleteNodeFromList()+addNodeToHead()&lt;br&gt;十五、动态规划（共23题，含6道 h a r d \color{red}{hard} hard 题）&lt;br&gt;10. 正则表达式匹配（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;br&gt;32. 最长有效括号（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;br&gt;53. 最大子数组和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;动态规划 方式1：
判断 dp[i] = dp[i-1] + nums[i]中，dp[i-1]是起到 正向作用还是负向作用
也就是判断 nums[i]是否要加上之前的前缀和 dp[i-1]，有两种情况：
    当 dp[i-1] &amp;gt; 0 对最大子数组和起正向作用时，则可以加上之前的dp[i-1]；
    反之 当 dp[i-1] &amp;lt; 0 对最大子数组和起负向作用时，则不加

动态规划 方式2（方式1的优化版）：
其实上述方式并不是最优的，因为每次遍历我只需要判断之前的 dp[i-1]的正负即可，所以可以用一个变量 pre来代替和复用，并不需要额外构造dp数组。这样空间复杂度可降至O(1)。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;62&#34;&gt;
&lt;li&gt;不同路径&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dp方程递推关系：到达当前坐标点的路径数 = 到达当前坐标点上面一格的路径数 + 到达当前坐标点左边一格的路径数
dp数组相对于mxn的网格，额外多初始化了最上面一行，与最左边一列。起始点是（1,1），终点是（m,n）。这样初始化可以跟题目坐标系对应，多余的dp数组位置也能处理掉循环的边界条件，不用增加额外的判断代码。（当然不额外多初始化最上面一行和最左边一列也可以，但是需要增加额外的判断代码。详情见我的题解）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建长宽分别为 m+1，n+1 的dp数组用于记录不同的路径数。注意初始化时以下任意方式都ok：
    dp[0][1] = 1，从上到下，dp[0][1] → dp[1][1]
    或者 dp[1][0] = 1，从左到右，dp[1][0] → dp[1][1]
其中，dp[1][1]对应原有矩阵的 [0][0] 位置，也就是机器人的起始位置
从 dp[1][1]起始位置出发，机器人每次只能向下或者向右移动一步，可得到递推方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;64&#34;&gt;
&lt;li&gt;最小路径和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，这道题与上一道题 62. 不同路径 的区别在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[62. 不同路径] 题不需要针对 第0行 与 第0列 单独处理，所有不同路径数对应的所有情况可以统一使用 到达当前坐标点的路径数 = 到达当前坐标点上面一格的路径数 + 到达当前坐标点左边一格的路径数 来处理。
而这道题因为是关系到每个坐标格子中的数值累加和，所以需要针对 第0行 与 第0列 单独处理：原点时不处理，最上边一行时只能从左到右累加和，最左边一行只能从上到下累加和。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜索的做法仅仅在数据规模比较小的时候才考虑使用，因为复杂度较高，所以采用dp。由于每个元素对应的最小路径和与其相邻元素（当前点的上面或左面）对应的最小路径和有关，因此可以使用动态规划求解。&lt;/p&gt;
&lt;p&gt;普通dp空间复杂度为O(n)，而在原有grid数组上进行原地修改，空间复杂度更优，为 O(1)，具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当 i == 0 &amp;amp;&amp;amp; j == 0，即位于 原点(0,0) 时：dp[i][j] = grid[i][j]
当 i == 0时，即当前点位于 最上边一行 时：只能从原点向右移动，从&amp;quot;左&amp;quot;边过来：dp[i][j] = dp[i][j-1] + grid[i][j]
当 j == 0时，即当前点位于 最左边一列 时：只能从原点向下移动，从&amp;quot;上&amp;quot;边过来：dp[i][j] = dp[i - 1][j] + grid[i][j]
其余情况，当前点既不在最上面一行，也不在最左边一列，此时选取其上或其左位置点中的较小值：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
最终返回 dp[m-1][n-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此题也可以采用递归处理，可以参考 我的题解，不过相比dp更复杂和难以理解。&lt;br&gt;70. 爬楼梯&lt;/p&gt;
&lt;p&gt;三种方法，劣 → 优：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方法1 递归法：时间复杂度较高，不推荐
方法2 动态规划：时间复杂度O(n)，空间复杂度：O(n)
方法3 动态规划 优化版：在动态规划的基础上进行优化，空间复杂度：O(1)
由于当前结果只跟 n-1 和 n-2 项有关，故只需缓存这两个变量即可，不需要使用方法2的dp数组缓存整个遍历结果
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;72&#34;&gt;
&lt;li&gt;编辑距离（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;不同的二叉搜索树&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;动态规划，双层循环，i 为当前树的节点总数（从0到n），j 为左子树节点数（j &amp;lt; i），因此可得右子树节点数为：i - 1 - j（根节点也占一个节点）。
左子树本身可能有m种构建方式，右子树有n种构建方式，所以取 i 作为根的二叉搜索树的种类为 m*n
对于整个序列 1→n 都可能作为根节点，根有n种可能。所以整个序列构建二叉搜索树，所有种类等于分别取 1→n 为根的二叉搜索树种类和。
因此可得递推关系式为：dp[i] += dp[j]*[i-1-j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建dp数组，初始化：
dp[0] = 1（空树）, dp[1] = 1（单节点树）
双层循环
    i表示当前想要表示的节点总数，从 1 递增至 n
    j表示当前一共有 i个节点时，其左子树可能的节点数
        递推方程：dp[i] += dp[j]*[i-1-j]，前一项 dp[j]是左子树可能出现的种数，后一项 dp[i-j-1]是右子树可能出现的种数，注意 根节点也占 1 个数量。
        举例：dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0]
返回 dp[n]即可
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;121&#34;&gt;
&lt;li&gt;买卖股票的最佳时机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此题可以看做一种动态规划，只不过对空间复杂度进行了优化。&lt;/p&gt;
&lt;p&gt;考虑每次如何获取最大收益？第 i 天的最大收益只需要知道前 i 天的最低点就可以算出来了。而第 i 天以前（包括第i天）的最低点和 i - 1 天的最低点有关，至此我们的动态方程就出来了：dp[i] &amp;#x3D; min(d[i-1], prices[i])。&lt;/p&gt;
&lt;p&gt;其中 dp[0] &amp;#x3D; prices[0]，然后动态计算之后的就可以了。 得到了前 i 天的最低点以后，只需要维护一个 max 用来保存最大收益就可以了。 这个时候是空间复杂度 O(n) 的动态规划，代码如下：&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 动态规划 版本1（优化前，空间复杂度：O(n)）&lt;br&gt;func maxProfit(prices []int) int {&lt;br&gt;    n, maxProfitVal :&amp;#x3D; len(prices), 0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// dp[i]表示截止到第 i 天，股票价格的最低点是多少 
// dp[i] = min(dp[i-1], nums[i])
dp := make([]int, n)
dp[0] = prices[0]

for i := 1; i &amp;lt; n; i++ &amp;#123;
    dp[i] = min(dp[i - 1], prices[i])
    maxProfitVal = max(maxProfitVal, prices[i] - dp[i])
&amp;#125;

return maxProfitVal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着考虑优化空间，仔细观察动态规划的辅助数组，其每一次只用到了 dp[i - 1] 这一个空间，因此可以把数组改成单个变量 dp 来存储截止到第 i 天的价格最低点。优化后的代码如下：&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 动态规划 版本2（版本1基础上优化后）&lt;br&gt;&amp;#x2F;&amp;#x2F; 使用变量 minPrice 保存当前遍历过的股价最低价格，替代之前的dp数组，空间复杂度：O(1)&lt;br&gt;&amp;#x2F;&amp;#x2F; 思路：只需记录数组中已遍历过的最小值，当一个数减去最小值，则差值最大！&lt;br&gt;func maxProfit(prices []int) int {&lt;br&gt;    minPrice, maxProfitVal :&amp;#x3D; prices[0], 0 &amp;#x2F;&amp;#x2F; 股价最低价格，最大利润&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := 1; i &amp;lt; len(prices); i++ &amp;#123;
    maxProfitVal = max(maxProfitVal, prices[i] - minPrice)
    minPrice = min(minPrice, prices[i])
&amp;#125;

return maxProfitVal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;139&#34;&gt;
&lt;li&gt;单词拆分 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;借助 map 来实现在 O(1) 时间复杂度内判断当前子串是否在字典 wordDict 中。
通过 j，i下标来标记当前遍历到的子串的左右边界，得到当前的子串 subStr = s[j:i]。
判断该子串是否在字典 wordDict 中出现，并且在这之前以 j结尾的子串 dp[j]是否也为 true。同时满足这两个条件，则表明当前遍历到的子串 subStr = s[j:i]是可以正常进行单词拆分的，记为 true。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体示例代码如下：&lt;/p&gt;
&lt;p&gt;func wordBreak(s string, wordDict []string) bool {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 初始化单词map，用于判断当前遍历到的子串是否在wordDict中出现过&lt;br&gt;    wordMap :&amp;#x3D; make(map[string]bool)&lt;br&gt;    for _, word :&amp;#x3D; range wordDict {&lt;br&gt;        wordMap[word] &amp;#x3D; true&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n := len(s)
dp := make([]bool, n + 1)
dp[0] = true // 边界条件，dp[0]=true 表示空串且合法

// i表示子串的结束位置的后一个位置
// 因为s[j:i]是左闭右开，不包含右边界的，所以i &amp;lt;= n，j &amp;lt;= i
for i := 1; i &amp;lt;= n; i++ &amp;#123;
    // j表示子串的开始位置
    for j := 0; j &amp;lt;= i/*j &amp;lt; i*/; j++ &amp;#123;
        subStr := s[j:i]
        if wordMap[subStr] &amp;amp;&amp;amp; dp[j] &amp;#123;
            dp[i] = true
            // break
        &amp;#125;
    &amp;#125;
&amp;#125;

return dp[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;152&#34;&gt;
&lt;li&gt;乘积最大子数组（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;打家劫舍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：递推方程为：dp[i] &amp;#x3D; max(偷上上个房屋 + 偷当前房屋, 偷上个房屋 + 不偷当前房屋)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;动态规划 方法1：优化前 空间复杂度 O(n)
    初始化：dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    递推方程：i从2开始，dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
    返回值：dp[len(nums) - 1]
动态规划 方法2：优化后 空间复杂度 O(1)
上述方法用数组存储结果，考虑到每间房屋的最高总金额只和【该房屋的前两间房屋】的最高总金额相关。因此，在每个时刻只用通过变量保存前两间房屋的最高总金额即可，无需额外保存更早的记录。
    初始化：prepre, pre := nums[0], max(nums[0], nums[1])
    递推方程：i从2开始，prepre, pre = pre, max(prepre + nums[i], pre)
    返回值：pre
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;337&#34;&gt;
&lt;li&gt;打家劫舍 III（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;最大正方形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;若某个格子值为 ‘1’，则在以此格为右下角的正方形中，其最大边长为：上方正方形、左方正方形、左上方正方形 中最小的那条边长，最后再加上右下角格子本身的边长 1。
因此可得递推公式：dp[i][j] = 以坐标点(i,j) 为【右下角】的正方形最大边长 = min(左, 上, 左上) + 1
可参考下图：
在这里插入图片描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;br&gt;最大正方形的边长 并不一定是以 matrix二维数组 右下角的网格参与构成的，而是在遍历过程中不断比较并随时记录到 maxLen 变量中的。因此，最后返回的结果不是 dp[m][n] * dp[m][n]，而是 maxLen * maxLen。&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;遍历二维数组
    先判断当前matrix[i][j]值是否为’1’
        若当前格子值为字符 ‘1’，构造递推方程：
        首先，d[i][j]代表的是 以坐标点 (i,j) 为右下角的正方形最大边长。
        由于 以坐标点(i,j) 为【右下角】的正方形最大边长 = min(左, 上, 左上) + 1，故可得递推方程：dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1。这里的 +1：表示右下角的格子本身的边长，也要算上，也参与到组成的最大正方形中。
    若当前格子值为字符 ‘0’，跳过不作处理
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;279&#34;&gt;
&lt;li&gt;完全平方数 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;br&gt;找到 n 之前最大的一个完全平方数 j（j×j&amp;lt;&amp;#x3D;n），记为一个个数；那么 还剩 n-j×j 需要继续拼凑。也就是说只要将 n-j×j 的解 dp[n-j×j] 加上上面 j×j 所占的那个1，就是n的解，这就是最短的。&lt;br&gt;递推方程：dp[i] &amp;#x3D; min(dp[i], dp[i-j*j] + 1)&lt;/p&gt;
&lt;p&gt;注意：&lt;br&gt;此题和【322. 零钱兑换】类似，在初始化时都需要将dp数组所有元素初始化为 n+1，这样递推方程 dp[i] 在取较小值 min 时，才能获取到和为 n 的完全平方数的最少数量 。&lt;br&gt;300. 最长递增子序列 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;初始化：子序列一定都是至少包含 nums[i]本身，占1个长度，所以dp数组的所有元素都初始化为1
双层循环：外循环控制每轮遍历中的结尾位置为 i，内循环则是不断寻找 nums[j:i]区间内最大的递增子序列长度（j从0开始）。
注意：在内循环（j=0 → j=i）的过程中，dp[i]的值是不断变化的，我们要取的就是这一过程中dp[i]的最大值。
    if nums[j] &amp;lt; nums[i]，则说明当前子序列是递增子序列
        可得 递推方程：dp[i] = max(dp[i], dp[j] + 1)，其中 dp[i]表示：以 nums[i]为结尾的最长递增子序列的长度，且 nums[i]本身也占一个长度，因此 +1。
返回值：注意最后不能返回 dp[n-1]，因为最长递增子序列不一定就包含最末尾的元素，而是需要在循环中不断比较并保存到最终返回的结果中。

类似题目有：
1143. 最长公共子序列
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;309&#34;&gt;
&lt;li&gt;最佳买卖股票时机含冷冻期 ★★★ \color{red}{★★★} ★★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这道题的更多思路可以参考 我的题解，状态比较多，理解起来很绕，感觉有hard难度了，比较容易出错，具体代码及注释如下：&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 参考 LeetCode【评论区】题解：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24vc29sdXRpb25zLzE4MTczNC9mZWktemh1YW5nLXRhaS1qaS1kZS1kcGppYW5nLWppZS1jaGFvLWppLXRvbmctc3UteS8=&#34;&gt;https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/181734/fei-zhuang-tai-ji-de-dpjiang-jie-chao-ji-tong-su-y/&lt;/span&gt;&lt;br&gt;&amp;#x2F;&amp;#x2F; 题目要求：多次买卖一支股票&lt;br&gt;func maxProfit(prices []int) int {&lt;br&gt;    days :&amp;#x3D; len(prices)&lt;br&gt;    dp :&amp;#x3D; make([][]int, days)&lt;br&gt;    for i :&amp;#x3D; 0; i &amp;lt; len(prices); i++ {&lt;br&gt;        dp[i] &amp;#x3D; make([]int, 4) &amp;#x2F;&amp;#x2F; ABCD四种股票买卖中间状态&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// A.【当天不持有股票】并且也没有卖出操作：原本就不持有股票，可能前些天之前就早卖了没了
dp[0][0] = 0

// B.【当天不持有股票】因为&amp;lt;今天有卖出操作&amp;gt;：原本是有股票的，但是今天卖掉了就没了，所以不持有
dp[0][1] = 0 // 第0天，可以理解为今天买入股票，然后当天又卖出了，所以当前收益为0

// C.【当天持有股票】今天才最新买入的股票：前提是前一天没有卖出操作，不处于冷冻期
dp[0][2] = -prices[0]

// D.【当天持有股票】并不是今天买入的股票：可能是从前一天“继承”过来的股票，一直没操作而已
dp[0][3] = -prices[0] // 第0天特殊情况，初始化

for i := 1; i &amp;lt; days; i++ &amp;#123;
    // a.【当天不持有股票】并且也没有卖出操作
    // dp[i-1][0]：原本就一直没有股票
    // dp[i-1][1]：原本有但昨天刚卖了
    dp[i][0] = max(dp[i-1][0], dp[i-1][1])

    // b.【当天不持有股票】因为&amp;lt;今天有卖出操作&amp;gt;
    // dp[i-1][2]：昨天买入的股票，今天卖出
    // dp[i-1][3]：昨天之前早就买入的股票，今天卖出
    // 最后再加上今天买股票的钱 prices[i]
    dp[i][1] = max(dp[i-1][2], dp[i-1][3]) + prices[i]

    // c.【当天持有股票】今天才最新买入的股票
    // 题目要求：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
    // 所以这里的前提：前一天不能卖出股票（不满足dp[i-1][1]），且之前不持有股票（不满足dp[i-1][2]和dp[i-1][3]）
    // 那么今天才能买入，最后再减去今天买股票的钱 prices[i]
    dp[i][2] = dp[i-1][0] - prices[i]

    // d.【当天持有股票】并不是今天买入的股票
    // dp[i-1][2]：前一天买入的
    // dp[i-1][3]：前一天虽未买入但前一天之前就早早持有股票了
    dp[i][3] = max(dp[i-1][2], dp[i-1][3])
&amp;#125; 

// 因为买卖到最后，一定是不持有的（即使亏了，卖也比不卖强），所以应该是0和1两种状态，取较大值
return max(dp[days-1][0], dp[days-1][1])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func max(a, b int) int {&lt;br&gt;    if a &amp;gt; b {&lt;br&gt;        return a&lt;br&gt;    }&lt;br&gt;    return b&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;312&#34;&gt;
&lt;li&gt;戳气球（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;零钱兑换 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类似于LeetCode70：爬楼梯，每次爬1,2,5阶楼梯层数
双层循环，外循环表示待拼凑的 amount 数（从1到amount），内层循环表示可选的硬币种类（两层循环倒过来也ok，反正是求最少的硬币个数，并不是硬币的 无序组合 或 有序排列）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意dp数组初始化时的长度大小：dp := make([]int, amount+1)，表示从最初的0元逐步递推到amount元。
由于递推方程是求最小值min，所以初始dp数组时应该将其中所有元素初始化为大于amount的任意值，比如：amount + 1，这样才能获取到凑成当前amount的最小硬币数。
关键点：有一种情况，如果面额为 i-coins[j]的硬币不存在（无法正好拼凑），那么 dp[i-coins[j]]的值就还是一开始初始化dp数组时大于amount的任意值，例如：dp[i-coins[j]] = amount+1。然后再通过min函数取较小值时，就可以排除掉 i-coins[j]这种硬币面额不存在的情况。且最后也可以通过 if dp[amount] == amount+1，来判断是否有任何一种硬币组合能组成总金额amount。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 类似于LeetCode70：爬楼梯，每次爬1,2,5阶楼梯层数&lt;br&gt;func coinChange(coins []int, amount int) int {&lt;br&gt;    if amount &amp;#x3D;&amp;#x3D; 0 {&lt;br&gt;        return 0&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 假设最小硬币面额为1，那么最坏情况下，达到amount金额则至少需要amount个面额为1的硬币，且最开始还有个dp[0]，故dp长度最大为amount+1
max := amount + 1
dp := make([]int, max) 
dp[0] = 0
for i := 1; i &amp;lt; max; i++ &amp;#123;
    // 只要初始化为大于 amount 的任意数都可以
    // 主要用于下面的min函数取最小值，且在最后return时可借此判断dp[amount]的值是否有被修改过
    dp[i] = max
&amp;#125;

// i代表当前要凑的金额数，从0逐渐递增至amount
for i := 1; i &amp;lt;= amount; i++ &amp;#123; 
    // 分别选取coins数组中不同面额的硬币，找出其中最少的硬币个数
    // 例如示例1：选取硬币面额为1、2、5时，都对应不同的最少硬币个数，选取这其中硬币个数最少的一组结果
    for j := 0; j &amp;lt; len(coins); j++ &amp;#123;
        // 刚开始i代表的金额较小时，可能会导致 i-coins[j] 的值为负数，越界报错
        if i &amp;gt;= coins[j] &amp;#123;
            // 关键点：如果面额为 i-coins[j] 的硬币不存在（无法正好拼凑）
            // 那么 dp[i-coins[j]] 的值就还是一开始初始化dp数组时的&amp;quot;较大值&amp;quot;，即：dp[i-coins[j]] = amount+1
            // 然后在通过min函数取较小值时，就可以排除掉 i-coins[j] 这种硬币面额不存在的情况
            dp[i] = min(dp[i], dp[i-coins[j]] + 1) // +1：代表coins[j]自身所占的一个硬币数
        &amp;#125;
    &amp;#125;
&amp;#125;

// 若等于初始值amount + 1，则代表该记录未被修改过
if dp[amount] == max &amp;#123;
    return -1
&amp;#125;

// 最终不能正好拼凑为amount的dp[i]的值都为max

return dp[amount]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;416&#34;&gt;
&lt;li&gt;分割等和子集（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;目标和 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这道题用回溯属于easy 难度，用dp得有 hard 难度。&lt;br&gt;虽然这道题用动态规划来解，时间复杂度和空间复杂度上会更优，但是我没太能理解，所以暂时用的回溯法来做。&lt;/p&gt;
&lt;p&gt;回溯法 关键代码：&lt;/p&gt;
&lt;p&gt;func dfs(nums []int, target, sum, i int) {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 因为要用到nums数组中的每个元素来构造表达式，因此i最终会等于nums数组的长度&lt;br&gt;    &amp;#x2F;&amp;#x2F; 注意是与len(nums)比较，而不是len(nums) - 1&lt;br&gt;    if i &amp;#x3D;&amp;#x3D; len(nums) {&lt;br&gt;        if sum &amp;#x3D;&amp;#x3D; target {&lt;br&gt;            res++&lt;br&gt;        }&lt;br&gt;        return&lt;br&gt;    }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dfs(nums, target, sum + nums[k], k+1) // 加一个数
dfs(nums, target, sum - nums[k], k+1) // 减一个数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;647&#34;&gt;
&lt;li&gt;回文子串 ★★ \color{red}{★★} ★★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考 LeetCode大佬题解&lt;/p&gt;
&lt;p&gt;中心拓展法（个人认为该方法相对于动态规划来讲，更加清晰明了，便于理解）&lt;br&gt;因为回文串是中心对称的，我们可以先枚举子串的中心，然后从中心处向两边探测，直到发现两端字符不相等或者到达字符串边缘。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s长度为 奇数，中心是单个字符，以 s[i]为中心向两边扩展
s长度为 偶数，中心是两个字符，以 s[i]、s[i+1]为中心向两边扩展
在这里插入图片描述
当然该题也有 动态规划 的方法，但是个人认为以下代码更清晰明了。且因为该题比较具有技巧性，具体代码示例如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;func countSubstrings(s string) int {&lt;br&gt;    cnt, length :&amp;#x3D; 0, len(s)&lt;br&gt;    for i :&amp;#x3D; 0; i &amp;lt; length; i++ {&lt;br&gt;        &amp;#x2F;&amp;#x2F; 回文串s长度为”奇数”：&lt;br&gt;        l, r :&amp;#x3D; i, i &amp;#x2F;&amp;#x2F; s长度为奇数，中心是单个字符，以s[i]为中心向两边扩展&lt;br&gt;        for l &amp;gt;&amp;#x3D; 0 &amp;amp;&amp;amp; r &amp;lt; length &amp;amp;&amp;amp; s[l] &amp;#x3D;&amp;#x3D; s[r] {&lt;br&gt;            l–&lt;br&gt;            r++&lt;br&gt;            cnt++&lt;br&gt;        }&lt;br&gt;        &amp;#x2F;&amp;#x2F; 回文串s长度为”偶数”：&lt;br&gt;        l, r &amp;#x3D; i, i + 1 &amp;#x2F;&amp;#x2F; s长度为偶数，中心是两个字符，以s[i]、s[i+1]为中心向两边扩展&lt;br&gt;        for l &amp;gt;&amp;#x3D; 0 &amp;amp;&amp;amp; r &amp;lt; length &amp;amp;&amp;amp; s[l] &amp;#x3D;&amp;#x3D; s[r] {&lt;br&gt;            l–&lt;br&gt;            r++&lt;br&gt;            cnt++&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    return cnt&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;最长回文子串&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中心拓展法（个人认为该方法相对于动态规划来讲，更加清晰明了，便于理解）&lt;/p&gt;
&lt;p&gt;注：此题可以在上面的 [647. 回文子串] 题的基础上，加上对最长回文子串的逻辑判断 即可，具体示例代码如下：&lt;/p&gt;
&lt;p&gt;func longestPalindrome(s string) string {&lt;br&gt;    sLength, res :&amp;#x3D; len(s), “”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; sLength; i++ &amp;#123;
    // s长度为奇数，中心是单个字符，以s[i]为中心向两边扩展
    l, r := i, i 
    for l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; sLength &amp;amp;&amp;amp; s[l] == s[r] &amp;#123;
        // 通过比较找出更长的最长回文子串
        tmpLength := r - l + 1
        if tmpLength &amp;gt; len(res) &amp;#123;
            res = s[l:r+1]
        &amp;#125;

        l--
        r++
    &amp;#125;

    // s长度为偶数，中心是两个字符，以s[i]、s[i+1]为中心向两边扩展
    l, r = i, i + 1 
    for l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; sLength &amp;amp;&amp;amp; s[l] == s[r] &amp;#123;
        // 通过比较找出更长的最长回文子串
        tmpLength := r - l + 1
        if tmpLength &amp;gt; len(res) &amp;#123;
            res = s[l:r+1]
        &amp;#125;

        l-- 
        r++
    &amp;#125;
&amp;#125;
return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十六、滑动窗口（共4题，含2道 h a r d \color{red}{hard} hard 题）&lt;br&gt;3. 无重复字符的最长子串 ★★★ \color{red}{★★★} ★★★&lt;/p&gt;
&lt;p&gt;此题和 剑指 Offer 48. 最长不含重复字符的子字符串 相同，思路可参考 LeetCode视频题解&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义双指针 start，end := 0, 0 来维护滑动窗口大小，双层循环：
外层循环负责固定每次字符的结束位置end，并记录待比较字符 cmpStr := s[end]，
而内层循环负责判断 cmpStr = s[end] 是否在区间 s[start:end) 中出现过（这里循环判断是否出现重复字符，可以通过map来记录字符最后出现的下标位置：m[cmpStr] = end，利用空间换时间的思想，使得时间复杂度提升为O(n)）
    若出现过则将start移动到出现位置的后一个位置（去重），并更新length为 end - start；
    反之不处理
最后在内循环外面更新maxLength和end的边界值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建左右两个指针，start和 end，end下标不断向右移动。
内循环 每次判断当前遍历到的新的 s[end]是否在之前已出现过（即是否重复出现）。
若出现过，则将 start下标指向之前出现位置的下一个位置，并更新当前不重复子串长度 length = end - start (这里本来应该是 length = end -start + 1，但被合并到了内循环外面的 length++中)。
这一过程其实是为了跳过之前的重复字符（比如 abbbc，最终会跳过中间的 bbb）。
更新右指针下标 end++和 maxLength = max(maxLength, length)子串的最大长度，且 length++使得不重复子串长度加1。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法1-滑动窗口 利用map优化前：&lt;br&gt;&amp;#x2F;&amp;#x2F; 时间复杂度：O(n^2)，空间复杂度：O(1)&lt;br&gt;&amp;#x2F;*&lt;br&gt;思路：&lt;br&gt;定义双指针left，right，来维护滑动窗口左右边界，双层循环：&lt;br&gt;外循环负责固定每次字符的结束位置right，并记录待比较字符cmpStr :&amp;#x3D; s[right]，&lt;br&gt;而内循环则判断 cmpStr &amp;#x3D; s[right] 是否在区间 s[left:right) 中出现过（这里循环判断是否出现重复字符，可以用map来记录字符最后出现的下标位置：m[cmpStr] &amp;#x3D; right，利用空间换时间的思想，使得时间复杂度提升为O(n)）&lt;br&gt;若出现过则将left移动到出现位置的后一个位置（去重），并更新length为 right - left；&lt;br&gt;反之不处理&lt;br&gt;最后在内循环外面更新maxLength和right的边界值&lt;br&gt;*&amp;#x2F;&lt;br&gt;func lengthOfLongestSubstring(s string) int {&lt;br&gt;    &amp;#x2F;&amp;#x2F; left：无重复字符的子串左边界；right：右边界&lt;br&gt;    &amp;#x2F;&amp;#x2F; length：当前子串长度；maxLength：最长子串长度&lt;br&gt;    left, right, length, maxLength :&amp;#x3D; 0, 0, 0, 0&lt;br&gt;    for right &amp;lt; len(s) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    // 过滤重复字符：将cmpChar与s[left:right)的字符逐个比较。比如abbbc，最终会跳过中间的bbb
    for i := left; i &amp;lt; right; i++ &amp;#123;
        if s[i] == s[right] &amp;#123;
            left = i + 1        // 若出现重复字符，left跳过重复字符，指向重复字符的下一位置
            length = right - left // 计算length时外循环中会对length++，所以这里暂时无需+1操作
            break                // s[left:right)中已经存在相同字符，break退出进行下一轮外循环
        &amp;#125;
    &amp;#125;
    length++ 
    right++ // 扩展右边界
    maxLength = max(maxLength, length)
&amp;#125;

return maxLength
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&amp;#x2F;******************************************************************&amp;#x2F;&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; 方法2-滑动窗口 利用map优化后（判断tmpStr在s[start,end)中之前是否已经重复出现过）：&lt;br&gt;&amp;#x2F;&amp;#x2F; 时间复杂度：O(n)，空间复杂度：O(n)&lt;br&gt;&amp;#x2F;&amp;#x2F; 1、创建map，key:每个字符，val:s中每个字符最后出现的下标&lt;br&gt;&amp;#x2F;&amp;#x2F; map用于判断某个字符是否在滑动窗口中出现过&lt;br&gt;&amp;#x2F;&amp;#x2F; 2.1、如果某字符在滑动窗口中出现过，则更新滑动窗口左边界，并记录子串长度，扩大右边界&lt;br&gt;&amp;#x2F;&amp;#x2F; 2.2、反之，扩大右边界，这两步扩大右边界的操作可合并&lt;br&gt;&amp;#x2F;&amp;#x2F; 3、过程中不断更新最长子串长度res&lt;br&gt;func lengthOfLongestSubstring(s string) int {&lt;br&gt;    &amp;#x2F;&amp;#x2F; left：无重复字符的子串左边界；right：右边界&lt;br&gt;    &amp;#x2F;&amp;#x2F; length：当前子串长度；maxLength：最长子串长度&lt;br&gt;    left, right, length, maxLength, sLength :&amp;#x3D; 0, 0, 0, 0, len(s)&lt;br&gt;    lastIndexMap :&amp;#x3D; make(map[byte]int) &amp;#x2F;&amp;#x2F; 存储已遍历字符最后出现的下标位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 滑动窗口的左右边界控制，右边界要一直右移
for right &amp;lt; sLength &amp;#123;
    cmpChar := s[right]

    if lastIndex, ok := lastIndexMap[cmpChar]; ok &amp;amp;&amp;amp; lastIndex &amp;gt;= left &amp;#123;
        // 之前出现过该字符，更新left，length
        left = lastIndex + 1
        length = right - left
    &amp;#125;/* else &amp;#123;
        // 之前未出现过该字符，右移滑动窗口右边界
        right++ // 该步骤统一合并到下面的right++中
    &amp;#125;*/
    lastIndexMap[cmpChar] = right
   
    length++
    right++ // 右移右边界
    maxLength = max(maxLength, length)
&amp;#125;

return maxLength
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;76&#34;&gt;
&lt;li&gt;最小覆盖子串（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;滑动窗口最大值（ h a r d \color{red}{hard} hard 题，暂时跳过）&lt;/li&gt;
&lt;li&gt;找到字符串中所有字母异位词 ★ \color{red}{★} ★&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：&lt;br&gt;将长度为 len(p)且不断右移的滑动窗口sCntArr与pCntArr比较&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;先构建两个[26]int数组 sCntArr 和 pCntArr，分别统计&amp;quot;在s中滑动的滑动窗口&amp;quot;和&amp;quot;被比较字符串p&amp;quot;中字母出现的次数
正式比较两数组前，先要根据字符串p来填充1次sCntArr和pCntArr，并判断是否为异位词
后续只需更新滑动窗口并比较，不断使其右移即可（左出右进，保证滑动窗口长度为 len(p)）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，获取 sLen = len(s)和 pLen = len(p)，如果 sLen &amp;lt; pLen，直接返回空结果集。
然后，创建两个长度为 26 的 int 类型数组 sCntArr和 pCntArr，用作比较【长度为pLen，在字符串s中不断向右滑动的滑动窗口中对应子串】与【给定字符串p】是否是字母异位词。
初始化这两个数组，并进行 首次比较 ，若相同则向结果集中追加当前滑动窗口的起始位置 0。

// 初始化这两个数组
// 分别统计【在s中滑动的滑动窗口】和【被比较字符串p】中字母出现的次数
for i := 0; i &amp;lt; len(p); i++ &amp;#123;
    pCntArr[p[i] - &amp;#39;a&amp;#39;] += 1
    sCntArr[s[i] - &amp;#39;a&amp;#39;] += 1
&amp;#125;

// 首次比较
if sCntArr == pCntArr &amp;#123;
    // 字符串s[:pLen]为p的字母异位词
    res = append(res, 0)
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12

在 后续比较 中，滑动窗口每次从左边滑出一个扫描过的旧字符，从右边滑进一个未扫描过的新字符。然后比较两个数组 sCntArr和 pCntArr是否相同，若相同则向结果集中追加当前滑动窗口的起始位置 i+1。

for i := 0; i &amp;lt; sLen - pLen; i++ &amp;#123;
    // 左边滑出一个扫描过的旧字符
    sCntArr[s[i] - &amp;#39;a&amp;#39;] -= 1 
    // 右边滑进一个未扫描过的新字符
    sCntArr[s[i+pLen] - &amp;#39;a&amp;#39;] += 1

    if sCntArr == pCntArr &amp;#123;
        res = append(res, i+1)
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10

最后返回结果集
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十七、贪心（共1题）&lt;br&gt;55. 跳跃游戏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;贪心法-1 【从左向右】，参考 LeetCode题解
    定义一个 maxJump = 0，表示从头开始能跳到的最大覆盖范围，每次都只向右跳一次
    for 循环：for i := 0; i &amp;lt;= maxJump; i++ &amp;#123;
        更新 maxJump 范围 maxJump = max(maxJump, i + nums[i])，在 “上一次索引能覆盖的范围” 和 “当前索引能覆盖的范围” 中取一个较大值，作为当前能跳跃到的的最远距离
        每次循环都判断：当 目前能跳跃的最大范围 maxJump&amp;gt;= 数组最后一个索引 len(nums) - 1时，返回 true，否则返回 false。
贪心法 2：【从右向左】，参考 B站视频题解 最后面讲解的贪心法
    起初定义一个 maxJump = len(nums) - 1，表示最终要跳到数组最后一个下标位置
    从倒数第二个下标位置开始判断 能否到达最后一个下标位置：若满足【当前下标位置i + 当前可跳跃最大长度nums[i] &amp;gt;= 这一轮循环中要到达的目标位置 maxJump】，则表示从当前下标位置可以到达它右侧的目标位置 maxJump。
    其实就是判断 倒数第二个位置 是否能到达 倒数第一个位置 。若能到达，则继续判断 倒数第三个位置 是否能到达 倒数第二个位置，以此类推 … 最终到给定数组nums的首位置（下标为0）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十八、数学（共1题）&lt;br&gt;48. 旋转图像 ★ \color{red}{★} ★&lt;/p&gt;
&lt;p&gt;思路：此题比较有技巧性，分为以下两步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主对角线（左上至右下）翻转
以中心轴水平翻转每一行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;func rotate(matrix [][]int)  {&lt;br&gt;    &amp;#x2F;&amp;#x2F; 因为题目说是n*n的矩阵，所以这里实际上m&amp;#x3D;n&lt;br&gt;    m, n :&amp;#x3D; len(matrix), len(matrix[0])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对角线翻转（左上至右下）
for i := 0; i &amp;lt; m; i++ &amp;#123;
    for j := 0; j &amp;lt; i; j++ &amp;#123; // 注意：这里j &amp;lt; i
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    &amp;#125;
&amp;#125;

// 水平翻转
for i := 0; i &amp;lt; m; i++ &amp;#123;
    for j := 0; j &amp;lt; n/2; j++ &amp;#123; // 注意：这里j &amp;lt; n/2
        matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;go&lt;br&gt;运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;补充一道类似技巧性的非 HOT100🔥 的高频题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;189. 轮转数组
假设数组长度为：n = len(nums)
先整体翻转：0 ~ n-1
再翻转前 k 个：0 ~ k-1
最后翻转后 n - k 个： k ~ n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;十九、其它（共2题，含1道 力扣 V I P 专属 \color{red}{力扣VIP专属} 力扣VIP专属 题）&lt;br&gt;253. 会议室 II（ 力扣 V I P 专属 \color{red}{力扣VIP专属} 力扣VIP专属 题，暂时跳过）&lt;br&gt;621. 任务调度器（ m i d d l e \color{orange}{middle} middle 题，暂时跳过）&lt;/p&gt;
&lt;p&gt;以下 m i d d l e \color{orange}{middle} middle 题目我暂时跳过了，后面有精力再研究：&lt;/p&gt;
&lt;ol start=&#34;406&#34;&gt;
&lt;li&gt;根据身高重建队列&lt;/li&gt;
&lt;li&gt;乘积最大子数组&lt;/li&gt;
&lt;li&gt;分割等和子集&lt;/li&gt;
&lt;li&gt;打家劫舍 III&lt;/li&gt;
&lt;li&gt;最短无序连续子数组&lt;/li&gt;
&lt;li&gt;会议室 II&lt;/li&gt;
&lt;li&gt;任务调度器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
3
4
5
6
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见高频题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;88. 合并两个有序数组，倒序双指针，类似于 21. 合并两个有序链表
面试题 01.06. 字符串压缩，类似于 443. 压缩字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;————————————————&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
                    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=&#34;&gt;https://blog.csdn.net/qq_37102984/article/details/128576283&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
            <title>java高频面试题</title>
            <link>http://example.com/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
            <category>Hexo</category>
            <category>博客</category>
            <pubDate>Mon, 21 Jul 2025 00:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;JavaSE&#34;&gt;&lt;a href=&#34;#JavaSE&#34; class=&#34;headerlink&#34; title=&#34;JavaSE&#34;&gt;&lt;/a&gt;JavaSE&lt;/h2&gt;&lt;h3 id=&#34;1-什么是JAVA&#34;&gt;&lt;a href=&#34;#1-什么是JAVA&#34; class=&#34;headerlink&#34; title=&#34;1. 什么是JAVA?&#34;&gt;&lt;/a&gt;1. 什么是JAVA?&lt;/h3&gt;&lt;p&gt;Java 是一门面向对象的编程语言，吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。比较重要的特点就是跨平台性，只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。还有面向对象、多线程，JVM等这些让Java变得高效。Java最适合用来做后端开发，有很多成熟的技术栈，比如Springboot,springcloud等。&lt;/p&gt;
&lt;h3 id=&#34;2-Java-有哪些数据类型？&#34;&gt;&lt;a href=&#34;#2-Java-有哪些数据类型？&#34; class=&#34;headerlink&#34; title=&#34;2. Java 有哪些数据类型？&#34;&gt;&lt;/a&gt;2. Java 有哪些数据类型？&lt;/h3&gt;&lt;p&gt;基本数据类型和引用数据类型两大类。基本数据类型有：数值型（byte,short,int,long）、浮点型(float,double)、布尔型boolean。引用数据类型有类，数组和接口。&lt;/p&gt;
&lt;h3 id=&#34;3-面向对象编程有哪些特性？&#34;&gt;&lt;a href=&#34;#3-面向对象编程有哪些特性？&#34; class=&#34;headerlink&#34; title=&#34;3. 面向对象编程有哪些特性？&#34;&gt;&lt;/a&gt;3. 面向对象编程有哪些特性？&lt;/h3&gt;&lt;p&gt;封装、继承和多态。封装就是把一些属性和方法捆在一起形成一个类，我们可以实例化这个类变成对象，对象可以设置和获取属性，调用方法。开发中就是对象之间的交互。继承就是子类获得父类的所有属性和方法，子类还可以进行扩充或者方法重写。多态就是java运行时可以根据对象类型产生不同的结果。子类需要继承父类并重写父类方法，父类引用指向子类对象。&lt;/p&gt;
&lt;h3 id=&#34;4-抽象类和接口有什么区别？&#34;&gt;&lt;a href=&#34;#4-抽象类和接口有什么区别？&#34; class=&#34;headerlink&#34; title=&#34;4. 抽象类和接口有什么区别？&#34;&gt;&lt;/a&gt;4. 抽象类和接口有什么区别？&lt;/h3&gt;&lt;p&gt;一个类只能继承一个抽象类；但一个类可以实现多个接口。比如我们创建线程类的时候一般用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。抽象类符合 is-a 的关系，而接口更像是 has-a 的关系。比如说一个类可以序列化的时候，它只需要实现 Serializable 接口，代表它有这个功能，而不是继承一个序列化类。&lt;/p&gt;
&lt;h3 id=&#34;5-和-equals-的区别？&#34;&gt;&lt;a href=&#34;#5-和-equals-的区别？&#34; class=&#34;headerlink&#34; title=&#34;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&#34;&gt;&lt;/a&gt;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D; 操作符和 equals() 方法用于比较两个对象：&amp;#x3D;&amp;#x3D;比较两个对象的引用，也就是说在内存中是不是同一份数据。对于基本数据类型（如 int, double, char 等），&amp;#x3D;&amp;#x3D; 比较的是值是否相等。equals比较的是两个对象的内容是否相等，默认跟&amp;#x3D;&amp;#x3D;相同，我们一般会对他重写来用于比较值（比如属性）是否相同而不是引用。&lt;/p&gt;
&lt;h3 id=&#34;6-为什么重写-equals-时必须重写-hashCode-⽅法？&#34;&gt;&lt;a href=&#34;#6-为什么重写-equals-时必须重写-hashCode-⽅法？&#34; class=&#34;headerlink&#34; title=&#34;6. 为什么重写 equals 时必须重写 hashCode ⽅法？&#34;&gt;&lt;/a&gt;6. 为什么重写 equals 时必须重写 hashCode ⽅法？&lt;/h3&gt;&lt;p&gt;因为基于哈希的集合类（如 HashMap）需要使用hashCode和equals方法来存储和查找对象。存储时首先根据键的hashCode计算出在数组中的存储位置，每个位置可以存单个值、链表和红黑树，如果没有重写hashCode方法，两个相同的键可能出现不同的hashCode导致它们被存在数组中的不同位置，获取时就发生错误。发生哈希冲突时，键会被存在数组的同一个桶中，通过链表和红黑树解决哈希冲突问题，发生哈希冲突的桶中元素的hashCode值相同，必须再用equals比较值才能找出对应元素，如果没有重写equals()方法就找不到需要的元素。&lt;/p&gt;
&lt;h3 id=&#34;7-String-和-StringBuilder、StringBuffer-的区别？&#34;&gt;&lt;a href=&#34;#7-String-和-StringBuilder、StringBuffer-的区别？&#34; class=&#34;headerlink&#34; title=&#34;7. String 和 StringBuilder、StringBuffer 的区别？&#34;&gt;&lt;/a&gt;7. String 和 StringBuilder、StringBuffer 的区别？&lt;/h3&gt;&lt;p&gt;它们都是用于处理字符串的，String底层用了final修饰是不可变的，每次修改都会创建一个新对象，开销很大，如果要频繁修改字符串可以用StringBuilder，它是在原对象上修改。StringBuffer跟StringBuilder相似，但是它的方法上都加了 synchronized 关键字，是线程安全的，这在单线程下效率比较低。&lt;/p&gt;
&lt;h3 id=&#34;8-Java-中异常处理体系&#34;&gt;&lt;a href=&#34;#8-Java-中异常处理体系&#34; class=&#34;headerlink&#34; title=&#34;8. Java 中异常处理体系?&#34;&gt;&lt;/a&gt;8. Java 中异常处理体系?&lt;/h3&gt;&lt;p&gt;主要有两大类，错误和异常，错误指的是程序无法处理的严重错误，比如内存溢出，栈溢出，这些错误通常与 JVM 的运行状态有关。异常分为编译时异常和运行时异常，编译时异常可以被try-catch捕获处理或者throws抛出，比如IOException、SQLException，运行时异常通常是代码逻辑错误，比如数组越界，空指针等。&lt;/p&gt;
&lt;h3 id=&#34;9-BIO、NIO、AIO-之间的区别？&#34;&gt;&lt;a href=&#34;#9-BIO、NIO、AIO-之间的区别？&#34; class=&#34;headerlink&#34; title=&#34;9. BIO、NIO、AIO 之间的区别？&#34;&gt;&lt;/a&gt;9. BIO、NIO、AIO 之间的区别？&lt;/h3&gt;&lt;p&gt;BIO：采用阻塞式 I&amp;#x2F;O 模型，基于字节流或字符流文件读写，基于 Socket 和 ServerSocket 进行网络通信，适用于连接数较少的场景，每个连接，都需要创建一个单独的线程来处理读写操作。&lt;br&gt;NIO：采用非阻塞 I&amp;#x2F;O 模型，线程在等待 I&amp;#x2F;O 时可执行其他任务，主要用在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，适用于连接数多但连接时间短的场景。&lt;br&gt;AIO：使用异步 I&amp;#x2F;O 模型，线程发起 I&amp;#x2F;O 请求后立即返回，不需要等待，当 I&amp;#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。&lt;/p&gt;
&lt;h3 id=&#34;10-🌟什么是反射？应用？原理？&#34;&gt;&lt;a href=&#34;#10-🌟什么是反射？应用？原理？&#34; class=&#34;headerlink&#34; title=&#34;10. 🌟什么是反射？应用？原理？&#34;&gt;&lt;/a&gt;10. 🌟什么是反射？应用？原理？&lt;/h3&gt;&lt;p&gt;反射就是在运行时动态地获取类的信息，然后使用它的属性和方法的技术。Spring 框架动态加载和管理 Bean、AOP的动态代理，还有Junit测试框架这些都用到了反射，我们可以用Class.forName通过类名获取一个类，然后调用newInstance方法创建实例对象，getMethod，invoke方法可以获取和调用方法，getDeclaredField可以获取属性，对于私有属性可以调用setAccessible(true); 让它可见。原理就是Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。&lt;/p&gt;
&lt;h2 id=&#34;Java集合&#34;&gt;&lt;a href=&#34;#Java集合&#34; class=&#34;headerlink&#34; title=&#34;Java集合&#34;&gt;&lt;/a&gt;Java集合&lt;/h2&gt;&lt;h3 id=&#34;1-常见集合有哪些？&#34;&gt;&lt;a href=&#34;#1-常见集合有哪些？&#34; class=&#34;headerlink&#34; title=&#34;1. 常见集合有哪些？&#34;&gt;&lt;/a&gt;1. 常见集合有哪些？&lt;/h3&gt;&lt;p&gt;集合有两大类，Collection 接口和Map 接口。Collection 接口下有List、Set,和Queue, List包含有序可重复的元素。实现类包括 ArrayList、LinkedList。Set是无序不重复的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。Queue是队列。实现类包括 PriorityQueue、ArrayDeque 等。Map 是表示键值对的集合。键不能重复。实现类包括 HashMap、LinkedHashMap、TreeMap 等。&lt;/p&gt;
&lt;h3 id=&#34;2-哪些是线程安全的容器？&#34;&gt;&lt;a href=&#34;#2-哪些是线程安全的容器？&#34; class=&#34;headerlink&#34; title=&#34;2. 哪些是线程安全的容器？&#34;&gt;&lt;/a&gt;2. 哪些是线程安全的容器？&lt;/h3&gt;&lt;p&gt;像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;3-ArrayList-和-LinkedList-有什么区别？&#34;&gt;&lt;a href=&#34;#3-ArrayList-和-LinkedList-有什么区别？&#34; class=&#34;headerlink&#34; title=&#34;3. ArrayList 和 LinkedList 有什么区别？&#34;&gt;&lt;/a&gt;3. ArrayList 和 LinkedList 有什么区别？&lt;/h3&gt;&lt;p&gt;ArrayList 底层是动态数组，内存是连续的，查找快，增删慢，适合经常通过索引访问，在末尾增删的场景，LinkedList 底层是双向链表，查找慢，增删快，适合频繁增删的场景。&lt;/p&gt;
&lt;h3 id=&#34;4-ArrayList-的扩容机制了解吗？底层实现？&#34;&gt;&lt;a href=&#34;#4-ArrayList-的扩容机制了解吗？底层实现？&#34; class=&#34;headerlink&#34; title=&#34;4. ArrayList 的扩容机制了解吗？底层实现？&#34;&gt;&lt;/a&gt;4. ArrayList 的扩容机制了解吗？底层实现？&lt;/h3&gt;&lt;p&gt;当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就调用grow方法生成一个1.5倍容量的新数组，然后拷贝元素到新数组中。&lt;/p&gt;
&lt;h3 id=&#34;5-ArrayList-怎么序列化的知道吗？&#34;&gt;&lt;a href=&#34;#5-ArrayList-怎么序列化的知道吗？&#34; class=&#34;headerlink&#34; title=&#34;5. ArrayList 怎么序列化的知道吗？&#34;&gt;&lt;/a&gt;5. ArrayList 怎么序列化的知道吗？&lt;/h3&gt;&lt;p&gt;它重写了writeObject 方法用于自定义序列化：只序列化有效数据，因为实际存储的元素数量一般小于elementData 数组的容量，声明的时候也加了 transient 关键字防止被默认序列化。&lt;/p&gt;
&lt;h3 id=&#34;6-HashMap实现原理？-高频&#34;&gt;&lt;a href=&#34;#6-HashMap实现原理？-高频&#34; class=&#34;headerlink&#34; title=&#34;6. HashMap实现原理？(高频)&#34;&gt;&lt;/a&gt;6. HashMap实现原理？(高频)&lt;/h3&gt;&lt;p&gt;JDK8之前是数组+链表。之后是数组+链表+红黑树。存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：如果key相同，覆盖原值。 key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。它的初始容量16，加载因子0.75。创建时使用懒加载，不初始化容量。&lt;/p&gt;
&lt;h3 id=&#34;7-HashMap的put方法的具体流程？-高频&#34;&gt;&lt;a href=&#34;#7-HashMap的put方法的具体流程？-高频&#34; class=&#34;headerlink&#34; title=&#34;7. HashMap的put方法的具体流程？(高频)&#34;&gt;&lt;/a&gt;7. HashMap的put方法的具体流程？(高频)&lt;/h3&gt;&lt;p&gt;第一步检查数组是否为空，首次put时，调用resize()初始化数组，默认容量为 16，负载因子为0.75。&lt;br&gt;第二步，计算键的哈希值，具体是将 键的hashCode 异或 hashCode 右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。&lt;br&gt;第三步，根据键的哈希值计算数组索引，具体是将键的哈希值 与上 数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高所以用与运算代替模运算，但前提是数组长度是2的N次幂）。&lt;br&gt;第四步，检查数组索引对应槽位的情况。如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。&lt;/p&gt;
&lt;p&gt;hashMap的寻址算法：扰动算法，通过hash方法，hashcode ^ hashcode &amp;lt;&amp;lt;&amp;lt; 16。&lt;br&gt;首先计算键的hashCode,再调用hash方法进行二次哈希，hashCode右移16位再和hashCode进行异或运算，减少哈希冲突，最后用哈希值 与 容量 -1 得到索引。&lt;/p&gt;
&lt;h3 id=&#34;8-讲一讲HashMap的扩容机制-高频&#34;&gt;&lt;a href=&#34;#8-讲一讲HashMap的扩容机制-高频&#34; class=&#34;headerlink&#34; title=&#34;8. 讲一讲HashMap的扩容机制(高频)&#34;&gt;&lt;/a&gt;8. 讲一讲HashMap的扩容机制(高频)&lt;/h3&gt;&lt;p&gt;当哈希表中元素个数超过阈值时会触发扩容resize方法，这个阈值是 数组容量 * 负载因子,数组容量初始是16，负载因子默认是0.75。&lt;br&gt;扩容时：&lt;br&gt;第一步，创建一个新数组，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。&lt;br&gt;第二步，迁移元素，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过e.hash &amp;amp; (newCap新容量 - 1)计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为低位链和高位链，避免重新哈希带来性能损耗，如果 e.hash &amp;amp; oldCap &amp;#x3D;&amp;#x3D; 0（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。&lt;/p&gt;
&lt;p&gt;为何HashMap的数组长度一定是2的次幂?&lt;br&gt;数组长度是 2 的幂次方时，hash % length和hash &amp;amp; (length - 1)的计算结果是一样的。不过按位与运算在性能上更具优势。计算索引时效率更高，扩容时效率更高。&lt;/p&gt;
&lt;h3 id=&#34;9-HashMap-是线程安全的吗？&#34;&gt;&lt;a href=&#34;#9-HashMap-是线程安全的吗？&#34; class=&#34;headerlink&#34; title=&#34;9. HashMap 是线程安全的吗？&#34;&gt;&lt;/a&gt;9. HashMap 是线程安全的吗？&lt;/h3&gt;&lt;p&gt;不是。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。多线程在进行 put 元素的时候，可能会导致元素丢失。因为put操作不是原子的。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素先插入的元素被覆盖而丢失put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get就可能获取不到元素。线程 1 执行完 table &amp;#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引 元素可能就 get 不到了。&lt;/p&gt;
&lt;h3 id=&#34;1-怎么解决HashMap线程不安全问题？&#34;&gt;&lt;a href=&#34;#1-怎么解决HashMap线程不安全问题？&#34; class=&#34;headerlink&#34; title=&#34;1. 怎么解决HashMap线程不安全问题？&#34;&gt;&lt;/a&gt;1. 怎么解决HashMap线程不安全问题？&lt;/h3&gt;&lt;p&gt;早期的 JDK 版本中，可以用 &lt;code&gt;Hashtable&lt;/code&gt; 来保证线程安全。&lt;code&gt;Hashtable&lt;/code&gt; 在方法上加了 &lt;code&gt;synchronized&lt;/code&gt; 关键字。但是它同步开销比较大、还不支持 null、扩容效率低，已经被淘汰。多线程场景下推荐使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;，它使用了分段锁优化，性能远超 &lt;code&gt;HashTable&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;并发与JUC高频面试题&#34;&gt;&lt;a href=&#34;#并发与JUC高频面试题&#34; class=&#34;headerlink&#34; title=&#34;并发与JUC高频面试题&#34;&gt;&lt;/a&gt;并发与JUC高频面试题&lt;/h2&gt;&lt;h3 id=&#34;2-进程和线程的区别？&#34;&gt;&lt;a href=&#34;#2-进程和线程的区别？&#34; class=&#34;headerlink&#34; title=&#34;2. 进程和线程的区别？&#34;&gt;&lt;/a&gt;2. 进程和线程的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：程序在操作系统中的一次执行，是系统进行资源分配和调度的基本单位，拥有独立内存空间和系统资源，进程间切换开销大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;：进程中的一个执行单元，是 CPU 调度的基本单位，共享所属进程的资源，线程间切换开销小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行&lt;/strong&gt;：多个任务同时执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发&lt;/strong&gt;：多个任务通过时间片轮转在一段时间内交替执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-线程创建的方式有哪些？&#34;&gt;&lt;a href=&#34;#3-线程创建的方式有哪些？&#34; class=&#34;headerlink&#34; title=&#34;3. 线程创建的方式有哪些？&#34;&gt;&lt;/a&gt;3. 线程创建的方式有哪些？&lt;/h3&gt;&lt;p&gt;有四种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口，线程池创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 继承 Thread 类&lt;/strong&gt;：需要重写父类 Thread 的 run() 方法，然后调用 start() 方法启动线程。缺点是，如果 ThreadTask 已经继承了另外一个类，就不能再继承 Thread 类了，因为 Java 不支持多重继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 实现 Runnable 接口&lt;/strong&gt;：重写 Runnable 接口的 run() 方法，然后把它作为参数传给 Thread类，最后调用 start() 方法启动线程。这种方式的优点是可以避免 Java 的单继承限制，缺点是没有返回值，拿不到线程执行结果并且不能抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现 Callable 接口&lt;/strong&gt;：重写 Callable 接口的 call() 方法，然后创建一个 CallableTask 对象，然后创建 FutureTask 对象，构造方法中以 CallableTask 实例传参；然后创建 Thread 对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;CallableTask&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;CallableTask&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;FutureTask&amp;lt;String&amp;gt; futureTask = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;FutureTask&lt;/span&gt;&amp;lt;&amp;gt;(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(futureTask);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;thread.start();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;4. 线程池创建&lt;/strong&gt;：实现 Runnable 或 Callable 接口后，提交给线程池执行。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-线程包括哪些状态，状态之间是如何变化的？&#34;&gt;&lt;a href=&#34;#4-线程包括哪些状态，状态之间是如何变化的？&#34; class=&#34;headerlink&#34; title=&#34;4. 线程包括哪些状态，状态之间是如何变化的？&#34;&gt;&lt;/a&gt;4. 线程包括哪些状态，状态之间是如何变化的？&lt;/h3&gt;&lt;p&gt;Thread类中有一个枚举类State，一共6种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建(NEW)&lt;/li&gt;
&lt;li&gt;可运行(RUNNABLE)&lt;/li&gt;
&lt;li&gt;阻塞(BLOCKED)&lt;/li&gt;
&lt;li&gt;等待（WAITING）&lt;/li&gt;
&lt;li&gt;时间等待(TIMED_WAITING)&lt;/li&gt;
&lt;li&gt;终止(TERMINATED)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建线程对象是新建状态&lt;/li&gt;
&lt;li&gt;调用了start()方法转变为可执行状态&lt;/li&gt;
&lt;li&gt;线程获取到了CPU的执行权，执行结束是终止状态&lt;/li&gt;
&lt;li&gt;在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态&lt;/li&gt;
&lt;li&gt;如果没有获取锁(synchronized或lock)进入阻塞状态，获得锁再切换为可执行状态&lt;/li&gt;
&lt;li&gt;如果线程调用了wait()方法进入等待状态，其他线程调用notify(唤醒后可切换为可执行状态)&lt;/li&gt;
&lt;li&gt;如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;5-在java中wait和sleep方法的不同&#34;&gt;&lt;a href=&#34;#5-在java中wait和sleep方法的不同&#34; class=&#34;headerlink&#34; title=&#34;5. 在java中wait和sleep方法的不同&#34;&gt;&lt;/a&gt;5. 在java中wait和sleep方法的不同&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;都能让线程进入阻塞状态，并且都可以传一个时间参数等待相应毫秒数醒来，也都能被打断唤醒。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sleep方法&lt;/strong&gt;是Thread类的静态方法，而&lt;strong&gt;wait方法&lt;/strong&gt;是Object类的成员方法。&lt;/li&gt;
&lt;li&gt;wait方法可以被notify方法唤醒，如果没传时间参数也没被唤醒就一直等待。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁不同&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;wait方法的调用必须先获取wait对象的锁，wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu，但你们还可以用）。&lt;/li&gt;
&lt;li&gt;sleep调用不用获取锁，sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;6-如何停止一个正在运行的线程&#34;&gt;&lt;a href=&#34;#6-如何停止一个正在运行的线程&#34; class=&#34;headerlink&#34; title=&#34;6. 如何停止一个正在运行的线程&#34;&gt;&lt;/a&gt;6. 如何停止一个正在运行的线程&lt;/h3&gt;&lt;p&gt;三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用退出标志&lt;/strong&gt;，使线程正常退出，也就是当run方法完成后线程终止。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;stop方法强行终止&lt;/strong&gt;（不推荐，方法已作废）。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;interrupt方法&lt;/strong&gt;中断线程。&lt;ul&gt;
&lt;li&gt;打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常。&lt;/li&gt;
&lt;li&gt;打断正常的线程，可以根据打断状态来标记是否退出线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;7-线程中并发安全（高频，难答）&#34;&gt;&lt;a href=&#34;#7-线程中并发安全（高频，难答）&#34; class=&#34;headerlink&#34; title=&#34;7. 线程中并发安全（高频，难答）&#34;&gt;&lt;/a&gt;7. 线程中并发安全（高频，难答）&lt;/h3&gt;&lt;h4 id=&#34;synchronized关键字的底层原理&#34;&gt;&lt;a href=&#34;#synchronized关键字的底层原理&#34; class=&#34;headerlink&#34; title=&#34;synchronized关键字的底层原理&#34;&gt;&lt;/a&gt;synchronized关键字的底层原理&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在jdk1.6之前，&lt;code&gt;synchronized&lt;/code&gt;被称为&lt;strong&gt;重量级锁&lt;/strong&gt;。底层核心是&lt;strong&gt;monitor（监视器）&lt;/strong&gt;，它是 JVM 层面的对象，每个 Java 对象都会关联一个 monitor。当线程获取 synchronized 锁时，本质是获取对象关联的 monitor 所有权，其核心属性是owner、entrylist、waitset。&lt;/li&gt;
&lt;li&gt;owner关联当前持有锁的线程（同一时刻仅一个线程可持有）。&lt;/li&gt;
&lt;li&gt;entrylist关联等待获取锁的线程队列（这些线程处于阻塞状态）。&lt;/li&gt;
&lt;li&gt;waitset关联的调用&lt;code&gt;wait()&lt;/code&gt;后进入等待状态的线程队列（需被&lt;code&gt;notify/notifyAll&lt;/code&gt;唤醒后才会进入 entryList）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;锁升级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了&lt;strong&gt;偏向锁&lt;/strong&gt;和&lt;strong&gt;轻量级锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;：在对象头的&lt;code&gt;Mark Word&lt;/code&gt;中记录获取锁的线程 ID，后续该线程再次获取锁时，只需判断 ID 是否在Mark Word，无需 CAS 操作。适用于锁长期被同一线程持有，无竞争的场景。当其他线程尝试获取锁时，偏向锁会被撤销，通过 CAS 竞争升级为轻量级锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;：通过CAS操作在当前线程栈帧中创建“锁记录（Lock Record）”，将&lt;code&gt;Mark Word&lt;/code&gt;复制到锁记录中，再尝试用CAS将&lt;code&gt;Mark Word&lt;/code&gt;替换为指向锁记录的指针：&lt;ul&gt;
&lt;li&gt;成功：获取轻量级锁，&lt;code&gt;Mark Word&lt;/code&gt;标志位为&lt;code&gt;00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;失败：进入“自旋优化”（线程不阻塞，循环尝试获取锁，避免内核态切换）。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自旋优化&lt;/strong&gt;：若自旋一定次数（默认10次）后仍失败，升级为重量级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;：底层使用的Monitor实现，Monitor依赖操作系统互斥量（Mutex）实现，所以也叫互斥锁，涉及到了用户态和内核态的切换，开销巨大，适用于锁竞争激烈或持有锁时间长的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;8-你谈谈JMM-Java内存模型）&#34;&gt;&lt;a href=&#34;#8-你谈谈JMM-Java内存模型）&#34; class=&#34;headerlink&#34; title=&#34;8. 你谈谈JMM(Java内存模型）&#34;&gt;&lt;/a&gt;8. 你谈谈JMM(Java内存模型）&lt;/h3&gt;&lt;p&gt;JMM（Java 内存模型）是 JVM 定义的&lt;strong&gt;共享内存中多线程读写操作规范&lt;/strong&gt;，保证指令正确性，它把内存分为主内存和本地内存。主内存公共区域存储共享变量，本地内存是线程私有存储共享变量的副本，线程间隔离，交互通过主内存。当某个线程更改了本地内存中共享变量的副本，jvm会写入主内存让所有线程可见。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;9-CAS-你知道吗&#34;&gt;&lt;a href=&#34;#9-CAS-你知道吗&#34; class=&#34;headerlink&#34; title=&#34;9. CAS 你知道吗&#34;&gt;&lt;/a&gt;9. CAS 你知道吗&lt;/h3&gt;&lt;p&gt;CAS的全称是：CompareAndSwap(比较再交换);它体现的一种&lt;strong&gt;乐观锁&lt;/strong&gt;的思想，在无锁状态下保证线程操作数据的&lt;strong&gt;原子性&lt;/strong&gt;。CAS使用到的地方很多：AQS框架、AtomicXXX类，在操作共享变量的时候使用的&lt;strong&gt;自旋锁&lt;/strong&gt;效率上更高一些，CAS的底层是调用的&lt;strong&gt;Unsafe类&lt;/strong&gt;中的本地方法由C&amp;#x2F;C++实现。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;10-乐观锁和悲观锁的区别？&#34;&gt;&lt;a href=&#34;#10-乐观锁和悲观锁的区别？&#34; class=&#34;headerlink&#34; title=&#34;10. 乐观锁和悲观锁的区别？&#34;&gt;&lt;/a&gt;10. 乐观锁和悲观锁的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;：操作数据时非常乐观，认为别的线程不会同时修改数据，因此不会上锁。通常在执行更新时，会判断在此期间数据是否被别人修改，若未修改则执行操作，否则放弃操作。主要实现方式有 CAS 机制和版本号机制，适用于&lt;strong&gt;竞争不激烈、读多写少&lt;/strong&gt;的场景，如 Java 中&lt;code&gt;AtomicInteger&lt;/code&gt;等原子类就运用了乐观锁思想。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;：操作数据时比较悲观，认为其他线程会同时修改数据，所以在操作数据前直接把数据锁住，直到操作完成后才释放锁，上锁期间其他线程不能修改数据。Java 中的&lt;code&gt;synchronized&lt;/code&gt;关键字和&lt;code&gt;ReentrantLock&lt;/code&gt;等都是悲观锁的实现，适合&lt;strong&gt;并发写入多、竞争激烈&lt;/strong&gt;的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;11-什么是AQS？&#34;&gt;&lt;a href=&#34;#11-什么是AQS？&#34; class=&#34;headerlink&#34; title=&#34;11. 什么是AQS？&#34;&gt;&lt;/a&gt;11. 什么是AQS？&lt;/h3&gt;&lt;p&gt;AQS 是一个抽象类，一个共享变量 state 和一个线程等待队列，为 ReentrantLock 等类提供底层支持。如果被请求的&lt;strong&gt;共享资源&lt;/strong&gt;处于空闲状态，当前线程就能成功&lt;strong&gt;获取锁&lt;/strong&gt;；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。&lt;/p&gt;
&lt;p&gt;AQS 的源码阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态 state 由 volatile 变量修饰，用于保证多线程之间的可见性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步队列&lt;/strong&gt;由内部定义的 Node 类实现，每个 Node 包含了等待状态、前后节点、线程的引用等，是一个先进先出的双向链表。&lt;/li&gt;
&lt;li&gt;AQS 支持两种同步方式：&lt;ul&gt;
&lt;li&gt;独占模式下：每次只能有一个线程持有锁，例如 ReentrantLock。&lt;/li&gt;
&lt;li&gt;共享模式下：多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;acquire ：获取锁，失败进入等待队列；&lt;/li&gt;
&lt;li&gt;release ：释放锁，唤醒等待队列中的线程；&lt;/li&gt;
&lt;li&gt;acquireShared ：共享模式获取锁&lt;/li&gt;
&lt;li&gt;releaseShared ：共享模式释放锁。&lt;/li&gt;
&lt;li&gt;AQS 使用一个 CLH 队列来维护等待线程，是一种基于链表的自旋锁。当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;12-ReentrantLock的实现原理&#34;&gt;&lt;a href=&#34;#12-ReentrantLock的实现原理&#34; class=&#34;headerlink&#34; title=&#34;12. ReentrantLock的实现原理&#34;&gt;&lt;/a&gt;12. ReentrantLock的实现原理&lt;/h3&gt;&lt;p&gt;ReentrantLock表示可重入锁，调用lock方法获取了锁之后，再次调用lock，是不会再阻塞。ReentrantLock主要利用CAS+AQS队列来实现，支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;13-synchronized-和-ReentrantLock-的区别&#34;&gt;&lt;a href=&#34;#13-synchronized-和-ReentrantLock-的区别&#34; class=&#34;headerlink&#34; title=&#34;13. synchronized 和 ReentrantLock 的区别&#34;&gt;&lt;/a&gt;13. synchronized 和 ReentrantLock 的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。&lt;/li&gt;
&lt;li&gt;ReentrantLock 可以实现多路选择通知，绑定多个 Condition，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；&lt;/li&gt;
&lt;li&gt;synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。&lt;/li&gt;
&lt;li&gt;并发量大的情况下，推荐使用 ReentrantLock，因为：&lt;ul&gt;
&lt;li&gt;提供了超时和公平锁等特性，可以应对更复杂的并发场景。&lt;/li&gt;
&lt;li&gt;允许更细粒度的锁控制，能有效减少锁竞争。&lt;/li&gt;
&lt;li&gt;支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;14-Lock-了解吗？&#34;&gt;&lt;a href=&#34;#14-Lock-了解吗？&#34; class=&#34;headerlink&#34; title=&#34;14. Lock 了解吗？&#34;&gt;&lt;/a&gt;14. Lock 了解吗？&lt;/h3&gt;&lt;p&gt;Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;15-ReentrantLock-的-lock-方法实现逻辑了解吗？&#34;&gt;&lt;a href=&#34;#15-ReentrantLock-的-lock-方法实现逻辑了解吗？&#34; class=&#34;headerlink&#34; title=&#34;15. ReentrantLock 的 lock() 方法实现逻辑了解吗？&#34;&gt;&lt;/a&gt;15. ReentrantLock 的 lock() 方法实现逻辑了解吗？&lt;/h3&gt;&lt;p&gt;lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS 的等待队列中。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;16-请谈谈你对volatile的理解&#34;&gt;&lt;a href=&#34;#16-请谈谈你对volatile的理解&#34; class=&#34;headerlink&#34; title=&#34;16. 请谈谈你对volatile的理解&#34;&gt;&lt;/a&gt;16. 请谈谈你对volatile的理解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JVM中的JIT即时编译器会对指令进行优化重排序，这可能导致一个线程对共享变量的修改其他线程不可见，用volatile修饰共享变量后，能够防止编译器等优化发生，保证共享变量的可见性。&lt;/li&gt;
&lt;li&gt;禁止进行指令重排序：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。&lt;/li&gt;
&lt;li&gt;volatile使用技巧：写变量让volatile修饰的变量的在代码最后位置，读变量让volatile修饰的变量的在代码最开始位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;17-聊一下ConcurrentHashMap-？（高频很重要）&#34;&gt;&lt;a href=&#34;#17-聊一下ConcurrentHashMap-？（高频很重要）&#34; class=&#34;headerlink&#34; title=&#34;17. 聊一下ConcurrentHashMap ？（高频很重要）&#34;&gt;&lt;/a&gt;17. 聊一下ConcurrentHashMap ？（高频很重要）&lt;/h3&gt;&lt;p&gt;ConcurrentHashMap 是 HashMap 的线程安全版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable，维护一个键值对数组HashEntry 它是一个单向链表。段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。&lt;/li&gt;
&lt;li&gt;JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。&lt;/li&gt;
&lt;li&gt;对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;JDK-7-中-ConcurrentHashMap-的-put-get-流程&#34;&gt;&lt;a href=&#34;#JDK-7-中-ConcurrentHashMap-的-put-get-流程&#34; class=&#34;headerlink&#34; title=&#34;JDK 7 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&#34;&gt;&lt;/a&gt;JDK 7 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;计算 key 的 hash，定位到段，段如果是空就先初始化；&lt;/li&gt;
&lt;li&gt;使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；&lt;/li&gt;
&lt;li&gt;遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。&lt;/li&gt;
&lt;li&gt;释放锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Get时先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。&lt;br&gt;get 不用加锁，因为 value 是 volatile 的，所以线程读取 value 时不会出现可见性问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;JDK-8-中-ConcurrentHashMap-的-put-get-流程&#34;&gt;&lt;a href=&#34;#JDK-8-中-ConcurrentHashMap-的-put-get-流程&#34; class=&#34;headerlink&#34; title=&#34;JDK 8 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&#34;&gt;&lt;/a&gt;JDK 8 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比 JDK 7 有了很大的提升。&lt;/li&gt;
&lt;li&gt;Put: 第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。插入的过程中会判断桶的哈希是否小于 0（f.hash &amp;gt;&amp;#x3D; 0），小于 0 说明是红黑树，大于等于 0 说明是链表。第三步，如果链表长度超过 8，转换为红黑树。第四步，在插入新节点后，会调用 addCount() 方法检查是否需要扩容。&lt;/li&gt;
&lt;li&gt;Get: get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用find方法查找。否则遍历链表查找匹配的键。如果都没找到，返回 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;项目中怎么使用-ConcurrentHashMap-的？&#34;&gt;&lt;a href=&#34;#项目中怎么使用-ConcurrentHashMap-的？&#34; class=&#34;headerlink&#34; title=&#34;项目中怎么使用 ConcurrentHashMap 的？&#34;&gt;&lt;/a&gt;项目中怎么使用 ConcurrentHashMap 的？&lt;/h4&gt;&lt;p&gt;在技术派实战项目中，用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用了 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;ConcurrentHashMap-怎么保证可见性？&#34;&gt;&lt;a href=&#34;#ConcurrentHashMap-怎么保证可见性？&#34; class=&#34;headerlink&#34; title=&#34;ConcurrentHashMap 怎么保证可见性？&#34;&gt;&lt;/a&gt;ConcurrentHashMap 怎么保证可见性？&lt;/h4&gt;&lt;p&gt;ConcurrentHashMap 中的 Node 节点中，value 和 next 都是 volatile 的，这样就可以保证对 value 或 next 的更新会被其他线程立即看到。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;为什么-ConcurrentHashMap-比-Hashtable-效率高？&#34;&gt;&lt;a href=&#34;#为什么-ConcurrentHashMap-比-Hashtable-效率高？&#34; class=&#34;headerlink&#34; title=&#34;为什么 ConcurrentHashMap 比 Hashtable 效率高？&#34;&gt;&lt;/a&gt;为什么 ConcurrentHashMap 比 Hashtable 效率高？&lt;/h4&gt;&lt;p&gt;Hashtable 在任何时刻只允许一个线程访问整个 Map，是通过对整个 Map 加锁来实现线程安全的。比如 get 和 put 方法，是直接在方法上加的 synchronized 关键字。而 ConcurrentHashMap 在 JDK 8 中是采用 CAS + synchronized 实现的，仅在必要时加锁。比如说 put 的时候优先使用 CAS 尝试插入，如果失败再使用 synchronized 代码块加锁。get 的时候是完全无锁的，因为 value 是 volatile 变量 修饰的，保证了内存可见性。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;CopyOnWriteArrayList-的实现原理&#34;&gt;&lt;a href=&#34;#CopyOnWriteArrayList-的实现原理&#34; class=&#34;headerlink&#34; title=&#34;CopyOnWriteArrayList 的实现原理&#34;&gt;&lt;/a&gt;CopyOnWriteArrayList 的实现原理&lt;/h4&gt;&lt;p&gt;CopyOnWriteArrayList 是 ArrayList 的线程安全版本，适用于读多写少的场景。它的核心思想是写操作时创建一个新数组，修改后再替换原数组，这样就能够确保读操作无锁，从而提高并发性能。内部使用 volatile 变量来修饰数组 array，以读操作的内存可见性。写操作的时候使用 ReentrantLock 来保证线程安全。缺点就是写操作的时候会复制一个新数组，如果数组很大，写操作的性能会受到影响。&lt;/p&gt;
&lt;h3 id=&#34;1-阻塞队列的实现方式？&#34;&gt;&lt;a href=&#34;#1-阻塞队列的实现方式？&#34; class=&#34;headerlink&#34; title=&#34;1. 阻塞队列的实现方式？&#34;&gt;&lt;/a&gt;1. 阻塞队列的实现方式？&lt;/h3&gt;&lt;p&gt;阻塞队列是多线程环境下常用的数据结构，支持阻塞式的插入和删除，当队列满时，生产者线程会被阻塞直到有空间；当队列空时，消费者线程会被阻塞直到有元素。这种特性使其非常适合实现生产者 - 消费者模式。主要实现方式有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 synchronized+wait&amp;#x2F;notify ，利用 Java 内置锁和 Object 类的等待机制。队列的 put 和 take 方法用 synchronized 修饰，当队列满时，生产者通过 wait () 进入等待状态；当队列空时，消费者同样 wait ()。操作完成后通过 notifyAll () 唤醒等待线程。优点是实现简单，缺点是功能单一，不支持公平性，且只有一个条件队列。&lt;/li&gt;
&lt;li&gt;基于 ReentrantLock+Condition 的实现。这是 JDK 标准库（如ArrayBlockingQueue）采用的方式，比 synchronized 更灵活。通过 ReentrantLock 保证线程安全，同时创建两个 Condition 对象（notEmpty 和 notFull）分别管理消费者和生产者的等待队列。当队列满时，生产者在 notFull 上 await ()；当队列空时，消费者在 notEmpty 上 await ()。操作完成后针对性地 signal () 对应条件队列的线程。这种方式支持公平锁配置，且能精确唤醒特定类型的线程。&lt;/li&gt;
&lt;li&gt;基于 CAS 操作的非阻塞实现。利用原子类（如 AtomicReference）通过 CAS 操作实现无锁化的并发控制，比如 ConcurrentLinkedQueue。通过循环重试的方式处理并发冲突，避免了线程阻塞和唤醒的开销，高并发场景下性能更好，但实现逻辑复杂，适合对性能要求极高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几种实现各有侧重：synchronized 方式适合简单场景；ReentrantLock+Condition 兼顾功能与性能，是 JDK 标准实现的首选；CAS 方式适合高并发低延迟的场景。实际开发中通常用 JDK 提供的阻塞队列（如 ArrayBlockingQueue、LinkedBlockingQueue），它们内部基于 ReentrantLock+Condition 实现，已经过充分优化和测试，能满足绝大多数并发场景的需求。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;开放性问题&#34;&gt;&lt;a href=&#34;#开放性问题&#34; class=&#34;headerlink&#34; title=&#34;开放性问题&#34;&gt;&lt;/a&gt;开放性问题&lt;/h2&gt;&lt;h3 id=&#34;1-先做个简单的自我介绍吧！&#34;&gt;&lt;a href=&#34;#1-先做个简单的自我介绍吧！&#34; class=&#34;headerlink&#34; title=&#34;1. 先做个简单的自我介绍吧！&#34;&gt;&lt;/a&gt;1. 先做个简单的自我介绍吧！&lt;/h3&gt;&lt;p&gt;面试官您好！我叫郝泽飞，是哈尔滨工程大学计算机专业的学生，现在在读研一，在校期间，我成绩专业排名前10%，大学期间参加了多个竞赛并取得奖项，通过了英语四六级。技术方面，大一期间我学习了计算机的基础知识，像数据结构，C++和JAVA的基础语法，大二以后开始学Java技术栈，比如Spring Boot、MyBatis-Plus、MySQL、Redis、RabbitMQ等，后来又做了一些项目，微服务架构的Pm-hub,大模型应用开发的派聪明。生活中我是一个比较积极乐观的人，我非常期待能在贵公司的开发岗位中，将所学的技术应用于实际业务，我的介绍完毕，谢谢！&lt;/p&gt;
&lt;h3 id=&#34;2-说说你的这个pm-hub项目吧？&#34;&gt;&lt;a href=&#34;#2-说说你的这个pm-hub项目吧？&#34; class=&#34;headerlink&#34; title=&#34;2. 说说你的这个pm-hub项目吧？&#34;&gt;&lt;/a&gt;2. 说说你的这个pm-hub项目吧？&lt;/h3&gt;&lt;p&gt;（项目背景、解决问题、职责任务。2项目使用的技术栈、技术架构、是否使用微服务，项目具体功能细节。技术具体实现细节。项目存在的问题和完善解决方案。项目具体功能的优化（如查询是在数据库中扫表查询吗）项目最有挑战的模块，如何解决，项目增大10倍的qps，如何设计？项目上线后出现频繁fullGc，怎么解决？）&lt;br&gt;好的，这个项目是我（跟室友&amp;#x2F;同学&amp;#x2F;老师一起做的。&amp;#x2F;参考开源项目做的一个二次开发），做这个项目是为了……，考虑到—所以项目中用到了***，当时我负责的部分是。发现速度&amp;#x2F;可用性不够，进行了SQL优化，分布式锁，seata事务,skywalking监控等。第二个项目是……，因为最近AI比较流行，我就想学一些新技术，跟上时代的步伐，这个项目是参考开源项目，用了……技术栈，实现了……功能，优化，解决……问题。以上是我的项目介绍。&lt;/p&gt;
&lt;h3 id=&#34;3-项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;a href=&#34;#3-项目中遇到最大的困难？怎么解决的？&#34; class=&#34;headerlink&#34; title=&#34;3. 项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;/a&gt;3. 项目中遇到最大的困难？怎么解决的？&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;4-平时是怎么学习的？&#34;&gt;&lt;a href=&#34;#4-平时是怎么学习的？&#34; class=&#34;headerlink&#34; title=&#34;4. 平时是怎么学习的？&#34;&gt;&lt;/a&gt;4. 平时是怎么学习的？&lt;/h3&gt;&lt;p&gt;比如我学一门新技术吧，首先看官方文档，如果晦涩难懂就会找教程&amp;#x2F;视频，还会使用AI工具（豆包，chatGPT）详细解释辅助理解，然后做个demo用到项目中，大学期间我大多是在开源社区学习还有网课。&lt;/p&gt;
&lt;h3 id=&#34;5-人生发展、最近五年职业规划&#34;&gt;&lt;a href=&#34;#5-人生发展、最近五年职业规划&#34; class=&#34;headerlink&#34; title=&#34;5. 人生发展、最近五年职业规划&#34;&gt;&lt;/a&gt;5. 人生发展、最近五年职业规划&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;6-什么时候能到岗？&#34;&gt;&lt;a href=&#34;#6-什么时候能到岗？&#34; class=&#34;headerlink&#34; title=&#34;6. 什么时候能到岗？&#34;&gt;&lt;/a&gt;6. 什么时候能到岗？&lt;/h3&gt;&lt;h3 id=&#34;7-薪资要求？&#34;&gt;&lt;a href=&#34;#7-薪资要求？&#34; class=&#34;headerlink&#34; title=&#34;7. 薪资要求？&#34;&gt;&lt;/a&gt;7. 薪资要求？&lt;/h3&gt;&lt;h2 id=&#34;反问：&#34;&gt;&lt;a href=&#34;#反问：&#34; class=&#34;headerlink&#34; title=&#34;反问：&#34;&gt;&lt;/a&gt;反问：&lt;/h2&gt;&lt;h3 id=&#34;一面&#34;&gt;&lt;a href=&#34;#一面&#34; class=&#34;headerlink&#34; title=&#34;一面&#34;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;部门主营业务和使用的技术栈是什么？&lt;/li&gt;
&lt;li&gt;您觉得我的专业能力有哪些需要提升的？&lt;/li&gt;
&lt;li&gt;刚才关于xx问题，我想问下您的思路。&lt;/li&gt;
&lt;li&gt;面试一般多久会出通知和结果呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二面&#34;&gt;&lt;a href=&#34;#二面&#34; class=&#34;headerlink&#34; title=&#34;二面&#34;&gt;&lt;/a&gt;二面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面试候选人，尤其是校招生的时候，最看重什么？&lt;/li&gt;
&lt;li&gt;您对进入您团队的成员的要求是什么？或者说需要怎样的品质胜任这个职位？&lt;/li&gt;
&lt;li&gt;我很好奇职位的晋升机制和发展路径。公司对信任的培养是怎么样的？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;HR面-三面&#34;&gt;&lt;a href=&#34;#HR面-三面&#34; class=&#34;headerlink&#34; title=&#34;HR面&amp;#x2F;三面&#34;&gt;&lt;/a&gt;HR面&amp;#x2F;三面&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;企业文化&lt;/li&gt;
&lt;li&gt;代表性产品&lt;/li&gt;
&lt;li&gt;历年薪资&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</guid>
            <title>ArrayList底层的实现原理是什么？</title>
            <link>http://example.com/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</link>
            <category>ArrayList</category>
            <category>实现原理</category>
            <pubDate>Sat, 19 Jul 2025 16:55:58 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;ArrayList底层是动态数组，支持自动扩容和高效随机访问。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;ArrayList底层是一个&lt;strong&gt;动态数组&lt;/strong&gt;，&lt;strong&gt;初始容量是0&lt;/strong&gt;，&lt;strong&gt;当第一次添加数据&lt;/strong&gt;才会初始化容量为10，&lt;strong&gt;扩容&lt;/strong&gt;是原来容量的1.5倍，每次扩容都需要&lt;strong&gt;拷贝数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;添加数据时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断元素个数size+1后是否大于总容量，如果大于就调用grow方法扩容，把旧数组拷贝到扩容后的新数组中，再把新元素放在size位置上，返回true。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ArrayList list&amp;#x3D;new ArrayList(10)中的list扩容几次?&lt;/strong&gt;&lt;br&gt;声明和实例了一个ArrayList，指定了容量为10，未扩容。构造方法中传参initCapcity,是多少就初始化多少容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现数组和List之间的转换？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组转List:           &lt;strong&gt;Arrays工具类的asList方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;List转数组，使用&lt;strong&gt;List的toArray方法&lt;/strong&gt;。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试官再问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Arrays.asList转List后，如果修改了数组内容，list受影响吗？&lt;/li&gt;
&lt;li&gt;List用toArray转数组后，如果修改了List内容，数组受影响吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数组转List受影响&lt;/strong&gt;，因为它的&lt;strong&gt;底层使用的Arrays类中的一个内部类ArrayList来构造的集合&lt;/strong&gt;，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，&lt;strong&gt;最终指向的都是同一个内存地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List转数组不受影响&lt;/strong&gt;，在底层是它是进行了数组的拷贝。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
            <title>HashSet，HashTable与HashMap的区别</title>
            <link>http://example.com/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
            <category>HashMap</category>
            <category>HashSet</category>
            <category>HashTable</category>
            <pubDate>Sat, 19 Jul 2025 16:55:48 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;对比HashSet、HashMap、HashTable三者的底层结构、线程安全性、常用方法及应用场景。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;数据结构上HashSet底层是一个HashMap，只存储键不存储值；HashMap是一个哈希表，由数组+链表+红黑树组成，存储键值对。HashSet不能重复，只允许一个null元素，实现了Set接口；HashMap键只有一个null值，值可以有多个，实现Map接口，它们性能一致。&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashSet：add, remove, contains, size&lt;/li&gt;
&lt;li&gt;HashMap: put(), get(), remove(), containsKey(), size()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HashTable 是 Java 早期的线程安全哈希表实现，因同步开销大、设计局限性（如不支持 null、扩容效率低），已逐渐被淘汰。HashMap 作为更现代的实现，性能更优、功能更灵活，而多线程场景下推荐使用 ConcurrentHashMap（分段锁优化，性能远超 HashTable）。&lt;/p&gt;
&lt;p&gt;你能自己设计实现一个 HashMap 吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，实现一个 hash 函数，对键的 hashCode 进行扰动&lt;/li&gt;
&lt;li&gt;第二步，实现一个拉链法的方法来解决哈希冲突&lt;/li&gt;
&lt;li&gt;第三步，扩容后，重新计算哈希值，将元素放到新的数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;讲讲 LinkedHashMap 怎么实现有序的？&lt;br&gt;在 HashMap 的基础上维护了一个双向链表，通过 before 和 after 标识前置节点和后置节点。从而实现插入和访问有序。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</guid>
            <title>HashMap 是线程安全的吗？</title>
            <link>http://example.com/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</link>
            <category>HashMap</category>
            <category>线程安全</category>
            <pubDate>Sat, 19 Jul 2025 16:55:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap 不是线程安全的，多线程环境下可能出现死循环、数据丢失等问题。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap 不是线程安全的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JDK7 中的 HashMap 使用的是&lt;strong&gt;头插法&lt;/strong&gt;来处理链表，在&lt;strong&gt;多线程环境下扩容会出现环形链表，造成死循环&lt;/strong&gt;。JDK 8 时通过&lt;strong&gt;尾插法修复&lt;/strong&gt;了这个问题，扩容时会保持链表原来的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程在进行 &lt;strong&gt;put 元素&lt;/strong&gt;的时候，&lt;strong&gt;可能会导致元素丢失&lt;/strong&gt;。因为put操作&lt;strong&gt;不是原子的&lt;/strong&gt;。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素&lt;strong&gt;先插入的元素被覆盖而丢失&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元&lt;strong&gt;素个数超出阈值而扩容&lt;/strong&gt;，线程 2 此时执行 get 就可能获取不到元素。线程 1 执行完 table &amp;#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引元素可能就 get 不到了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</guid>
            <title>HashMap的put方法的具体流程？</title>
            <link>http://example.com/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</link>
            <category>HashMap</category>
            <category>put方法</category>
            <pubDate>Sat, 19 Jul 2025 16:55:24 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;详细解析HashMap的put方法执行流程，包括哈希计算、索引定位、冲突处理、链表与红黑树转换等。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;&lt;strong&gt;第一步：检查数组是否为空&lt;/strong&gt;&lt;br&gt;首次&lt;code&gt;put&lt;/code&gt;时，调用&lt;code&gt;resize()&lt;/code&gt;初始化数组，默认容量为16，负载因子为0.75。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：计算键的哈希值&lt;/strong&gt;&lt;br&gt;具体是将键的hashCode异或hashCode右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：根据键的哈希值计算数组索引&lt;/strong&gt;&lt;br&gt;具体是将键的哈希值与上数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高，所以用与运算代替模运算，但前提是数组长度是2的N次幂）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：检查数组索引对应槽位的情况&lt;/strong&gt;&lt;br&gt;如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只重写元素的equals方法没重写hashCode，put的时候会发生什么？&lt;/strong&gt;&lt;br&gt;如果只重写equals方法，没有重写hashCode方法，那么会导致equals相等的两个对象，hashCode不相等，这样的话，两个对象会被put到数组中不同的位置，导致get的时候，无法获取到正确的值。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</guid>
            <title>HashMap实现原理？</title>
            <link>http://example.com/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</link>
            <category>实现原理</category>
            <category>HashMap</category>
            <pubDate>Sat, 19 Jul 2025 16:55:15 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前是数组+链表，之后是数组+链表+红黑树。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前，是数组+链表。之后是数组+链表+红黑树。&lt;/p&gt;
&lt;p&gt;存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果key相同，覆盖原值。&lt;/li&gt;
&lt;li&gt;key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。&lt;/p&gt;
&lt;p&gt;源码：初始容量16，加载因子0.75，扩容&amp;#x3D;之积。懒加载，不初始化容量。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid>
            <title>讲一讲HashMap的扩容机制</title>
            <link>http://example.com/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link>
            <category>HashMap</category>
            <category>扩容</category>
            <pubDate>Sat, 19 Jul 2025 16:28:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;HashMap 在元素个数超过阈值时会触发扩容（resize）操作，这个阈值是数组容量 * 负载因子。扩容的过程包括新数组创建和元素迁移。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;当哈希表中元素个数超过阈值时会触发扩容 resize 方法，这个阈值是 数组容量 * 负载因子，数组容量初始是16，负载因子默认是0.75。&lt;/p&gt;
&lt;p&gt;扩容时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建一个新数组&lt;/strong&gt;，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移元素&lt;/strong&gt;，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过 &lt;code&gt;e.hash &amp;amp; (newCap新容量 - 1)&lt;/code&gt; 计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为&lt;strong&gt;低位链&lt;/strong&gt;和&lt;strong&gt;高位链&lt;/strong&gt;，避免重新哈希带来性能损耗。如果 &lt;code&gt;e.hash &amp;amp; oldCap == 0&lt;/code&gt;（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种方式，HashMap 能够高效地完成扩容和数据迁移，保证查询和插入的性能。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2025/07/18/hello-world/</guid>
            <title>你好，世界</title>
            <link>http://example.com/2025/07/18/hello-world/</link>
            <category>Hexo</category>
            <category>博客</category>
            <pubDate>Fri, 18 Jul 2025 17:26:05 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;摘要：&lt;br&gt;欢迎使用 Hexo！这是你的第一篇博客文章。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;你好，欢迎来到我的个人博客！&lt;/p&gt;
&lt;p&gt;这是我用 Hexo 搭建的第一个博客页面。你可以在这里记录生活、学习、技术心得等内容。&lt;/p&gt;
&lt;p&gt;如果你遇到任何问题，可以查阅 Hexo 官方文档，或者在评论区留言交流。&lt;/p&gt;
&lt;p&gt;祝你写作愉快！&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/</guid>
            <title>LangChain4j实战教程-Java开发AI项目，太爽了！</title>
            <link>http://example.com/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/</link>
            <category>AI</category>
            <category>Java</category>
            <category>LangChain4j</category>
            <category>实战教程</category>
            <pubDate>Sun, 21 Jul 2024 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;原文链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvN2NOaDduZGVpV2lIQmpua1Rrel9aZw==&#34;&gt;https://mp.weixin.qq.com/s/7cNh7ndeiWiHBjnkTkz_Zg&lt;/span&gt;&lt;br&gt;大家好，我是程序员鱼皮。现在 AI 应用开发可以说是程序员必备的技能了，求职时能够大幅增加竞争力。之前我用 Spring AI 带大家做过一个开源的 AI 超级智能体项目，这次我来带大家快速掌握另一个主流的 Java AI 应用开发框架 LangChain4j。&lt;/p&gt;
&lt;p&gt;这个教程也是我精心设计，拒绝枯燥的理论，而是用一个编程小助手项目带大家在实战中依次学习 LangChain 几乎所有主流的用法和特性。看完这个教程，你不仅学会了 LangChain，还直接多了一段项目经历，岂不美哉？&lt;/p&gt;
&lt;p&gt;文章近一万字，有点长，建议收藏，观看视频版体验更佳~&lt;/p&gt;
&lt;p&gt;完整视频教程：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iaWxpYmlsaS5jb20vdmlkZW8vQlYxWDRHR3ppRXly&#34;&gt;https://bilibili.com/video/BV1X4GGziEyr&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;项目代码开源：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2xpeXVwaS9haS1jb2RlLWhlbHBlcg==&#34;&gt;https://github.com/liyupi/ai-code-helper&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;需求分析&#34;&gt;&lt;a href=&#34;#需求分析&#34; class=&#34;headerlink&#34; title=&#34;需求分析&#34;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;我们要实现一个 AI 编程小助手，可以帮助用户答疑解惑，并且给出编程学习的指导建议，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编程学习路线&lt;/li&gt;
&lt;li&gt;项目学习建议&lt;/li&gt;
&lt;li&gt;程序员求职指南&lt;/li&gt;
&lt;li&gt;程序员常见面试题&lt;/li&gt;
&lt;/ul&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQtvia8yfz6ukkFwsZHhnHfnV7ia4LnanElUoS68nR5ichlZbHQyty9HVwQ/640?wx_fmt=png&amp;from=appmsg&amp;randomid=als75bj1&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;要实现这个需求，我们首先要能够调用 AI 完成基础对话，而且要支持实现多轮对话记忆。此外，如果想进一步增强 AI 的能力，需要让它能够使用工具来联网搜索内容；还可以让 AI 基于我们自己的知识库回答，给用户提供我们在编程领域沉淀的资源和经验。&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQel4e7wMeljibTCub9ELadNwqIHHMDvxglnibHhEZNThZqXcNTaYHXMPg/640?wx_fmt=png&amp;from=appmsg&amp;randomid=7m9qg0cr&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;如果要从 0 开始实现上述功能，还是很麻烦的，因此我们要使用 AI 开发框架来提高效率。&lt;/p&gt;
&lt;h2 id=&#34;什么是-LangChain4j？&#34;&gt;&lt;a href=&#34;#什么是-LangChain4j？&#34; class=&#34;headerlink&#34; title=&#34;什么是 LangChain4j？&#34;&gt;&lt;/a&gt;什么是 LangChain4j？&lt;/h2&gt;&lt;p&gt;目前主流的 Java AI 开发框架有 Spring AI 和 LangChain4j，它们都提供了很多开箱即用的 API 来帮你调用大模型、实现 AI 开发常用的功能，比如我们今天要学的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对话记忆&lt;/li&gt;
&lt;li&gt;结构化输出&lt;/li&gt;
&lt;li&gt;RAG 知识库&lt;/li&gt;
&lt;li&gt;工具调用&lt;/li&gt;
&lt;li&gt;MCP&lt;/li&gt;
&lt;li&gt;SSE 流式输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就我个人体验下来，这两个框架的很多概念和用法都是类似的，也都提供了很多插件扩展，都支持和 Spring Boot 项目集成。虽然有一些编码上的区别，但孰好孰坏，使用感受也是因人而异的。&lt;/p&gt;
&lt;p&gt;实际开发中应该如何选择呢？&lt;/p&gt;
&lt;p&gt;我想先带你用 LangChain4j 开发完一个项目，最后再揭晓答案，因为那个时候你自己也会有一些想法。&lt;/p&gt;
&lt;h2 id=&#34;AI-应用开发&#34;&gt;&lt;a href=&#34;#AI-应用开发&#34; class=&#34;headerlink&#34; title=&#34;AI 应用开发&#34;&gt;&lt;/a&gt;AI 应用开发&lt;/h2&gt;&lt;h3 id=&#34;新建项目&#34;&gt;&lt;a href=&#34;#新建项目&#34; class=&#34;headerlink&#34; title=&#34;新建项目&#34;&gt;&lt;/a&gt;新建项目&lt;/h3&gt;&lt;p&gt;打开 IDEA 开发工具，新建一个 Spring Boot 项目，Java 版本选择 21（因为 LangChain4j 最低支持 17 版本）：&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQycl5RYAlTBorwbTI3PlIicqz4qgYAfF5VA8ZD6OqdOQfaqPsxMgr9ag/640?wx_fmt=png&amp;from=appmsg&amp;randomid=cdah2fh9&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;选择依赖，使用 3.5.x 版本的 Spring Boot，引入 Spring MVC 和 Lombok 注解库：&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQduuBrs4ibuHF2kGDvHeJjOYtYAFt8OyjpYjChNIGq6MRPe1AtrNprAg/640?wx_fmt=png&amp;from=appmsg&amp;randomid=g2rzqtq4&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;新建项目后，先修改配置文件后缀为 yml，便于后面填写配置。&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQibWyATuY1jEMNX4NBNtXws0s68icNdRQM6w7ZdiaBuUXDuyVoclxAP6Fw/640?wx_fmt=png&amp;from=appmsg&amp;randomid=8glbb5o8&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;这里我会建议大家创建一个 application-local.yml 配置文件，将开发时用到的敏感配置写到这里，并且添加到 .gitignore 中，防止不小心开源出来。&lt;/p&gt;
&lt;h2 id=&#34;AI-对话-ChatModel&#34;&gt;&lt;a href=&#34;#AI-对话-ChatModel&#34; class=&#34;headerlink&#34; title=&#34;AI 对话 - ChatModel&#34;&gt;&lt;/a&gt;AI 对话 - ChatModel&lt;/h2&gt;&lt;p&gt;ChatModel 是最基础的概念，负责和 AI 大模型交互。&lt;/p&gt;
&lt;p&gt;首先需要引入至少一个 AI 大模型依赖，这里选择国内的阿里云大模型，提供了和 Spring Boot 项目的整合依赖包，比较方便：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;dev.langchain4j&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;langchain4j-community-dashscope-spring-boot-starter&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.1.0-beta7&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;需要到 阿里云百炼平台 获取大模型调用 key，注意不要泄露！&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQibTrFMyk56ic6p3qg6aCicKD6l5XeCMKIv8edXQ3omDEtyCplkCWXcfeQ/640?wx_fmt=png&amp;from=appmsg&amp;randomid=4t4d3x7n&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;回到项目，在配置文件中添加大模型配置，指定模型名称和 API Key：&lt;/p&gt;
&lt;figure class=&#34;highlight yaml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;langchain4j:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;community:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;dashscope:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;chat-model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;model-name:&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;qwen-max&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;api-key:&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;You&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;API&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;Key&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;here&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以按需选择模型名称，追求效果可以用 qwen-max，否则可以选择效果、速度、成本均衡的 qwen-plus。&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQenuXgWvZOMQtpdquOdUJyyLASN2NkhUqk30Ozngn9SEmdUvFQxdbRg/640?wx_fmt=png&amp;from=appmsg&amp;randomid=8ac4s7h5&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;除了编写配置让 Spring Boot 自动构建 ChatModel 外，也可以通过构造器自己创建 ChatModel 对象。这种方式更灵活，在 LangChain4j 中我们会经常用到这种方式来构造对象。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;ChatModel&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;qwenModel&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; QwenChatModel.builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .apiKey(&lt;span class=&#34;string&#34;&gt;&amp;quot;You API key here&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .modelName(&lt;span class=&#34;string&#34;&gt;&amp;quot;qwen-max&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .enableSearch(&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .temperature(&lt;span class=&#34;number&#34;&gt;0.7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .maxTokens(&lt;span class=&#34;number&#34;&gt;4096&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .stops(List.of(&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有了 ChatModel 后，创建一个 AiCodeHelper 类，引入自动注入的 qwenChatModel，编写简单的对话代码，并利用 Lombok 注解打印输出结果日志：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AiCodeHelper&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; ChatModel qwenChatModel;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;chat&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String message)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;UserMessage&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;userMessage&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; UserMessage.from(message);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ChatResponse&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;chatResponse&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; qwenChatModel.chat(userMessage);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;AiMessage&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;aiMessage&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; chatResponse.aiMessage();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        log.info(&lt;span class=&#34;string&#34;&gt;&amp;quot;AI 输出：&amp;quot;&lt;/span&gt; + aiMessage.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; aiMessage.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编写单元测试，向 AI 打个招呼吧：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@SpringBootTest&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AiCodeHelperTest&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; AiCodeHelper aiCodeHelper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;chat&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        aiCodeHelper.chat(&lt;span class=&#34;string&#34;&gt;&amp;quot;你好，我是程序员鱼皮&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以 Debug 模式运行单元测试，成功运行并查看输出：&lt;/p&gt;
&lt;!-- 省略后续内容，继续按上述格式处理全文 --&gt;  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/07/21/%E7%89%9B%E5%AE%A2%E7%A5%9E%E5%93%81%E5%85%AB%E8%82%A1/</guid>
            <title>神品八股-付费14元</title>
            <link>http://example.com/2024/07/21/%E7%89%9B%E5%AE%A2%E7%A5%9E%E5%93%81%E5%85%AB%E8%82%A1/</link>
            <category>八股</category>
            <category>牛客</category>
            <pubDate>Sun, 21 Jul 2024 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2lzc3VlL3R1dG9yaWFsP3podWFubGFuSWQ9TVE3NW5CJnV1aWQ9NzVhM2Y1ZGEwODZmNDE3ODk3YTg0NjdlZjY2ZGRlYjQ=&#34;&gt;https://www.nowcoder.com/issue/tutorial?zhuanlanId=MQ75nB&amp;amp;uuid=75a3f5da086f417897a8467ef66ddeb4&lt;/span&gt;&lt;br&gt;面经陪练：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djNTI5MDY1L2FydGljbGUvZGV0YWlscy8xNDg3NjAzMDY=&#34;&gt;https://blog.csdn.net/wc529065/article/details/148760306&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;京东 后端开发 暑期实习一面面经&lt;br&gt;Java集合&lt;br&gt;别用互联网思维写国企简历，这些模块要调整😧&lt;br&gt;Java SE&lt;br&gt;神品八股 | 专栏简介 | 基于1759篇面经、24139道八股题，精准提炼真实高频八股&lt;br&gt;JUC&lt;br&gt;JVM&lt;br&gt;Spring&lt;br&gt;MySQL&lt;br&gt;Redis&lt;br&gt;RabbitMQ&lt;br&gt;操作系统&lt;br&gt;计算机网络&lt;br&gt;设计模式 &lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/07/21/%E5%AD%A6%E4%B9%A0%E7%89%88%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/</guid>
            <title>学习版游戏网站</title>
            <link>http://example.com/2024/07/21/%E5%AD%A6%E4%B9%A0%E7%89%88%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/</link>
            <category>游戏</category>
            <category>Steam</category>
            <pubDate>Sun, 21 Jul 2024 12:00:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;以下均为电脑游戏&lt;/p&gt;
&lt;p&gt;gamebox：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9meTZiLmxhbnpvdXEuY29tL2lhTTQxMW9kODl3ZA==&#34;&gt;https://fy6b.lanzouq.com/iaM411od89wd&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;game520：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuZ2FtZXI1MjAuY29tLw==&#34;&gt;https://www.gamer520.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;GBT乐赏游戏空间：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2didGdhbWUueXNlcGFuLmNvbS8=&#34;&gt;http://gbtgame.ysepan.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;byrutor：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly90aGVieXJ1dC5vcmcv&#34;&gt;https://thebyrut.org/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;小叽游戏：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdGVhbXpnLmNvbS8=&#34;&gt;https://steamzg.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;wavse：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93YXZzZS5jb20v&#34;&gt;https://wavse.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意，网站内的广告切勿相信，直接忽略就好。以免造成不必要的损失！&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
