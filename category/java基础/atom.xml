<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://120115.xyz</id>
    <title>杰克飞的博客 • Posts by &#34;java基础&#34; category</title>
    <link href="https://120115.xyz" />
    <updated>2025-07-20T16:00:00.000Z</updated>
    <category term="ArrayList" />
    <category term="实现原理" />
    <category term="HashMap" />
    <category term="put方法" />
    <category term="Hexo" />
    <category term="博客" />
    <category term="线程安全" />
    <category term="AI" />
    <category term="Java" />
    <category term="LangChain4j" />
    <category term="实战教程" />
    <category term="HashSet" />
    <category term="HashTable" />
    <category term="八股" />
    <category term="牛客" />
    <category term="算法" />
    <category term="力扣" />
    <category term="LeetCode" />
    <category term="刷题" />
    <category term="游戏" />
    <category term="Steam" />
    <category term="扩容" />
    <entry>
        <id>https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
        <title>java高频面试题</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
        <content type="html">&lt;h2 id=&#34;JavaSE&#34;&gt;&lt;a href=&#34;#JavaSE&#34; class=&#34;headerlink&#34; title=&#34;JavaSE&#34;&gt;&lt;/a&gt;JavaSE&lt;/h2&gt;&lt;h3 id=&#34;1-什么是JAVA&#34;&gt;&lt;a href=&#34;#1-什么是JAVA&#34; class=&#34;headerlink&#34; title=&#34;1. 什么是JAVA?&#34;&gt;&lt;/a&gt;1. 什么是JAVA?&lt;/h3&gt;&lt;p&gt;Java 是一门面向对象的编程语言，吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。比较重要的特点就是跨平台性，只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。还有面向对象、多线程，JVM等这些让Java变得高效。Java最适合用来做后端开发，有很多成熟的技术栈，比如Springboot,springcloud等。&lt;/p&gt;
&lt;h3 id=&#34;2-Java-有哪些数据类型？&#34;&gt;&lt;a href=&#34;#2-Java-有哪些数据类型？&#34; class=&#34;headerlink&#34; title=&#34;2. Java 有哪些数据类型？&#34;&gt;&lt;/a&gt;2. Java 有哪些数据类型？&lt;/h3&gt;&lt;p&gt;基本数据类型和引用数据类型两大类。基本数据类型有：数值型（byte,short,int,long）、浮点型(float,double)、布尔型boolean。引用数据类型有类，数组和接口。&lt;/p&gt;
&lt;h3 id=&#34;3-面向对象编程有哪些特性？&#34;&gt;&lt;a href=&#34;#3-面向对象编程有哪些特性？&#34; class=&#34;headerlink&#34; title=&#34;3. 面向对象编程有哪些特性？&#34;&gt;&lt;/a&gt;3. 面向对象编程有哪些特性？&lt;/h3&gt;&lt;p&gt;封装、继承和多态。封装就是把一些属性和方法捆在一起形成一个类，我们可以实例化这个类变成对象，对象可以设置和获取属性，调用方法。开发中就是对象之间的交互。继承就是子类获得父类的所有属性和方法，子类还可以进行扩充或者方法重写。多态就是java运行时可以根据对象类型产生不同的结果。子类需要继承父类并重写父类方法，父类引用指向子类对象。&lt;/p&gt;
&lt;h3 id=&#34;4-抽象类和接口有什么区别？&#34;&gt;&lt;a href=&#34;#4-抽象类和接口有什么区别？&#34; class=&#34;headerlink&#34; title=&#34;4. 抽象类和接口有什么区别？&#34;&gt;&lt;/a&gt;4. 抽象类和接口有什么区别？&lt;/h3&gt;&lt;p&gt;一个类只能继承一个抽象类；但一个类可以实现多个接口。比如我们创建线程类的时候一般用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。抽象类符合 is-a 的关系，而接口更像是 has-a 的关系。比如说一个类可以序列化的时候，它只需要实现 Serializable 接口，代表它有这个功能，而不是继承一个序列化类。&lt;/p&gt;
&lt;h3 id=&#34;5-和-equals-的区别？&#34;&gt;&lt;a href=&#34;#5-和-equals-的区别？&#34; class=&#34;headerlink&#34; title=&#34;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&#34;&gt;&lt;/a&gt;5. &amp;#x3D;&amp;#x3D;和 equals 的区别？&lt;/h3&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D; 操作符和 equals() 方法用于比较两个对象：&amp;#x3D;&amp;#x3D;比较两个对象的引用，也就是说在内存中是不是同一份数据。对于基本数据类型（如 int, double, char 等），&amp;#x3D;&amp;#x3D; 比较的是值是否相等。equals比较的是两个对象的内容是否相等，默认跟&amp;#x3D;&amp;#x3D;相同，我们一般会对他重写来用于比较值（比如属性）是否相同而不是引用。&lt;/p&gt;
&lt;h3 id=&#34;6-为什么重写-equals-时必须重写-hashCode-⽅法？&#34;&gt;&lt;a href=&#34;#6-为什么重写-equals-时必须重写-hashCode-⽅法？&#34; class=&#34;headerlink&#34; title=&#34;6. 为什么重写 equals 时必须重写 hashCode ⽅法？&#34;&gt;&lt;/a&gt;6. 为什么重写 equals 时必须重写 hashCode ⽅法？&lt;/h3&gt;&lt;p&gt;因为基于哈希的集合类（如 HashMap）需要使用hashCode和equals方法来存储和查找对象。存储时首先根据键的hashCode计算出在数组中的存储位置，每个位置可以存单个值、链表和红黑树，如果没有重写hashCode方法，两个相同的键可能出现不同的hashCode导致它们被存在数组中的不同位置，获取时就发生错误。发生哈希冲突时，键会被存在数组的同一个桶中，通过链表和红黑树解决哈希冲突问题，发生哈希冲突的桶中元素的hashCode值相同，必须再用equals比较值才能找出对应元素，如果没有重写equals()方法就找不到需要的元素。&lt;/p&gt;
&lt;h3 id=&#34;7-String-和-StringBuilder、StringBuffer-的区别？&#34;&gt;&lt;a href=&#34;#7-String-和-StringBuilder、StringBuffer-的区别？&#34; class=&#34;headerlink&#34; title=&#34;7. String 和 StringBuilder、StringBuffer 的区别？&#34;&gt;&lt;/a&gt;7. String 和 StringBuilder、StringBuffer 的区别？&lt;/h3&gt;&lt;p&gt;它们都是用于处理字符串的，String底层用了final修饰是不可变的，每次修改都会创建一个新对象，开销很大，如果要频繁修改字符串可以用StringBuilder，它是在原对象上修改。StringBuffer跟StringBuilder相似，但是它的方法上都加了 synchronized 关键字，是线程安全的，这在单线程下效率比较低。&lt;/p&gt;
&lt;h3 id=&#34;8-Java-中异常处理体系&#34;&gt;&lt;a href=&#34;#8-Java-中异常处理体系&#34; class=&#34;headerlink&#34; title=&#34;8. Java 中异常处理体系?&#34;&gt;&lt;/a&gt;8. Java 中异常处理体系?&lt;/h3&gt;&lt;p&gt;主要有两大类，错误和异常，错误指的是程序无法处理的严重错误，比如内存溢出，栈溢出，这些错误通常与 JVM 的运行状态有关。异常分为编译时异常和运行时异常，编译时异常可以被try-catch捕获处理或者throws抛出，比如IOException、SQLException，运行时异常通常是代码逻辑错误，比如数组越界，空指针等。&lt;/p&gt;
&lt;h3 id=&#34;9-BIO、NIO、AIO-之间的区别？&#34;&gt;&lt;a href=&#34;#9-BIO、NIO、AIO-之间的区别？&#34; class=&#34;headerlink&#34; title=&#34;9. BIO、NIO、AIO 之间的区别？&#34;&gt;&lt;/a&gt;9. BIO、NIO、AIO 之间的区别？&lt;/h3&gt;&lt;p&gt;BIO：采用阻塞式 I&amp;#x2F;O 模型，基于字节流或字符流文件读写，基于 Socket 和 ServerSocket 进行网络通信，适用于连接数较少的场景，每个连接，都需要创建一个单独的线程来处理读写操作。&lt;br&gt;NIO：采用非阻塞 I&amp;#x2F;O 模型，线程在等待 I&amp;#x2F;O 时可执行其他任务，主要用在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，适用于连接数多但连接时间短的场景。&lt;br&gt;AIO：使用异步 I&amp;#x2F;O 模型，线程发起 I&amp;#x2F;O 请求后立即返回，不需要等待，当 I&amp;#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。&lt;/p&gt;
&lt;h3 id=&#34;10-🌟什么是反射？应用？原理？&#34;&gt;&lt;a href=&#34;#10-🌟什么是反射？应用？原理？&#34; class=&#34;headerlink&#34; title=&#34;10. 🌟什么是反射？应用？原理？&#34;&gt;&lt;/a&gt;10. 🌟什么是反射？应用？原理？&lt;/h3&gt;&lt;p&gt;反射就是在运行时动态地获取类的信息，然后使用它的属性和方法的技术。Spring 框架动态加载和管理 Bean、AOP的动态代理，还有Junit测试框架这些都用到了反射，我们可以用Class.forName通过类名获取一个类，然后调用newInstance方法创建实例对象，getMethod，invoke方法可以获取和调用方法，getDeclaredField可以获取属性，对于私有属性可以调用setAccessible(true); 让它可见。原理就是Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。&lt;/p&gt;
&lt;h2 id=&#34;Java集合&#34;&gt;&lt;a href=&#34;#Java集合&#34; class=&#34;headerlink&#34; title=&#34;Java集合&#34;&gt;&lt;/a&gt;Java集合&lt;/h2&gt;&lt;h3 id=&#34;1-常见集合有哪些？&#34;&gt;&lt;a href=&#34;#1-常见集合有哪些？&#34; class=&#34;headerlink&#34; title=&#34;1. 常见集合有哪些？&#34;&gt;&lt;/a&gt;1. 常见集合有哪些？&lt;/h3&gt;&lt;p&gt;集合有两大类，Collection 接口和Map 接口。Collection 接口下有List、Set,和Queue, List包含有序可重复的元素。实现类包括 ArrayList、LinkedList。Set是无序不重复的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。Queue是队列。实现类包括 PriorityQueue、ArrayDeque 等。Map 是表示键值对的集合。键不能重复。实现类包括 HashMap、LinkedHashMap、TreeMap 等。&lt;/p&gt;
&lt;h3 id=&#34;2-哪些是线程安全的容器？&#34;&gt;&lt;a href=&#34;#2-哪些是线程安全的容器？&#34; class=&#34;headerlink&#34; title=&#34;2. 哪些是线程安全的容器？&#34;&gt;&lt;/a&gt;2. 哪些是线程安全的容器？&lt;/h3&gt;&lt;p&gt;像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。&lt;/p&gt;
&lt;h3 id=&#34;3-ArrayList-和-LinkedList-有什么区别？&#34;&gt;&lt;a href=&#34;#3-ArrayList-和-LinkedList-有什么区别？&#34; class=&#34;headerlink&#34; title=&#34;3. ArrayList 和 LinkedList 有什么区别？&#34;&gt;&lt;/a&gt;3. ArrayList 和 LinkedList 有什么区别？&lt;/h3&gt;&lt;p&gt;ArrayList 底层是动态数组，内存是连续的，查找快，增删慢，适合经常通过索引访问，在末尾增删的场景，LinkedList 底层是双向链表，查找慢，增删快，适合频繁增删的场景。&lt;/p&gt;
&lt;h3 id=&#34;4-ArrayList-的扩容机制了解吗？底层实现？&#34;&gt;&lt;a href=&#34;#4-ArrayList-的扩容机制了解吗？底层实现？&#34; class=&#34;headerlink&#34; title=&#34;4. ArrayList 的扩容机制了解吗？底层实现？&#34;&gt;&lt;/a&gt;4. ArrayList 的扩容机制了解吗？底层实现？&lt;/h3&gt;&lt;p&gt;当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就调用grow方法生成一个1.5倍容量的新数组，然后拷贝元素到新数组中。&lt;/p&gt;
&lt;h3 id=&#34;5-ArrayList-怎么序列化的知道吗？&#34;&gt;&lt;a href=&#34;#5-ArrayList-怎么序列化的知道吗？&#34; class=&#34;headerlink&#34; title=&#34;5. ArrayList 怎么序列化的知道吗？&#34;&gt;&lt;/a&gt;5. ArrayList 怎么序列化的知道吗？&lt;/h3&gt;&lt;p&gt;它重写了writeObject 方法用于自定义序列化：只序列化有效数据，因为实际存储的元素数量一般小于elementData 数组的容量，声明的时候也加了 transient 关键字防止被默认序列化。&lt;/p&gt;
&lt;h3 id=&#34;6-HashMap实现原理？-高频&#34;&gt;&lt;a href=&#34;#6-HashMap实现原理？-高频&#34; class=&#34;headerlink&#34; title=&#34;6. HashMap实现原理？(高频)&#34;&gt;&lt;/a&gt;6. HashMap实现原理？(高频)&lt;/h3&gt;&lt;p&gt;JDK8之前是数组+链表。之后是数组+链表+红黑树。存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：如果key相同，覆盖原值。 key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。它的初始容量16，加载因子0.75。创建时使用懒加载，不初始化容量。&lt;/p&gt;
&lt;h3 id=&#34;7-HashMap的put方法的具体流程？-高频&#34;&gt;&lt;a href=&#34;#7-HashMap的put方法的具体流程？-高频&#34; class=&#34;headerlink&#34; title=&#34;7. HashMap的put方法的具体流程？(高频)&#34;&gt;&lt;/a&gt;7. HashMap的put方法的具体流程？(高频)&lt;/h3&gt;&lt;p&gt;第一步检查数组是否为空，首次put时，调用resize()初始化数组，默认容量为 16，负载因子为0.75。&lt;br&gt;第二步，计算键的哈希值，具体是将 键的hashCode 异或 hashCode 右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。&lt;br&gt;第三步，根据键的哈希值计算数组索引，具体是将键的哈希值 与上 数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高所以用与运算代替模运算，但前提是数组长度是2的N次幂）。&lt;br&gt;第四步，检查数组索引对应槽位的情况。如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。&lt;/p&gt;
&lt;p&gt;hashMap的寻址算法：扰动算法，通过hash方法，hashcode ^ hashcode &amp;lt;&amp;lt;&amp;lt; 16。&lt;br&gt;首先计算键的hashCode,再调用hash方法进行二次哈希，hashCode右移16位再和hashCode进行异或运算，减少哈希冲突，最后用哈希值 与 容量 -1 得到索引。&lt;/p&gt;
&lt;h3 id=&#34;8-讲一讲HashMap的扩容机制-高频&#34;&gt;&lt;a href=&#34;#8-讲一讲HashMap的扩容机制-高频&#34; class=&#34;headerlink&#34; title=&#34;8. 讲一讲HashMap的扩容机制(高频)&#34;&gt;&lt;/a&gt;8. 讲一讲HashMap的扩容机制(高频)&lt;/h3&gt;&lt;p&gt;当哈希表中元素个数超过阈值时会触发扩容resize方法，这个阈值是 数组容量 * 负载因子,数组容量初始是16，负载因子默认是0.75。&lt;br&gt;扩容时：&lt;br&gt;第一步，创建一个新数组，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。&lt;br&gt;第二步，迁移元素，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过e.hash &amp;amp; (newCap新容量 - 1)计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为低位链和高位链，避免重新哈希带来性能损耗，如果 e.hash &amp;amp; oldCap &amp;#x3D;&amp;#x3D; 0（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。&lt;/p&gt;
&lt;p&gt;为何HashMap的数组长度一定是2的次幂?&lt;br&gt;数组长度是 2 的幂次方时，hash % length和hash &amp;amp; (length - 1)的计算结果是一样的。不过按位与运算在性能上更具优势。计算索引时效率更高，扩容时效率更高。&lt;/p&gt;
&lt;h3 id=&#34;9-HashMap-是线程安全的吗？&#34;&gt;&lt;a href=&#34;#9-HashMap-是线程安全的吗？&#34; class=&#34;headerlink&#34; title=&#34;9. HashMap 是线程安全的吗？&#34;&gt;&lt;/a&gt;9. HashMap 是线程安全的吗？&lt;/h3&gt;&lt;p&gt;不是。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。多线程在进行 put 元素的时候，可能会导致元素丢失。因为put操作不是原子的。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素先插入的元素被覆盖而丢失put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get就可能获取不到元素。线程 1 执行完 table &amp;#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引 元素可能就 get 不到了。&lt;/p&gt;
&lt;h3 id=&#34;1-怎么解决HashMap线程不安全问题？&#34;&gt;&lt;a href=&#34;#1-怎么解决HashMap线程不安全问题？&#34; class=&#34;headerlink&#34; title=&#34;1. 怎么解决HashMap线程不安全问题？&#34;&gt;&lt;/a&gt;1. 怎么解决HashMap线程不安全问题？&lt;/h3&gt;&lt;p&gt;早期的 JDK 版本中，可以用 &lt;code&gt;Hashtable&lt;/code&gt; 来保证线程安全。&lt;code&gt;Hashtable&lt;/code&gt; 在方法上加了 &lt;code&gt;synchronized&lt;/code&gt; 关键字。但是它同步开销比较大、还不支持 null、扩容效率低，已经被淘汰。多线程场景下推荐使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;，它使用了分段锁优化，性能远超 &lt;code&gt;HashTable&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;并发与JUC高频面试题&#34;&gt;&lt;a href=&#34;#并发与JUC高频面试题&#34; class=&#34;headerlink&#34; title=&#34;并发与JUC高频面试题&#34;&gt;&lt;/a&gt;并发与JUC高频面试题&lt;/h2&gt;&lt;h3 id=&#34;2-进程和线程的区别？&#34;&gt;&lt;a href=&#34;#2-进程和线程的区别？&#34; class=&#34;headerlink&#34; title=&#34;2. 进程和线程的区别？&#34;&gt;&lt;/a&gt;2. 进程和线程的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：程序在操作系统中的一次执行，是系统进行资源分配和调度的基本单位，拥有独立内存空间和系统资源，进程间切换开销大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;：进程中的一个执行单元，是 CPU 调度的基本单位，共享所属进程的资源，线程间切换开销小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行&lt;/strong&gt;：多个任务同时执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发&lt;/strong&gt;：多个任务通过时间片轮转在一段时间内交替执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-线程创建的方式有哪些？&#34;&gt;&lt;a href=&#34;#3-线程创建的方式有哪些？&#34; class=&#34;headerlink&#34; title=&#34;3. 线程创建的方式有哪些？&#34;&gt;&lt;/a&gt;3. 线程创建的方式有哪些？&lt;/h3&gt;&lt;p&gt;有四种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口，线程池创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 继承 Thread 类&lt;/strong&gt;：需要重写父类 Thread 的 run() 方法，然后调用 start() 方法启动线程。缺点是，如果 ThreadTask 已经继承了另外一个类，就不能再继承 Thread 类了，因为 Java 不支持多重继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 实现 Runnable 接口&lt;/strong&gt;：重写 Runnable 接口的 run() 方法，然后把它作为参数传给 Thread类，最后调用 start() 方法启动线程。这种方式的优点是可以避免 Java 的单继承限制，缺点是没有返回值，拿不到线程执行结果并且不能抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现 Callable 接口&lt;/strong&gt;：重写 Callable 接口的 call() 方法，然后创建一个 CallableTask 对象，然后创建 FutureTask 对象，构造方法中以 CallableTask 实例传参；然后创建 Thread 对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;CallableTask&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;CallableTask&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;FutureTask&amp;lt;String&amp;gt; futureTask = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;FutureTask&lt;/span&gt;&amp;lt;&amp;gt;(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;thread&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(futureTask);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;thread.start();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;4. 线程池创建&lt;/strong&gt;：实现 Runnable 或 Callable 接口后，提交给线程池执行。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-线程包括哪些状态，状态之间是如何变化的？&#34;&gt;&lt;a href=&#34;#4-线程包括哪些状态，状态之间是如何变化的？&#34; class=&#34;headerlink&#34; title=&#34;4. 线程包括哪些状态，状态之间是如何变化的？&#34;&gt;&lt;/a&gt;4. 线程包括哪些状态，状态之间是如何变化的？&lt;/h3&gt;&lt;p&gt;Thread类中有一个枚举类State，一共6种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建(NEW)&lt;/li&gt;
&lt;li&gt;可运行(RUNNABLE)&lt;/li&gt;
&lt;li&gt;阻塞(BLOCKED)&lt;/li&gt;
&lt;li&gt;等待（WAITING）&lt;/li&gt;
&lt;li&gt;时间等待(TIMED_WAITING)&lt;/li&gt;
&lt;li&gt;终止(TERMINATED)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建线程对象是新建状态&lt;/li&gt;
&lt;li&gt;调用了start()方法转变为可执行状态&lt;/li&gt;
&lt;li&gt;线程获取到了CPU的执行权，执行结束是终止状态&lt;/li&gt;
&lt;li&gt;在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态&lt;/li&gt;
&lt;li&gt;如果没有获取锁(synchronized或lock)进入阻塞状态，获得锁再切换为可执行状态&lt;/li&gt;
&lt;li&gt;如果线程调用了wait()方法进入等待状态，其他线程调用notify(唤醒后可切换为可执行状态)&lt;/li&gt;
&lt;li&gt;如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;5-在java中wait和sleep方法的不同&#34;&gt;&lt;a href=&#34;#5-在java中wait和sleep方法的不同&#34; class=&#34;headerlink&#34; title=&#34;5. 在java中wait和sleep方法的不同&#34;&gt;&lt;/a&gt;5. 在java中wait和sleep方法的不同&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;都能让线程进入阻塞状态，并且都可以传一个时间参数等待相应毫秒数醒来，也都能被打断唤醒。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sleep方法&lt;/strong&gt;是Thread类的静态方法，而&lt;strong&gt;wait方法&lt;/strong&gt;是Object类的成员方法。&lt;/li&gt;
&lt;li&gt;wait方法可以被notify方法唤醒，如果没传时间参数也没被唤醒就一直等待。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁不同&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;wait方法的调用必须先获取wait对象的锁，wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu，但你们还可以用）。&lt;/li&gt;
&lt;li&gt;sleep调用不用获取锁，sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;6-如何停止一个正在运行的线程&#34;&gt;&lt;a href=&#34;#6-如何停止一个正在运行的线程&#34; class=&#34;headerlink&#34; title=&#34;6. 如何停止一个正在运行的线程&#34;&gt;&lt;/a&gt;6. 如何停止一个正在运行的线程&lt;/h3&gt;&lt;p&gt;三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用退出标志&lt;/strong&gt;，使线程正常退出，也就是当run方法完成后线程终止。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;stop方法强行终止&lt;/strong&gt;（不推荐，方法已作废）。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;interrupt方法&lt;/strong&gt;中断线程。&lt;ul&gt;
&lt;li&gt;打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常。&lt;/li&gt;
&lt;li&gt;打断正常的线程，可以根据打断状态来标记是否退出线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;7-线程中并发安全（高频，难答）&#34;&gt;&lt;a href=&#34;#7-线程中并发安全（高频，难答）&#34; class=&#34;headerlink&#34; title=&#34;7. 线程中并发安全（高频，难答）&#34;&gt;&lt;/a&gt;7. 线程中并发安全（高频，难答）&lt;/h3&gt;&lt;h4 id=&#34;synchronized关键字的底层原理&#34;&gt;&lt;a href=&#34;#synchronized关键字的底层原理&#34; class=&#34;headerlink&#34; title=&#34;synchronized关键字的底层原理&#34;&gt;&lt;/a&gt;synchronized关键字的底层原理&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在jdk1.6之前，&lt;code&gt;synchronized&lt;/code&gt;被称为&lt;strong&gt;重量级锁&lt;/strong&gt;。底层核心是&lt;strong&gt;monitor（监视器）&lt;/strong&gt;，它是 JVM 层面的对象，每个 Java 对象都会关联一个 monitor。当线程获取 synchronized 锁时，本质是获取对象关联的 monitor 所有权，其核心属性是owner、entrylist、waitset。&lt;/li&gt;
&lt;li&gt;owner关联当前持有锁的线程（同一时刻仅一个线程可持有）。&lt;/li&gt;
&lt;li&gt;entrylist关联等待获取锁的线程队列（这些线程处于阻塞状态）。&lt;/li&gt;
&lt;li&gt;waitset关联的调用&lt;code&gt;wait()&lt;/code&gt;后进入等待状态的线程队列（需被&lt;code&gt;notify/notifyAll&lt;/code&gt;唤醒后才会进入 entryList）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;锁升级：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了&lt;strong&gt;偏向锁&lt;/strong&gt;和&lt;strong&gt;轻量级锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;：在对象头的&lt;code&gt;Mark Word&lt;/code&gt;中记录获取锁的线程 ID，后续该线程再次获取锁时，只需判断 ID 是否在Mark Word，无需 CAS 操作。适用于锁长期被同一线程持有，无竞争的场景。当其他线程尝试获取锁时，偏向锁会被撤销，通过 CAS 竞争升级为轻量级锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;：通过CAS操作在当前线程栈帧中创建“锁记录（Lock Record）”，将&lt;code&gt;Mark Word&lt;/code&gt;复制到锁记录中，再尝试用CAS将&lt;code&gt;Mark Word&lt;/code&gt;替换为指向锁记录的指针：&lt;ul&gt;
&lt;li&gt;成功：获取轻量级锁，&lt;code&gt;Mark Word&lt;/code&gt;标志位为&lt;code&gt;00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;失败：进入“自旋优化”（线程不阻塞，循环尝试获取锁，避免内核态切换）。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自旋优化&lt;/strong&gt;：若自旋一定次数（默认10次）后仍失败，升级为重量级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;：底层使用的Monitor实现，Monitor依赖操作系统互斥量（Mutex）实现，所以也叫互斥锁，涉及到了用户态和内核态的切换，开销巨大，适用于锁竞争激烈或持有锁时间长的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;8-你谈谈JMM-Java内存模型）&#34;&gt;&lt;a href=&#34;#8-你谈谈JMM-Java内存模型）&#34; class=&#34;headerlink&#34; title=&#34;8. 你谈谈JMM(Java内存模型）&#34;&gt;&lt;/a&gt;8. 你谈谈JMM(Java内存模型）&lt;/h3&gt;&lt;p&gt;JMM（Java 内存模型）是 JVM 定义的&lt;strong&gt;共享内存中多线程读写操作规范&lt;/strong&gt;，保证指令正确性，它把内存分为主内存和本地内存。主内存公共区域存储共享变量，本地内存是线程私有存储共享变量的副本，线程间隔离，交互通过主内存。当某个线程更改了本地内存中共享变量的副本，jvm会写入主内存让所有线程可见。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;9-CAS-你知道吗&#34;&gt;&lt;a href=&#34;#9-CAS-你知道吗&#34; class=&#34;headerlink&#34; title=&#34;9. CAS 你知道吗&#34;&gt;&lt;/a&gt;9. CAS 你知道吗&lt;/h3&gt;&lt;p&gt;CAS的全称是：CompareAndSwap(比较再交换);它体现的一种&lt;strong&gt;乐观锁&lt;/strong&gt;的思想，在无锁状态下保证线程操作数据的&lt;strong&gt;原子性&lt;/strong&gt;。CAS使用到的地方很多：AQS框架、AtomicXXX类，在操作共享变量的时候使用的&lt;strong&gt;自旋锁&lt;/strong&gt;效率上更高一些，CAS的底层是调用的&lt;strong&gt;Unsafe类&lt;/strong&gt;中的本地方法由C&amp;#x2F;C++实现。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;10-乐观锁和悲观锁的区别？&#34;&gt;&lt;a href=&#34;#10-乐观锁和悲观锁的区别？&#34; class=&#34;headerlink&#34; title=&#34;10. 乐观锁和悲观锁的区别？&#34;&gt;&lt;/a&gt;10. 乐观锁和悲观锁的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;：操作数据时非常乐观，认为别的线程不会同时修改数据，因此不会上锁。通常在执行更新时，会判断在此期间数据是否被别人修改，若未修改则执行操作，否则放弃操作。主要实现方式有 CAS 机制和版本号机制，适用于&lt;strong&gt;竞争不激烈、读多写少&lt;/strong&gt;的场景，如 Java 中&lt;code&gt;AtomicInteger&lt;/code&gt;等原子类就运用了乐观锁思想。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;：操作数据时比较悲观，认为其他线程会同时修改数据，所以在操作数据前直接把数据锁住，直到操作完成后才释放锁，上锁期间其他线程不能修改数据。Java 中的&lt;code&gt;synchronized&lt;/code&gt;关键字和&lt;code&gt;ReentrantLock&lt;/code&gt;等都是悲观锁的实现，适合&lt;strong&gt;并发写入多、竞争激烈&lt;/strong&gt;的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;11-什么是AQS？&#34;&gt;&lt;a href=&#34;#11-什么是AQS？&#34; class=&#34;headerlink&#34; title=&#34;11. 什么是AQS？&#34;&gt;&lt;/a&gt;11. 什么是AQS？&lt;/h3&gt;&lt;p&gt;AQS 是一个抽象类，一个共享变量 state 和一个线程等待队列，为 ReentrantLock 等类提供底层支持。如果被请求的&lt;strong&gt;共享资源&lt;/strong&gt;处于空闲状态，当前线程就能成功&lt;strong&gt;获取锁&lt;/strong&gt;；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。&lt;/p&gt;
&lt;p&gt;AQS 的源码阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态 state 由 volatile 变量修饰，用于保证多线程之间的可见性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步队列&lt;/strong&gt;由内部定义的 Node 类实现，每个 Node 包含了等待状态、前后节点、线程的引用等，是一个先进先出的双向链表。&lt;/li&gt;
&lt;li&gt;AQS 支持两种同步方式：&lt;ul&gt;
&lt;li&gt;独占模式下：每次只能有一个线程持有锁，例如 ReentrantLock。&lt;/li&gt;
&lt;li&gt;共享模式下：多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;acquire ：获取锁，失败进入等待队列；&lt;/li&gt;
&lt;li&gt;release ：释放锁，唤醒等待队列中的线程；&lt;/li&gt;
&lt;li&gt;acquireShared ：共享模式获取锁&lt;/li&gt;
&lt;li&gt;releaseShared ：共享模式释放锁。&lt;/li&gt;
&lt;li&gt;AQS 使用一个 CLH 队列来维护等待线程，是一种基于链表的自旋锁。当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;12-ReentrantLock的实现原理&#34;&gt;&lt;a href=&#34;#12-ReentrantLock的实现原理&#34; class=&#34;headerlink&#34; title=&#34;12. ReentrantLock的实现原理&#34;&gt;&lt;/a&gt;12. ReentrantLock的实现原理&lt;/h3&gt;&lt;p&gt;ReentrantLock表示可重入锁，调用lock方法获取了锁之后，再次调用lock，是不会再阻塞。ReentrantLock主要利用CAS+AQS队列来实现，支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;13-synchronized-和-ReentrantLock-的区别&#34;&gt;&lt;a href=&#34;#13-synchronized-和-ReentrantLock-的区别&#34; class=&#34;headerlink&#34; title=&#34;13. synchronized 和 ReentrantLock 的区别&#34;&gt;&lt;/a&gt;13. synchronized 和 ReentrantLock 的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。&lt;/li&gt;
&lt;li&gt;ReentrantLock 可以实现多路选择通知，绑定多个 Condition，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；&lt;/li&gt;
&lt;li&gt;synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。&lt;/li&gt;
&lt;li&gt;并发量大的情况下，推荐使用 ReentrantLock，因为：&lt;ul&gt;
&lt;li&gt;提供了超时和公平锁等特性，可以应对更复杂的并发场景。&lt;/li&gt;
&lt;li&gt;允许更细粒度的锁控制，能有效减少锁竞争。&lt;/li&gt;
&lt;li&gt;支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;14-Lock-了解吗？&#34;&gt;&lt;a href=&#34;#14-Lock-了解吗？&#34; class=&#34;headerlink&#34; title=&#34;14. Lock 了解吗？&#34;&gt;&lt;/a&gt;14. Lock 了解吗？&lt;/h3&gt;&lt;p&gt;Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;15-ReentrantLock-的-lock-方法实现逻辑了解吗？&#34;&gt;&lt;a href=&#34;#15-ReentrantLock-的-lock-方法实现逻辑了解吗？&#34; class=&#34;headerlink&#34; title=&#34;15. ReentrantLock 的 lock() 方法实现逻辑了解吗？&#34;&gt;&lt;/a&gt;15. ReentrantLock 的 lock() 方法实现逻辑了解吗？&lt;/h3&gt;&lt;p&gt;lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS 的等待队列中。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;16-请谈谈你对volatile的理解&#34;&gt;&lt;a href=&#34;#16-请谈谈你对volatile的理解&#34; class=&#34;headerlink&#34; title=&#34;16. 请谈谈你对volatile的理解&#34;&gt;&lt;/a&gt;16. 请谈谈你对volatile的理解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JVM中的JIT即时编译器会对指令进行优化重排序，这可能导致一个线程对共享变量的修改其他线程不可见，用volatile修饰共享变量后，能够防止编译器等优化发生，保证共享变量的可见性。&lt;/li&gt;
&lt;li&gt;禁止进行指令重排序：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。&lt;/li&gt;
&lt;li&gt;volatile使用技巧：写变量让volatile修饰的变量的在代码最后位置，读变量让volatile修饰的变量的在代码最开始位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;17-聊一下ConcurrentHashMap-？（高频很重要）&#34;&gt;&lt;a href=&#34;#17-聊一下ConcurrentHashMap-？（高频很重要）&#34; class=&#34;headerlink&#34; title=&#34;17. 聊一下ConcurrentHashMap ？（高频很重要）&#34;&gt;&lt;/a&gt;17. 聊一下ConcurrentHashMap ？（高频很重要）&lt;/h3&gt;&lt;p&gt;ConcurrentHashMap 是 HashMap 的线程安全版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable，维护一个键值对数组HashEntry 它是一个单向链表。段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。&lt;/li&gt;
&lt;li&gt;JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。&lt;/li&gt;
&lt;li&gt;对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;JDK-7-中-ConcurrentHashMap-的-put-get-流程&#34;&gt;&lt;a href=&#34;#JDK-7-中-ConcurrentHashMap-的-put-get-流程&#34; class=&#34;headerlink&#34; title=&#34;JDK 7 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&#34;&gt;&lt;/a&gt;JDK 7 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;计算 key 的 hash，定位到段，段如果是空就先初始化；&lt;/li&gt;
&lt;li&gt;使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；&lt;/li&gt;
&lt;li&gt;遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。&lt;/li&gt;
&lt;li&gt;释放锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Get时先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。&lt;br&gt;get 不用加锁，因为 value 是 volatile 的，所以线程读取 value 时不会出现可见性问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;JDK-8-中-ConcurrentHashMap-的-put-get-流程&#34;&gt;&lt;a href=&#34;#JDK-8-中-ConcurrentHashMap-的-put-get-流程&#34; class=&#34;headerlink&#34; title=&#34;JDK 8 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&#34;&gt;&lt;/a&gt;JDK 8 中 ConcurrentHashMap 的 put&amp;#x2F;get 流程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比 JDK 7 有了很大的提升。&lt;/li&gt;
&lt;li&gt;Put: 第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。插入的过程中会判断桶的哈希是否小于 0（f.hash &amp;gt;&amp;#x3D; 0），小于 0 说明是红黑树，大于等于 0 说明是链表。第三步，如果链表长度超过 8，转换为红黑树。第四步，在插入新节点后，会调用 addCount() 方法检查是否需要扩容。&lt;/li&gt;
&lt;li&gt;Get: get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用find方法查找。否则遍历链表查找匹配的键。如果都没找到，返回 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;项目中怎么使用-ConcurrentHashMap-的？&#34;&gt;&lt;a href=&#34;#项目中怎么使用-ConcurrentHashMap-的？&#34; class=&#34;headerlink&#34; title=&#34;项目中怎么使用 ConcurrentHashMap 的？&#34;&gt;&lt;/a&gt;项目中怎么使用 ConcurrentHashMap 的？&lt;/h4&gt;&lt;p&gt;在技术派实战项目中，用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用了 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;ConcurrentHashMap-怎么保证可见性？&#34;&gt;&lt;a href=&#34;#ConcurrentHashMap-怎么保证可见性？&#34; class=&#34;headerlink&#34; title=&#34;ConcurrentHashMap 怎么保证可见性？&#34;&gt;&lt;/a&gt;ConcurrentHashMap 怎么保证可见性？&lt;/h4&gt;&lt;p&gt;ConcurrentHashMap 中的 Node 节点中，value 和 next 都是 volatile 的，这样就可以保证对 value 或 next 的更新会被其他线程立即看到。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;为什么-ConcurrentHashMap-比-Hashtable-效率高？&#34;&gt;&lt;a href=&#34;#为什么-ConcurrentHashMap-比-Hashtable-效率高？&#34; class=&#34;headerlink&#34; title=&#34;为什么 ConcurrentHashMap 比 Hashtable 效率高？&#34;&gt;&lt;/a&gt;为什么 ConcurrentHashMap 比 Hashtable 效率高？&lt;/h4&gt;&lt;p&gt;Hashtable 在任何时刻只允许一个线程访问整个 Map，是通过对整个 Map 加锁来实现线程安全的。比如 get 和 put 方法，是直接在方法上加的 synchronized 关键字。而 ConcurrentHashMap 在 JDK 8 中是采用 CAS + synchronized 实现的，仅在必要时加锁。比如说 put 的时候优先使用 CAS 尝试插入，如果失败再使用 synchronized 代码块加锁。get 的时候是完全无锁的，因为 value 是 volatile 变量 修饰的，保证了内存可见性。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;CopyOnWriteArrayList-的实现原理&#34;&gt;&lt;a href=&#34;#CopyOnWriteArrayList-的实现原理&#34; class=&#34;headerlink&#34; title=&#34;CopyOnWriteArrayList 的实现原理&#34;&gt;&lt;/a&gt;CopyOnWriteArrayList 的实现原理&lt;/h4&gt;&lt;p&gt;CopyOnWriteArrayList 是 ArrayList 的线程安全版本，适用于读多写少的场景。它的核心思想是写操作时创建一个新数组，修改后再替换原数组，这样就能够确保读操作无锁，从而提高并发性能。内部使用 volatile 变量来修饰数组 array，以读操作的内存可见性。写操作的时候使用 ReentrantLock 来保证线程安全。缺点就是写操作的时候会复制一个新数组，如果数组很大，写操作的性能会受到影响。&lt;/p&gt;
&lt;h3 id=&#34;1-阻塞队列的实现方式？&#34;&gt;&lt;a href=&#34;#1-阻塞队列的实现方式？&#34; class=&#34;headerlink&#34; title=&#34;1. 阻塞队列的实现方式？&#34;&gt;&lt;/a&gt;1. 阻塞队列的实现方式？&lt;/h3&gt;&lt;p&gt;阻塞队列是多线程环境下常用的数据结构，支持阻塞式的插入和删除，当队列满时，生产者线程会被阻塞直到有空间；当队列空时，消费者线程会被阻塞直到有元素。这种特性使其非常适合实现生产者 - 消费者模式。主要实现方式有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 synchronized+wait&amp;#x2F;notify ，利用 Java 内置锁和 Object 类的等待机制。队列的 put 和 take 方法用 synchronized 修饰，当队列满时，生产者通过 wait () 进入等待状态；当队列空时，消费者同样 wait ()。操作完成后通过 notifyAll () 唤醒等待线程。优点是实现简单，缺点是功能单一，不支持公平性，且只有一个条件队列。&lt;/li&gt;
&lt;li&gt;基于 ReentrantLock+Condition 的实现。这是 JDK 标准库（如ArrayBlockingQueue）采用的方式，比 synchronized 更灵活。通过 ReentrantLock 保证线程安全，同时创建两个 Condition 对象（notEmpty 和 notFull）分别管理消费者和生产者的等待队列。当队列满时，生产者在 notFull 上 await ()；当队列空时，消费者在 notEmpty 上 await ()。操作完成后针对性地 signal () 对应条件队列的线程。这种方式支持公平锁配置，且能精确唤醒特定类型的线程。&lt;/li&gt;
&lt;li&gt;基于 CAS 操作的非阻塞实现。利用原子类（如 AtomicReference）通过 CAS 操作实现无锁化的并发控制，比如 ConcurrentLinkedQueue。通过循环重试的方式处理并发冲突，避免了线程阻塞和唤醒的开销，高并发场景下性能更好，但实现逻辑复杂，适合对性能要求极高的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这几种实现各有侧重：synchronized 方式适合简单场景；ReentrantLock+Condition 兼顾功能与性能，是 JDK 标准实现的首选；CAS 方式适合高并发低延迟的场景。实际开发中通常用 JDK 提供的阻塞队列（如 ArrayBlockingQueue、LinkedBlockingQueue），它们内部基于 ReentrantLock+Condition 实现，已经过充分优化和测试，能满足绝大多数并发场景的需求。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;开放性问题&#34;&gt;&lt;a href=&#34;#开放性问题&#34; class=&#34;headerlink&#34; title=&#34;开放性问题&#34;&gt;&lt;/a&gt;开放性问题&lt;/h2&gt;&lt;h3 id=&#34;1-先做个简单的自我介绍吧！&#34;&gt;&lt;a href=&#34;#1-先做个简单的自我介绍吧！&#34; class=&#34;headerlink&#34; title=&#34;1. 先做个简单的自我介绍吧！&#34;&gt;&lt;/a&gt;1. 先做个简单的自我介绍吧！&lt;/h3&gt;&lt;p&gt;面试官您好！我叫郝泽飞，是哈尔滨工程大学计算机专业的学生，现在在读研一，在校期间，我成绩专业排名前10%，大学期间参加了多个竞赛并取得奖项，通过了英语四六级。技术方面，大一期间我学习了计算机的基础知识，像数据结构，C++和JAVA的基础语法，大二以后开始学Java技术栈，比如Spring Boot、MyBatis-Plus、MySQL、Redis、RabbitMQ等，后来又做了一些项目，微服务架构的Pm-hub,大模型应用开发的派聪明。生活中我是一个比较积极乐观的人，我非常期待能在贵公司的开发岗位中，将所学的技术应用于实际业务，我的介绍完毕，谢谢！&lt;/p&gt;
&lt;h3 id=&#34;2-说说你的这个pm-hub项目吧？&#34;&gt;&lt;a href=&#34;#2-说说你的这个pm-hub项目吧？&#34; class=&#34;headerlink&#34; title=&#34;2. 说说你的这个pm-hub项目吧？&#34;&gt;&lt;/a&gt;2. 说说你的这个pm-hub项目吧？&lt;/h3&gt;&lt;p&gt;（项目背景、解决问题、职责任务。2项目使用的技术栈、技术架构、是否使用微服务，项目具体功能细节。技术具体实现细节。项目存在的问题和完善解决方案。项目具体功能的优化（如查询是在数据库中扫表查询吗）项目最有挑战的模块，如何解决，项目增大10倍的qps，如何设计？项目上线后出现频繁fullGc，怎么解决？）&lt;br&gt;好的，这个项目是我（跟室友&amp;#x2F;同学&amp;#x2F;老师一起做的。&amp;#x2F;参考开源项目做的一个二次开发），做这个项目是为了……，考虑到—所以项目中用到了***，当时我负责的部分是。发现速度&amp;#x2F;可用性不够，进行了SQL优化，分布式锁，seata事务,skywalking监控等。第二个项目是……，因为最近AI比较流行，我就想学一些新技术，跟上时代的步伐，这个项目是参考开源项目，用了……技术栈，实现了……功能，优化，解决……问题。以上是我的项目介绍。&lt;/p&gt;
&lt;h3 id=&#34;3-项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;a href=&#34;#3-项目中遇到最大的困难？怎么解决的？&#34; class=&#34;headerlink&#34; title=&#34;3. 项目中遇到最大的困难？怎么解决的？&#34;&gt;&lt;/a&gt;3. 项目中遇到最大的困难？怎么解决的？&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;4-平时是怎么学习的？&#34;&gt;&lt;a href=&#34;#4-平时是怎么学习的？&#34; class=&#34;headerlink&#34; title=&#34;4. 平时是怎么学习的？&#34;&gt;&lt;/a&gt;4. 平时是怎么学习的？&lt;/h3&gt;&lt;p&gt;比如我学一门新技术吧，首先看官方文档，如果晦涩难懂就会找教程&amp;#x2F;视频，还会使用AI工具（豆包，chatGPT）详细解释辅助理解，然后做个demo用到项目中，大学期间我大多是在开源社区学习还有网课。&lt;/p&gt;
&lt;h3 id=&#34;5-人生发展、最近五年职业规划&#34;&gt;&lt;a href=&#34;#5-人生发展、最近五年职业规划&#34; class=&#34;headerlink&#34; title=&#34;5. 人生发展、最近五年职业规划&#34;&gt;&lt;/a&gt;5. 人生发展、最近五年职业规划&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;6-什么时候能到岗？&#34;&gt;&lt;a href=&#34;#6-什么时候能到岗？&#34; class=&#34;headerlink&#34; title=&#34;6. 什么时候能到岗？&#34;&gt;&lt;/a&gt;6. 什么时候能到岗？&lt;/h3&gt;&lt;h3 id=&#34;7-薪资要求？&#34;&gt;&lt;a href=&#34;#7-薪资要求？&#34; class=&#34;headerlink&#34; title=&#34;7. 薪资要求？&#34;&gt;&lt;/a&gt;7. 薪资要求？&lt;/h3&gt;&lt;h2 id=&#34;反问：&#34;&gt;&lt;a href=&#34;#反问：&#34; class=&#34;headerlink&#34; title=&#34;反问：&#34;&gt;&lt;/a&gt;反问：&lt;/h2&gt;&lt;h3 id=&#34;一面&#34;&gt;&lt;a href=&#34;#一面&#34; class=&#34;headerlink&#34; title=&#34;一面&#34;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;部门主营业务和使用的技术栈是什么？&lt;/li&gt;
&lt;li&gt;您觉得我的专业能力有哪些需要提升的？&lt;/li&gt;
&lt;li&gt;刚才关于xx问题，我想问下您的思路。&lt;/li&gt;
&lt;li&gt;面试一般多久会出通知和结果呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二面&#34;&gt;&lt;a href=&#34;#二面&#34; class=&#34;headerlink&#34; title=&#34;二面&#34;&gt;&lt;/a&gt;二面&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面试候选人，尤其是校招生的时候，最看重什么？&lt;/li&gt;
&lt;li&gt;您对进入您团队的成员的要求是什么？或者说需要怎样的品质胜任这个职位？&lt;/li&gt;
&lt;li&gt;我很好奇职位的晋升机制和发展路径。公司对信任的培养是怎么样的？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;HR面-三面&#34;&gt;&lt;a href=&#34;#HR面-三面&#34; class=&#34;headerlink&#34; title=&#34;HR面&amp;#x2F;三面&#34;&gt;&lt;/a&gt;HR面&amp;#x2F;三面&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;企业文化&lt;/li&gt;
&lt;li&gt;代表性产品&lt;/li&gt;
&lt;li&gt;历年薪资&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Hexo" />
        <category term="博客" />
        <updated>2025-07-20T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
        <title>ArrayList底层的实现原理是什么？</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;ArrayList底层是动态数组，支持自动扩容和高效随机访问。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;ArrayList底层是一个&lt;strong&gt;动态数组&lt;/strong&gt;，&lt;strong&gt;初始容量是0&lt;/strong&gt;，&lt;strong&gt;当第一次添加数据&lt;/strong&gt;才会初始化容量为10，&lt;strong&gt;扩容&lt;/strong&gt;是原来容量的1.5倍，每次扩容都需要&lt;strong&gt;拷贝数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;添加数据时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断元素个数size+1后是否大于总容量，如果大于就调用grow方法扩容，把旧数组拷贝到扩容后的新数组中，再把新元素放在size位置上，返回true。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ArrayList list&amp;#x3D;new ArrayList(10)中的list扩容几次?&lt;/strong&gt;&lt;br&gt;声明和实例了一个ArrayList，指定了容量为10，未扩容。构造方法中传参initCapcity,是多少就初始化多少容量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现数组和List之间的转换？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组转List:           &lt;strong&gt;Arrays工具类的asList方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;List转数组，使用&lt;strong&gt;List的toArray方法&lt;/strong&gt;。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面试官再问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Arrays.asList转List后，如果修改了数组内容，list受影响吗？&lt;/li&gt;
&lt;li&gt;List用toArray转数组后，如果修改了List内容，数组受影响吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数组转List受影响&lt;/strong&gt;，因为它的&lt;strong&gt;底层使用的Arrays类中的一个内部类ArrayList来构造的集合&lt;/strong&gt;，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，&lt;strong&gt;最终指向的都是同一个内存地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List转数组不受影响&lt;/strong&gt;，在底层是它是进行了数组的拷贝。&lt;/p&gt;
</content>
        <category term="ArrayList" />
        <category term="实现原理" />
        <updated>2025-07-19T08:55:58.136Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
        <title>HashSet，HashTable与HashMap的区别</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;对比HashSet、HashMap、HashTable三者的底层结构、线程安全性、常用方法及应用场景。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;数据结构上HashSet底层是一个HashMap，只存储键不存储值；HashMap是一个哈希表，由数组+链表+红黑树组成，存储键值对。HashSet不能重复，只允许一个null元素，实现了Set接口；HashMap键只有一个null值，值可以有多个，实现Map接口，它们性能一致。&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HashSet：add, remove, contains, size&lt;/li&gt;
&lt;li&gt;HashMap: put(), get(), remove(), containsKey(), size()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HashTable 是 Java 早期的线程安全哈希表实现，因同步开销大、设计局限性（如不支持 null、扩容效率低），已逐渐被淘汰。HashMap 作为更现代的实现，性能更优、功能更灵活，而多线程场景下推荐使用 ConcurrentHashMap（分段锁优化，性能远超 HashTable）。&lt;/p&gt;
&lt;p&gt;你能自己设计实现一个 HashMap 吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，实现一个 hash 函数，对键的 hashCode 进行扰动&lt;/li&gt;
&lt;li&gt;第二步，实现一个拉链法的方法来解决哈希冲突&lt;/li&gt;
&lt;li&gt;第三步，扩容后，重新计算哈希值，将元素放到新的数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;讲讲 LinkedHashMap 怎么实现有序的？&lt;br&gt;在 HashMap 的基础上维护了一个双向链表，通过 before 和 after 标识前置节点和后置节点。从而实现插入和访问有序。&lt;/p&gt;
</content>
        <category term="HashMap" />
        <category term="HashSet" />
        <category term="HashTable" />
        <updated>2025-07-19T08:55:48.002Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</id>
        <title>HashMap 是线程安全的吗？</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;HashMap 不是线程安全的，多线程环境下可能出现死循环、数据丢失等问题。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap 不是线程安全的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JDK7 中的 HashMap 使用的是&lt;strong&gt;头插法&lt;/strong&gt;来处理链表，在&lt;strong&gt;多线程环境下扩容会出现环形链表，造成死循环&lt;/strong&gt;。JDK 8 时通过&lt;strong&gt;尾插法修复&lt;/strong&gt;了这个问题，扩容时会保持链表原来的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程在进行 &lt;strong&gt;put 元素&lt;/strong&gt;的时候，&lt;strong&gt;可能会导致元素丢失&lt;/strong&gt;。因为put操作&lt;strong&gt;不是原子的&lt;/strong&gt;。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素&lt;strong&gt;先插入的元素被覆盖而丢失&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元&lt;strong&gt;素个数超出阈值而扩容&lt;/strong&gt;，线程 2 此时执行 get 就可能获取不到元素。线程 1 执行完 table &amp;#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引元素可能就 get 不到了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="HashMap" />
        <category term="线程安全" />
        <updated>2025-07-19T08:55:34.536Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/</id>
        <title>HashMap的put方法的具体流程？</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;详细解析HashMap的put方法执行流程，包括哈希计算、索引定位、冲突处理、链表与红黑树转换等。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;&lt;strong&gt;第一步：检查数组是否为空&lt;/strong&gt;&lt;br&gt;首次&lt;code&gt;put&lt;/code&gt;时，调用&lt;code&gt;resize()&lt;/code&gt;初始化数组，默认容量为16，负载因子为0.75。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：计算键的哈希值&lt;/strong&gt;&lt;br&gt;具体是将键的hashCode异或hashCode右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：根据键的哈希值计算数组索引&lt;/strong&gt;&lt;br&gt;具体是将键的哈希值与上数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高，所以用与运算代替模运算，但前提是数组长度是2的N次幂）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：检查数组索引对应槽位的情况&lt;/strong&gt;&lt;br&gt;如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只重写元素的equals方法没重写hashCode，put的时候会发生什么？&lt;/strong&gt;&lt;br&gt;如果只重写equals方法，没有重写hashCode方法，那么会导致equals相等的两个对象，hashCode不相等，这样的话，两个对象会被put到数组中不同的位置，导致get的时候，无法获取到正确的值。&lt;/p&gt;
</content>
        <category term="HashMap" />
        <category term="put方法" />
        <updated>2025-07-19T08:55:24.937Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</id>
        <title>HashMap实现原理？</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前是数组+链表，之后是数组+链表+红黑树。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;HashMap底层是哈希表数据结构，Java8之前，是数组+链表。之后是数组+链表+红黑树。&lt;/p&gt;
&lt;p&gt;存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果key相同，覆盖原值。&lt;/li&gt;
&lt;li&gt;key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。&lt;/p&gt;
&lt;p&gt;源码：初始容量16，加载因子0.75，扩容&amp;#x3D;之积。懒加载，不初始化容量。&lt;/p&gt;
</content>
        <category term="实现原理" />
        <category term="HashMap" />
        <updated>2025-07-19T08:55:15.936Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
        <title>讲一讲HashMap的扩容机制</title>
        <link rel="alternate" href="https://120115.xyz/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
        <content type="html">&lt;p&gt;摘要：&lt;br&gt;HashMap 在元素个数超过阈值时会触发扩容（resize）操作，这个阈值是数组容量 * 负载因子。扩容的过程包括新数组创建和元素迁移。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;

&lt;p&gt;正文：&lt;br&gt;当哈希表中元素个数超过阈值时会触发扩容 resize 方法，这个阈值是 数组容量 * 负载因子，数组容量初始是16，负载因子默认是0.75。&lt;/p&gt;
&lt;p&gt;扩容时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建一个新数组&lt;/strong&gt;，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迁移元素&lt;/strong&gt;，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过 &lt;code&gt;e.hash &amp;amp; (newCap新容量 - 1)&lt;/code&gt; 计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为&lt;strong&gt;低位链&lt;/strong&gt;和&lt;strong&gt;高位链&lt;/strong&gt;，避免重新哈希带来性能损耗。如果 &lt;code&gt;e.hash &amp;amp; oldCap == 0&lt;/code&gt;（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这种方式，HashMap 能够高效地完成扩容和数据迁移，保证查询和插入的性能。&lt;/p&gt;
</content>
        <category term="HashMap" />
        <category term="扩容" />
        <updated>2025-07-19T08:28:05.350Z</updated>
    </entry>
    <entry>
        <id>https://120115.xyz/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/</id>
        <title>LangChain4j实战教程-Java开发AI项目，太爽了！</title>
        <link rel="alternate" href="https://120115.xyz/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/"/>
        <content type="html">&lt;p&gt;原文链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvN2NOaDduZGVpV2lIQmpua1Rrel9aZw==&#34;&gt;https://mp.weixin.qq.com/s/7cNh7ndeiWiHBjnkTkz_Zg&lt;/span&gt;&lt;br&gt;大家好，我是程序员鱼皮。现在 AI 应用开发可以说是程序员必备的技能了，求职时能够大幅增加竞争力。之前我用 Spring AI 带大家做过一个开源的 AI 超级智能体项目，这次我来带大家快速掌握另一个主流的 Java AI 应用开发框架 LangChain4j。&lt;/p&gt;
&lt;p&gt;这个教程也是我精心设计，拒绝枯燥的理论，而是用一个编程小助手项目带大家在实战中依次学习 LangChain 几乎所有主流的用法和特性。看完这个教程，你不仅学会了 LangChain，还直接多了一段项目经历，岂不美哉？&lt;/p&gt;
&lt;p&gt;文章近一万字，有点长，建议收藏，观看视频版体验更佳~&lt;/p&gt;
&lt;p&gt;完整视频教程：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iaWxpYmlsaS5jb20vdmlkZW8vQlYxWDRHR3ppRXly&#34;&gt;https://bilibili.com/video/BV1X4GGziEyr&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;项目代码开源：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2xpeXVwaS9haS1jb2RlLWhlbHBlcg==&#34;&gt;https://github.com/liyupi/ai-code-helper&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;需求分析&#34;&gt;&lt;a href=&#34;#需求分析&#34; class=&#34;headerlink&#34; title=&#34;需求分析&#34;&gt;&lt;/a&gt;需求分析&lt;/h2&gt;&lt;p&gt;我们要实现一个 AI 编程小助手，可以帮助用户答疑解惑，并且给出编程学习的指导建议，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编程学习路线&lt;/li&gt;
&lt;li&gt;项目学习建议&lt;/li&gt;
&lt;li&gt;程序员求职指南&lt;/li&gt;
&lt;li&gt;程序员常见面试题&lt;/li&gt;
&lt;/ul&gt;
&lt;img data-src=&#34;/images/d58d0458.jpg&#34; /&gt;

&lt;p&gt;要实现这个需求，我们首先要能够调用 AI 完成基础对话，而且要支持实现多轮对话记忆。此外，如果想进一步增强 AI 的能力，需要让它能够使用工具来联网搜索内容；还可以让 AI 基于我们自己的知识库回答，给用户提供我们在编程领域沉淀的资源和经验。&lt;/p&gt;
&lt;img data-src=&#34;/images/07acfff9.jpg&#34; /&gt;

&lt;p&gt;如果要从 0 开始实现上述功能，还是很麻烦的，因此我们要使用 AI 开发框架来提高效率。&lt;/p&gt;
&lt;h2 id=&#34;什么是-LangChain4j？&#34;&gt;&lt;a href=&#34;#什么是-LangChain4j？&#34; class=&#34;headerlink&#34; title=&#34;什么是 LangChain4j？&#34;&gt;&lt;/a&gt;什么是 LangChain4j？&lt;/h2&gt;&lt;p&gt;目前主流的 Java AI 开发框架有 Spring AI 和 LangChain4j，它们都提供了很多开箱即用的 API 来帮你调用大模型、实现 AI 开发常用的功能，比如我们今天要学的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对话记忆&lt;/li&gt;
&lt;li&gt;结构化输出&lt;/li&gt;
&lt;li&gt;RAG 知识库&lt;/li&gt;
&lt;li&gt;工具调用&lt;/li&gt;
&lt;li&gt;MCP&lt;/li&gt;
&lt;li&gt;SSE 流式输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就我个人体验下来，这两个框架的很多概念和用法都是类似的，也都提供了很多插件扩展，都支持和 Spring Boot 项目集成。虽然有一些编码上的区别，但孰好孰坏，使用感受也是因人而异的。&lt;/p&gt;
&lt;p&gt;实际开发中应该如何选择呢？&lt;/p&gt;
&lt;p&gt;我想先带你用 LangChain4j 开发完一个项目，最后再揭晓答案，因为那个时候你自己也会有一些想法。&lt;/p&gt;
&lt;h2 id=&#34;AI-应用开发&#34;&gt;&lt;a href=&#34;#AI-应用开发&#34; class=&#34;headerlink&#34; title=&#34;AI 应用开发&#34;&gt;&lt;/a&gt;AI 应用开发&lt;/h2&gt;&lt;h3 id=&#34;新建项目&#34;&gt;&lt;a href=&#34;#新建项目&#34; class=&#34;headerlink&#34; title=&#34;新建项目&#34;&gt;&lt;/a&gt;新建项目&lt;/h3&gt;&lt;p&gt;打开 IDEA 开发工具，新建一个 Spring Boot 项目，Java 版本选择 21（因为 LangChain4j 最低支持 17 版本）：&lt;/p&gt;
&lt;img data-src=&#34;/images/84fb083d.jpg&#34; /&gt;

&lt;p&gt;选择依赖，使用 3.5.x 版本的 Spring Boot，引入 Spring MVC 和 Lombok 注解库：&lt;/p&gt;
&lt;img data-src=&#34;/images/d7781d62.jpg&#34; /&gt;

&lt;p&gt;新建项目后，先修改配置文件后缀为 yml，便于后面填写配置。&lt;/p&gt;
&lt;img data-src=&#34;/images/b18ee1c8.jpg&#34; /&gt;

&lt;p&gt;这里我会建议大家创建一个 application-local.yml 配置文件，将开发时用到的敏感配置写到这里，并且添加到 .gitignore 中，防止不小心开源出来。&lt;/p&gt;
&lt;h2 id=&#34;AI-对话-ChatModel&#34;&gt;&lt;a href=&#34;#AI-对话-ChatModel&#34; class=&#34;headerlink&#34; title=&#34;AI 对话 - ChatModel&#34;&gt;&lt;/a&gt;AI 对话 - ChatModel&lt;/h2&gt;&lt;p&gt;ChatModel 是最基础的概念，负责和 AI 大模型交互。&lt;/p&gt;
&lt;p&gt;首先需要引入至少一个 AI 大模型依赖，这里选择国内的阿里云大模型，提供了和 Spring Boot 项目的整合依赖包，比较方便：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;dev.langchain4j&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;langchain4j-community-dashscope-spring-boot-starter&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.1.0-beta7&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;需要到 阿里云百炼平台 获取大模型调用 key，注意不要泄露！&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQibTrFMyk56ic6p3qg6aCicKD6l5XeCMKIv8edXQ3omDEtyCplkCWXcfeQ/640?wx_fmt=png&amp;from=appmsg&amp;randomid=4t4d3x7n&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;回到项目，在配置文件中添加大模型配置，指定模型名称和 API Key：&lt;/p&gt;
&lt;figure class=&#34;highlight yaml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;attr&#34;&gt;langchain4j:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;community:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;dashscope:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;chat-model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;model-name:&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;qwen-max&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;api-key:&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;You&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;API&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;Key&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;here&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以按需选择模型名称，追求效果可以用 qwen-max，否则可以选择效果、速度、成本均衡的 qwen-plus。&lt;/p&gt;
&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQenuXgWvZOMQtpdquOdUJyyLASN2NkhUqk30Ozngn9SEmdUvFQxdbRg/640?wx_fmt=png&amp;from=appmsg&amp;randomid=8ac4s7h5&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&#34; /&gt;

&lt;p&gt;除了编写配置让 Spring Boot 自动构建 ChatModel 外，也可以通过构造器自己创建 ChatModel 对象。这种方式更灵活，在 LangChain4j 中我们会经常用到这种方式来构造对象。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;ChatModel&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;qwenModel&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; QwenChatModel.builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .apiKey(&lt;span class=&#34;string&#34;&gt;&amp;quot;You API key here&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .modelName(&lt;span class=&#34;string&#34;&gt;&amp;quot;qwen-max&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .enableSearch(&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .temperature(&lt;span class=&#34;number&#34;&gt;0.7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .maxTokens(&lt;span class=&#34;number&#34;&gt;4096&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .stops(List.of(&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;有了 ChatModel 后，创建一个 AiCodeHelper 类，引入自动注入的 qwenChatModel，编写简单的对话代码，并利用 Lombok 注解打印输出结果日志：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AiCodeHelper&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; ChatModel qwenChatModel;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;chat&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String message)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;UserMessage&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;userMessage&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; UserMessage.from(message);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ChatResponse&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;chatResponse&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; qwenChatModel.chat(userMessage);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;AiMessage&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;aiMessage&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; chatResponse.aiMessage();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        log.info(&lt;span class=&#34;string&#34;&gt;&amp;quot;AI 输出：&amp;quot;&lt;/span&gt; + aiMessage.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; aiMessage.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编写单元测试，向 AI 打个招呼吧：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@SpringBootTest&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AiCodeHelperTest&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; AiCodeHelper aiCodeHelper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;chat&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        aiCodeHelper.chat(&lt;span class=&#34;string&#34;&gt;&amp;quot;你好，我是程序员鱼皮&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以 Debug 模式运行单元测试，成功运行并查看输出：&lt;/p&gt;
&lt;!-- 省略后续内容，继续按上述格式处理全文 --&gt; </content>
        <category term="AI" />
        <category term="Java" />
        <category term="LangChain4j" />
        <category term="实战教程" />
        <updated>2024-07-21T04:00:00.000Z</updated>
    </entry>
</feed>
