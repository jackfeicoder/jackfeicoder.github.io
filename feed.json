{
    "version": "https://jsonfeed.org/version/1",
    "title": "杰克飞的博客",
    "description": "一个用Hexo搭建的个人博客",
    "home_page_url": "https://120115.xyz",
    "items": [
        {
            "id": "https://120115.xyz/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E7%AE%80%E6%B4%81%E7%89%88/",
            "url": "https://120115.xyz/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E7%AE%80%E6%B4%81%E7%89%88/",
            "title": "力扣算法Hot100刷题路线",
            "date_published": "2025-08-01T03:08:46.565Z",
            "content_html": "<h1 id=\"力扣算法Hot100刷题路线\"><a href=\"#力扣算法Hot100刷题路线\" class=\"headerlink\" title=\"力扣算法Hot100刷题路线\"></a>力扣算法Hot100刷题路线</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于算法题，按题型类别刷题才会更有成效，因此我这里在网上搜索并参考了下 <strong>🔥 LeetCode 热题 HOT 100</strong> 的题型归类，并在其基础上做了一定的完善，希望能够记录自己的刷题历程，有所收获！</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">【热题】LeetCode 热题 HOT 100分类+题解</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">leetcode HOT100总结</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">leetcode算法总结 —— HOT 100分类整理</span></li>\n</ul>\n<h3 id=\"刷题说明\"><a href=\"#刷题说明\" class=\"headerlink\" title=\"刷题说明\"></a>刷题说明</h3><ul>\n<li>我这里只做了LeetCode 热题 HOT 100中的 <strong>easy</strong> 和 <strong>middle</strong> 的题，<strong>hard</strong> 的题难度较大暂时都跳过了（题目上都有 <del>删除线</del> 标识），大部分面试也不会考察，后面有精力再做研究。</li>\n<li>题目后带有 <strong>★</strong> 标识的表示后续还要继续反复练习，题目可能不难，但有时可能会忽略其中的一些刷题细节而导致错误</li>\n<li>每一种类型的题目，并不绝对是按照题号递增的顺序来排列的（当然大部分都是按题号大小排好序的）。</li>\n<li>因为有些题目其实很相似，放在一起更好，便单独对他们做了调整，比如 <a href=\"#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\">647. 回文子串</a> 和 <a href=\"#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\">5. 最长回文子串</a></li>\n<li>这里面的每一道题，都有相对应我自己日常整理的题解，具体可参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">我的博客-LeetCode专栏题解</span>，在里面搜对应题号即可 ~</li>\n<li>大家在浏览时，可以通过下方⬇️按题型分类汇总后的【目录】来实现快速跳转，更方便、更快捷的刷题。</li>\n<li>同时这篇文章我也是我花费了很长的时间，对比多篇文章来总结和编写的，希望对大家有所帮助。</li>\n</ul>\n<h2 id=\"文章目录\"><a href=\"#文章目录\" class=\"headerlink\" title=\"文章目录\"></a>文章目录</h2><h3 id=\"一、链表（共11题）\"><a href=\"#一、链表（共11题）\" class=\"headerlink\" title=\"一、链表（共11题）\"></a>一、链表（共11题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMvZGVzY3JpcHRpb24v\">2. 两数相加</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC9kZXNjcmlwdGlvbi8=\">19. 删除链表的倒数第 N 个结点</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLz9mYXZvcml0ZT0yY2t0a3Zq\">21. 合并两个有序链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">23. 合并K个升序链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8/ZmF2b3JpdGU9MmNrdGt2ag==\">141. 环形链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">142. 环形链表 II</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3QvZGVzY3JpcHRpb24v\">148. 排序链表</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8/ZmF2b3JpdGU9MmNrdGt2ag==\">160. 相交链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">206. 反转链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">234. 回文链表</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9xdWV1ZS1yZWNvbnN0cnVjdGlvbi1ieS1oZWlnaHQvP2Zhdm9yaXRlPTJja3Rrdmo=\">406. 根据身高重建队列</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h3 id=\"二、二叉树（共14题，含2道hard题）\"><a href=\"#二、二叉树（共14题，含2道hard题）\" class=\"headerlink\" title=\"二、二叉树（共14题，含2道hard题）\"></a>二、二叉树（共14题，含2道hard题）</h3><p><strong>做题心得：</strong></p>\n<ul>\n<li><p>处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了</p>\n</li>\n<li><p>是的，只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</p>\n</li>\n<li><p>跟树相关的题，一般有两种解法：递归&amp;迭代：递归用dfs，而迭代用bfs（队列）</p>\n</li>\n<li><p>Go 语言的深度优先遍历算法可以采用闭包函数实现，这样省去了许多参数的传递与全局变量的声明。</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8/ZmF2b3JpdGU9MmNrdGt2ag==\">94. 二叉树的中序遍历</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUvP2Zhdm9yaXRlPTJja3Rrdmo=\">98. 验证二叉搜索树</span> <strong>★★★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS9kZXNjcmlwdGlvbi8=\">101. 对称二叉树</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">102. 二叉树的层序遍历</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==\">104. 二叉树的最大深度</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24v\">105. 从前序与中序遍历序列构造二叉树</span> <strong>★★★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lz9mYXZvcml0ZT0yY2t0a3Zq\">114. 二叉树展开为链表</span> <strong>★★★</strong></p>\n</li>\n<li><p><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">124. 二叉树中的最大路径和</span></del>（hard题，暂时跳过）</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">226. 翻转二叉树</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24v\">236. 二叉树的最近公共祖先</span> <strong>★</strong></p>\n</li>\n<li><p><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLz9mYXZvcml0ZT0yY2t0a3Zq\">297. 二叉树的序列化与反序列化</span></del>（hard题，暂时跳过）</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUvZGVzY3JpcHRpb24v\">538. 把二叉搜索树转换为累加树</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS9kZXNjcmlwdGlvbi8=\">543. 二叉树的直径</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLz9mYXZvcml0ZT0yY2t0a3Zq\">617. 合并二叉树</span></p>\n</li>\n</ul>\n<p><strong>新版 hot100 题目扩充（以下题目列表不断更新ing~）：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUvZGVzY3JpcHRpb24v\">LeetCode 108. 将有序数组转换为二叉搜索树</span></li>\n</ul>\n<h3 id=\"三、DFS-BFS（共6题，含3道hard题）\"><a href=\"#三、DFS-BFS（共6题，含3道hard题）\" class=\"headerlink\" title=\"三、DFS&#x2F;BFS（共6题，含3道hard题）\"></a>三、DFS&#x2F;BFS（共6题，含3道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC9kZXNjcmlwdGlvbi8=\">79. 单词搜索</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS8/ZmF2b3JpdGU9MmNrdGt2ag==\">85. 最大矩形</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy9kZXNjcmlwdGlvbi8=\">200. 岛屿数量</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGUvP2Zhdm9yaXRlPTJja3Rrdmo=\">207. 课程表</span></del> （hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">301. 删除无效的括号</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb25zLw==\">437. 路径总和 III</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"四、递归-回溯（共6题，含1道hard题）\"><a href=\"#四、递归-回溯（共6题，含1道hard题）\" class=\"headerlink\" title=\"四、递归&#x2F;回溯（共6题，含1道hard题）\"></a>四、递归&#x2F;回溯（共6题，含1道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">17. 电话号码的字母组合</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=\">22. 括号生成</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0vZGVzY3JpcHRpb24v\">39. 组合总和</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMvP2Zhdm9yaXRlPTJja3Rrdmo=\">46. 全排列</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzL2Rlc2NyaXB0aW9uLw==\">78. 子集</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1kaXZpc2lvbi9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">399. 除法求值</span></del> （hard题，暂时跳过）</li>\n</ul>\n<h3 id=\"五、Hash表-map（共3题）\"><a href=\"#五、Hash表-map（共3题）\" class=\"headerlink\" title=\"五、Hash表&#x2F;map（共3题）\"></a>五、Hash表&#x2F;map（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtL2Rlc2NyaXB0aW9uLw==\">1. 两数之和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy9kZXNjcmlwdGlvbi8=\">49. 字母异位词分组</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">128. 最长连续序列</span></li>\n</ul>\n<h3 id=\"六、位运算（共3题）\"><a href=\"#六、位运算（共3题）\" class=\"headerlink\" title=\"六、位运算（共3题）\"></a>六、位运算（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">136. 只出现一次的数字</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzL2Rlc2NyaXB0aW9uLw==\">338. 比特位计数</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYW1taW5nLWRpc3RhbmNlL2Rlc2NyaXB0aW9uLw==\">461. 汉明距离</span></li>\n</ul>\n<h3 id=\"七、数组（共5题）\"><a href=\"#七、数组（共5题）\" class=\"headerlink\" title=\"七、数组（共5题）\"></a>七、数组（共5题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">15. 三数之和</span></del> 待研究</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LXBlcm11dGF0aW9uL2Rlc2NyaXB0aW9uLw==\">31. 下一个排列</span> <strong>★★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50L2Rlc2NyaXB0aW9uLw==\">169. 多数元素</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmL2Rlc2NyaXB0aW9uLw==\">238. 除自身以外数组的乘积</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1udW1iZXJzLWRpc2FwcGVhcmVkLWluLWFuLWFycmF5L2Rlc2NyaXB0aW9uLw==\">448. 找到所有数组中消失的数字</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"八、二分查找（共5题，含1道hard题）\"><a href=\"#八、二分查找（共5题，含1道hard题）\" class=\"headerlink\" title=\"八、二分查找（共5题，含1道hard题）\"></a>八、二分查找（共5题，含1道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWRpYW4tb2YtdHdvLXNvcnRlZC1hcnJheXMvZGVzY3JpcHRpb24v\">4. 寻找两个正序数组的中位数</span> （hard题）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkvZGVzY3JpcHRpb24v\">33. 搜索旋转排序数组</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWFycmF5L2Rlc2NyaXB0aW9uLw==\">34. 在排序数组中查找元素的第一个和最后一个位置</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">240. 搜索二维矩阵 II</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kdXBsaWNhdGUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">287. 寻找重复数</span> <strong>★★</strong></li>\n</ul>\n<p><strong>新版 hot100 题目扩充（以下题目列表不断更新ing~）：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW5zZXJ0LXBvc2l0aW9uL2Rlc2NyaXB0aW9uLw==\">LeetCode 35. 搜索插入位置</span></li>\n</ul>\n<h3 id=\"九、双指针-三指针（共3题）\"><a href=\"#九、双指针-三指针（共3题）\" class=\"headerlink\" title=\"九、双指针&#x2F;三指针（共3题）\"></a>九、双指针&#x2F;三指针（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyL2Rlc2NyaXB0aW9uLw==\">11. 盛最多水的容器</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy9kZXNjcmlwdGlvbi8=\">75. 颜色分类</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy9kZXNjcmlwdGlvbi8=\">283. 移动零</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十、栈-单调栈（共6题，含2道hard题）\"><a href=\"#十、栈-单调栈（共6题，含2道hard题）\" class=\"headerlink\" title=\"十、栈&#x2F;单调栈（共6题，含2道hard题）\"></a>十、栈&#x2F;单调栈（共6题，含2道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=\">20. 有效的括号</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLz9mYXZvcml0ZT0yY2t0a3Zq\">42. 接雨水</span></del> （hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vP2Zhdm9yaXRlPTJja3Rrdmo=\">84. 柱状图中最大的矩形</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2svZGVzY3JpcHRpb24v\">155. 最小栈</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL2Rlc2NyaXB0aW9uLw==\">394. 字符串解码</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kYWlseS10ZW1wZXJhdHVyZXMvZGVzY3JpcHRpb24v\">739. 每日温度</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十一、排序（共4题）\"><a href=\"#十一、排序（共4题）\" class=\"headerlink\" title=\"十一、排序（共4题）\"></a>十一、排序（共4题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">56. 合并区间</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWFuLWFycmF5L2Rlc2NyaXB0aW9uLw==\">215. 数组中的第K个最大元素</span> <strong>★★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3Atay1mcmVxdWVudC1lbGVtZW50cy9kZXNjcmlwdGlvbi8=\">347. 前 K 个高频元素</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydGVzdC11bnNvcnRlZC1jb250aW51b3VzLXN1YmFycmF5L2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">581. 最短无序连续子数组</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h3 id=\"十二、前缀和（共1题）\"><a href=\"#十二、前缀和（共1题）\" class=\"headerlink\" title=\"十二、前缀和（共1题）\"></a>十二、前缀和（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsvZGVzY3JpcHRpb24v\">560. 和为 K 的子数组</span></li>\n</ul>\n<h3 id=\"十三、字典树-前缀树（共1题）\"><a href=\"#十三、字典树-前缀树（共1题）\" class=\"headerlink\" title=\"十三、字典树&#x2F;前缀树（共1题）\"></a>十三、字典树&#x2F;前缀树（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS9kZXNjcmlwdGlvbi8=\">208. 实现 Trie (前缀树)</span> <strong>★★★</strong></li>\n</ul>\n<h3 id=\"十四、LRU缓存（共1题）\"><a href=\"#十四、LRU缓存（共1题）\" class=\"headerlink\" title=\"十四、LRU缓存（共1题）\"></a>十四、LRU缓存（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUvP2Zhdm9yaXRlPTJja3Rrdmo=\">146. LRU 缓存</span> <strong>★★★</strong></li>\n</ul>\n<h3 id=\"十五、动态规划（共23题，含6道hard题）\"><a href=\"#十五、动态规划（共23题，含6道hard题）\" class=\"headerlink\" title=\"十五、动态规划（共23题，含6道hard题）\"></a>十五、动态规划（共23题，含6道hard题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">10. 正则表达式匹配</span></del>（hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">32. 最长有效括号</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5L2Rlc2NyaXB0aW9uLw==\">53. 最大子数组和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMvZGVzY3JpcHRpb24v\">62. 不同路径</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLz9mYXZvcml0ZT0yY2t0a3Zq\">64. 最小路径和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMvZGVzY3JpcHRpb24v\">70. 爬楼梯</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLz9mYXZvcml0ZT0yY2t0a3Zq\">72. 编辑距离</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy9kZXNjcmlwdGlvbi8=\">96. 不同的二叉搜索树</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrL2Rlc2NyaXB0aW9uLw==\">121. 买卖股票的最佳时机</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrLz9mYXZvcml0ZT0yY2t0a3Zq\">139. 单词拆分</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">152. 乘积最大子数组</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIvZGVzY3JpcHRpb24v\">198. 打家劫舍</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWlpL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">337. 打家劫舍 III</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS9kZXNjcmlwdGlvbi8=\">221. 最大正方形</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJmZWN0LXNxdWFyZXMvZGVzY3JpcHRpb24v\">279. 完全平方数</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">300. 最长递增子序列</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24vP2Zhdm9yaXRlPTJja3Rrdmo=\">309. 最佳买卖股票时机含冷冻期</span> <strong>★★★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8/ZmF2b3JpdGU9MmNrdGt2ag==\">312. 戳气球</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS9kZXNjcmlwdGlvbi8=\">322. 零钱兑换</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS8/ZmF2b3JpdGU9MmNrdGt2ag==\">416. 分割等和子集</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtL2Rlc2NyaXB0aW9uLw==\">494. 目标和</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">647. 回文子串</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy9kZXNjcmlwdGlvbi8=\">5. 最长回文子串</span></li>\n</ul>\n<h3 id=\"十六、滑动窗口（共4题，含2道hard题）\"><a href=\"#十六、滑动窗口（共4题，含2道hard题）\" class=\"headerlink\" title=\"十六、滑动窗口（共4题，含2道hard题）\"></a>十六、滑动窗口（共4题，含2道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzL2Rlc2NyaXB0aW9uLw==\">3. 无重复字符的最长子串</span> <strong>★★★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">76. 最小覆盖子串</span></del>（hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLz9mYXZvcml0ZT0yY2t0a3Zq\">239. 滑动窗口最大值</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">438. 找到字符串中所有字母异位词</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十七、贪心（共1题）\"><a href=\"#十七、贪心（共1题）\" class=\"headerlink\" title=\"十七、贪心（共1题）\"></a>十七、贪心（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUvZGVzY3JpcHRpb24v\">55. 跳跃游戏</span></li>\n</ul>\n<h3 id=\"十八、数学（共1题）\"><a href=\"#十八、数学（共1题）\" class=\"headerlink\" title=\"十八、数学（共1题）\"></a>十八、数学（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uvc29sdXRpb25zLz9mYXZvcml0ZT0yY2t0a3Zq\">48. 旋转图像</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十九、其它（共2题，含1道力扣VIP专属题）\"><a href=\"#十九、其它（共2题，含1道力扣VIP专属题）\" class=\"headerlink\" title=\"十九、其它（共2题，含1道力扣VIP专属题）\"></a>十九、其它（共2题，含1道力扣VIP专属题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWV0aW5nLXJvb21zLWlpLz9mYXZvcml0ZT0yY2t0a3Zq\">253. 会议室 II</span></del>（力扣VIP专属题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci9zb2x1dGlvbnMvP2Zhdm9yaXRlPTJja3Rrdmo=\">621. 任务调度器</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h2 id=\"以下middle题目我暂时跳过了，后面有精力再研究：\"><a href=\"#以下middle题目我暂时跳过了，后面有精力再研究：\" class=\"headerlink\" title=\"以下middle题目我暂时跳过了，后面有精力再研究：\"></a>以下middle题目我暂时跳过了，后面有精力再研究：</h2><ul>\n<li><ol start=\"406\">\n<li>根据身高重建队列</li>\n</ol>\n</li>\n<li><ol start=\"152\">\n<li>乘积最大子数组</li>\n</ol>\n</li>\n<li><ol start=\"416\">\n<li>分割等和子集</li>\n</ol>\n</li>\n<li><ol start=\"337\">\n<li>打家劫舍 III</li>\n</ol>\n</li>\n<li><ol start=\"581\">\n<li>最短无序连续子数组</li>\n</ol>\n</li>\n<li><ol start=\"253\">\n<li>会议室 II</li>\n</ol>\n</li>\n<li><ol start=\"621\">\n<li>任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"常见高频题：\"><a href=\"#常见高频题：\" class=\"headerlink\" title=\"常见高频题：\"></a>常见高频题：</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1zb3J0ZWQtYXJyYXkvZGVzY3JpcHRpb24v\">88. 合并两个有序数组</span>，倒序双指针，类似于 <a href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\">21. 合并两个有序链表</a></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21wcmVzcy1zdHJpbmctbGNjaS9kZXNjcmlwdGlvbi8=\">面试题 01.06. 字符串压缩</span>，类似于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctY29tcHJlc3Npb24vZGVzY3JpcHRpb24v\">443. 压缩字符串</span></li>\n</ul>\n<hr>\n<p><strong>版权声明：</strong> 本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>\n<p><strong>原文链接：</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">https://blog.csdn.net/qq_37102984/article/details/128576283</span> </p>\n",
            "tags": [
                "算法",
                "力扣",
                "LeetCode",
                "刷题"
            ]
        },
        {
            "id": "https://120115.xyz/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E6%95%B4%E7%90%86%E7%89%88/",
            "url": "https://120115.xyz/2025/08/01/leetcodeHot100%E5%88%B7%E9%A2%98%E6%96%B9%E5%BC%8F_%E6%95%B4%E7%90%86%E7%89%88/",
            "title": "力扣算法Hot100刷题路线",
            "date_published": "2025-08-01T02:49:40.465Z",
            "content_html": "<h1 id=\"力扣算法Hot100刷题路线\"><a href=\"#力扣算法Hot100刷题路线\" class=\"headerlink\" title=\"力扣算法Hot100刷题路线\"></a>力扣算法Hot100刷题路线</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>对于算法题，按题型类别刷题才会更有成效，因此我这里在网上搜索并参考了下 <strong>🔥 LeetCode 热题 HOT 100</strong> 的题型归类，并在其基础上做了一定的完善，希望能够记录自己的刷题历程，有所收获！</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">【热题】LeetCode 热题 HOT 100分类+题解</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">leetcode HOT100总结</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">leetcode算法总结 —— HOT 100分类整理</span></li>\n</ul>\n<h3 id=\"刷题说明\"><a href=\"#刷题说明\" class=\"headerlink\" title=\"刷题说明\"></a>刷题说明</h3><ul>\n<li>我这里只做了LeetCode 热题 HOT 100中的 <strong>easy</strong> 和 <strong>middle</strong> 的题，<strong>hard</strong> 的题难度较大暂时都跳过了（题目上都有 <del>删除线</del> 标识），大部分面试也不会考察，后面有精力再做研究。</li>\n<li>题目后带有 <strong>★</strong> 标识的表示后续还要继续反复练习，题目可能不难，但有时可能会忽略其中的一些刷题细节而导致错误</li>\n<li>每一种类型的题目，并不绝对是按照题号递增的顺序来排列的（当然大部分都是按题号大小排好序的）。</li>\n<li>因为有些题目其实很相似，放在一起更好，便单独对他们做了调整，比如 <a href=\"#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\">647. 回文子串</a> 和 <a href=\"#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\">5. 最长回文子串</a></li>\n<li>这里面的每一道题，都有相对应我自己日常整理的题解，具体可参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">我的博客-LeetCode专栏题解</span>，在里面搜对应题号即可 ~</li>\n<li>大家在浏览时，可以通过下方⬇️按题型分类汇总后的【目录】来实现快速跳转，更方便、更快捷的刷题。</li>\n<li>同时这篇文章我也是我花费了很长的时间，对比多篇文章来总结和编写的，希望对大家有所帮助。</li>\n</ul>\n<h2 id=\"文章目录\"><a href=\"#文章目录\" class=\"headerlink\" title=\"文章目录\"></a>文章目录</h2><h3 id=\"一、链表（共11题）\"><a href=\"#一、链表（共11题）\" class=\"headerlink\" title=\"一、链表（共11题）\"></a>一、链表（共11题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMvZGVzY3JpcHRpb24v\">2. 两数相加</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC9kZXNjcmlwdGlvbi8=\">19. 删除链表的倒数第 N 个结点</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLz9mYXZvcml0ZT0yY2t0a3Zq\">21. 合并两个有序链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">23. 合并K个升序链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8/ZmF2b3JpdGU9MmNrdGt2ag==\">141. 环形链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">142. 环形链表 II</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3QvZGVzY3JpcHRpb24v\">148. 排序链表</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8/ZmF2b3JpdGU9MmNrdGt2ag==\">160. 相交链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">206. 反转链表</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">234. 回文链表</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9xdWV1ZS1yZWNvbnN0cnVjdGlvbi1ieS1oZWlnaHQvP2Zhdm9yaXRlPTJja3Rrdmo=\">406. 根据身高重建队列</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h2 id=\"详细题解\"><a href=\"#详细题解\" class=\"headerlink\" title=\"详细题解\"></a>详细题解</h2><h3 id=\"一、链表（共11题）-1\"><a href=\"#一、链表（共11题）-1\" class=\"headerlink\" title=\"一、链表（共11题）\"></a>一、链表（共11题）</h3><h4 id=\"2-两数相加-★\"><a href=\"#2-两数相加-★\" class=\"headerlink\" title=\"2. 两数相加 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMvZGVzY3JpcHRpb24v\">2. 两数相加</span> <strong>★</strong></h4><p>注意分别处理 【相同数位上的两数之和 val1 + val2，并加上上一轮新产生的进位值 carry：sum &#x3D; val1 + val2 + carry】 与 【这一轮新产生的进位值 carry &#x3D; carry &#x2F; 10】。</p>\n<p>并且当两链表 l1 和 l2 都遍历完后，记得额外处理最后的一次进位。例如：99+9&#x3D;108，这里需要单独处理百位最后的1。</p>\n<h4 id=\"19-删除链表的倒数第-N-个结点-★\"><a href=\"#19-删除链表的倒数第-N-个结点-★\" class=\"headerlink\" title=\"19. 删除链表的倒数第 N 个结点 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC9kZXNjcmlwdGlvbi8=\">19. 删除链表的倒数第 N 个结点</span> <strong>★</strong></h4><ul>\n<li>注意 先创建虚拟头节点 dummy，且 dummy.Next &#x3D; head。防止当链表头节点head为待删除节点时，删除该节点后链表头head为空的情况（边界情况）</li>\n<li>如果我们能得到倒数第n个节点的前驱节点而不是倒数第n个节点，那么删除操作会更加方便。因此我们可以考虑在初始时创建 快慢指针 fast和 slow，并将这两个指针指向哑节点 dummy，其余操作不变。这样一来，当 fast遍历到链表末尾时，slow的下一个节点就是我们需要删除的节点。</li>\n<li>快指针先走n步，然后快指针和慢指针再每次各走一步</li>\n<li>删除倒数第n个节点：slow.Next &#x3D; slow.Next.Next，注意不是 slow.Next &#x3D; fast</li>\n<li>最后返回虚拟头节点的后继节点：dummy.Next</li>\n</ul>\n<p>类似题目有：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">237. 删除链表中的节点</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaGFuLWNodS1saWFuLWJpYW8tZGUtamllLWRpYW4tbGNvZi9kZXNjcmlwdGlvbi8=\">剑指 Offer 18. 删除链表的节点</span></li>\n</ul>\n<h4 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tc29ydGVkLWxpc3RzLz9mYXZvcml0ZT0yY2t0a3Zq\">21. 合并两个有序链表</span></h4><p>两种方法：递归 和 迭代 。</p>\n<h4 id=\"23-合并K个升序链表\"><a href=\"#23-合并K个升序链表\" class=\"headerlink\" title=\"23. 合并K个升序链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1rLXNvcnRlZC1saXN0cy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">23. 合并K个升序链表</span></h4><p>在 <a href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\">21. 合并两个有序链表</a> 的基础上，使用</p>\n<ul>\n<li><strong>递归法（推荐，时间复杂度更优）</strong>，参考 LeetCode题解-分治法<ul>\n<li>时间复杂度：O(nlog⁡k)，其中 k 为 lists 的长度，n 为所有链表的节点数之和。每个节点参与链表合并的次数为 O(log⁡k) 次，一共有 n 个节点，所以总的时间复杂度为 O(nlog⁡k)。</li>\n<li>空间复杂度：O(log⁡k) 递归深度为 O(log⁡k)，需要用到 O(log⁡k)的栈空间。</li>\n</ul>\n</li>\n<li><strong>迭代法（不推荐，时间复杂度较高）</strong>：遍历链表数组，两两合并。<ul>\n<li>时间复杂度 O(nk)，时间复杂度高于递归法</li>\n</ul>\n</li>\n</ul>\n<p>有两个细节需要特别注意：</p>\n<ol>\n<li>在方法 mergeKLists()中，初始化链表时，采用如下写法：</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res *ListNode</span><br><span class=\"line\"><span class=\"comment\">// res := &amp;ListNode&#123;&#125; // 错误写法，会初始化res为0值，导致结果集多一个0值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(lists); i++ &#123;</span><br><span class=\"line\">    res = mergeTwoLists(res, lists[i])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>而在方法 mergeTwoLists()中，初始化虚拟节点 head时，则为：</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var head *ListNode // 错误写法 会空指针异常</span></span><br><span class=\"line\">head := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">cur := head</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> head.Next</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8/ZmF2b3JpdGU9MmNrdGt2ag==\">141. 环形链表</span></h4><p>判断快慢指针是否相遇（快指针两步，慢指针一步）</p>\n<h4 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">142. 环形链表 II</span></h4><p>先判断快慢指针是否相遇（快指针两步，慢指针一步），若相遇则将快指针重置到头结点，然后快慢指针每次各走一步，直至相遇</p>\n<h4 id=\"148-排序链表-★\"><a href=\"#148-排序链表-★\" class=\"headerlink\" title=\"148. 排序链表 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3QvZGVzY3JpcHRpb24v\">148. 排序链表</span> <strong>★</strong></h4><p>题目要求时间复杂度为：O(NlogN)，故采用归并排序的思想（拆分→排序→合并）</p>\n<ul>\n<li>先通过快慢指针找到链表中点，并切割为前后两部分</li>\n<li>不断递归上述过程，直至最终将链表切割为多个长度为1的链表</li>\n<li>最后不断合并这多个长度为1的链表（此比较大小并合并的过程，与 <a href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\">21. 合并两个有序链表</a> 一样）</li>\n</ul>\n<h4 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy8/ZmF2b3JpdGU9MmNrdGt2ag==\">160. 相交链表</span></h4><p>用双指针pA 、pB分别遍历两个链表，pA对链表A遍历结束后就去遍历链表B，pB对链表B遍历结束后就遍历链表A。当 pA &#x3D;&#x3D; pB 时，相遇节点即为交点，因为两个指针分别移动的步数是一样的。</p>\n<h4 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">206. 反转链表</span></h4><p>注意go中要用该方式初始化 <code>var pre, mid, end *ListNode = nil, head, nil</code>，而不是 <code>pre, mid, end := &amp;ListNode&#123;&#125;, head, &amp;ListNode&#123;&#125;</code>，否则会在反转后的尾节点添加值为0的 “空节点”，导致错误</p>\n<p>类似题目：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0LWlpL2Rlc2NyaXB0aW9uLw==\">92. 反转链表 II</span>，反转指定区间内的链表</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLW5vZGVzLWluLWstZ3JvdXAvZGVzY3JpcHRpb24v\">25. K 个一组翻转链表</span>，虽然是困难题，但是也是常考的高频题</li>\n</ul>\n<h4 id=\"234-回文链表-★\"><a href=\"#234-回文链表-★\" class=\"headerlink\" title=\"234. 回文链表 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLw==\">234. 回文链表</span> <strong>★</strong></h4><ul>\n<li>先通过快慢指针找链表中点，划分为前半部分和后半部分；注意寻找链表中点时的判断条件：<code>for fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;...&#125;</code></li>\n<li>再反转后半部分链表；</li>\n<li>最后将两部分链表的节点逐个比较</li>\n</ul>\n<h4 id=\"406-根据身高重建队列（middle题，暂时跳过）\"><a href=\"#406-根据身高重建队列（middle题，暂时跳过）\" class=\"headerlink\" title=\"406. 根据身高重建队列（middle题，暂时跳过）\"></a><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9xdWV1ZS1yZWNvbnN0cnVjdGlvbi1ieS1oZWlnaHQvP2Zhdm9yaXRlPTJja3Rrdmo=\">406. 根据身高重建队列</span></del>（middle题，暂时跳过）</h4><h3 id=\"二、二叉树（共14题，含2道hard题）\"><a href=\"#二、二叉树（共14题，含2道hard题）\" class=\"headerlink\" title=\"二、二叉树（共14题，含2道hard题）\"></a>二、二叉树（共14题，含2道hard题）</h3><p><strong>做题心得：</strong></p>\n<ul>\n<li>处理递归，核心就是千万不要想子问题的过程，你脑子能处理几层？马上就绕迷糊了。要想子问题的结果，思路就清晰了</li>\n<li>是的，只要代码的边界条件和非边界条件的逻辑写对了，其他的事情交给数学归纳法就好了。也就是说，写对了这两个逻辑，你的代码自动就是正确的了，没必要想递归是怎么一层一层走的。</li>\n<li>跟树相关的题，一般有两种解法：递归&amp;迭代：递归用dfs，而迭代用bfs（队列）</li>\n<li>Go 语言的深度优先遍历算法可以采用闭包函数实现，这样省去了许多参数的传递与全局变量的声明。</li>\n</ul>\n<p>另外，关于递归，看到该题讨论区有一个评论，对于递归的理解很有帮助，特意截图留念。</p>\n<h4 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8/ZmF2b3JpdGU9MmNrdGt2ag==\">94. 二叉树的中序遍历</span></h4><ul>\n<li>递归 or 迭代（利用栈的先进后出特性），必会</li>\n</ul>\n<p>类似题目：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24v\">144. 二叉树的前序遍历</span> 利用栈，类似于中序遍历</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsL2Rlc2NyaXB0aW9uLw==\">145. 二叉树的后序遍历</span> 利用栈，有一个标记根节点的flagMap，用来标记第几次经过某个根节点root，只有第二次经过某个根节点时，才存储其结果，并将其出栈置空。</li>\n</ul>\n<h4 id=\"98-验证二叉搜索树-★★★\"><a href=\"#98-验证二叉搜索树-★★★\" class=\"headerlink\" title=\"98. 验证二叉搜索树 ★★★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUvP2Zhdm9yaXRlPTJja3Rrdmo=\">98. 验证二叉搜索树</span> <strong>★★★</strong></h4><p>利用二叉搜索树的中序遍历为升序序列这一性质，来递归验证。</p>\n<p><strong>方法一：</strong> 官方题解 通过限制每个子树中的上下界（lower和upper）来判断，需额外引入常量：math.MinInt64, math.MaxInt64，不推荐，也没必要。</p>\n<p><strong>方法二：</strong> 双指针比较法（pre和node），参考 B站视频题解，不需额外引入常量，而只需通过一个pre指针，在向上回溯的过程中，不断保存之前的节点用于比较。</p>\n<ul>\n<li>首先【不断向左子树递归】直至最后空节点：<code>left := dfs(node.Left)</code></li>\n<li>然后再自底向上【回溯】的过程中，pre每次保存的都是之前上一层栈空间中的根节点，并不断将当前node节点和pre节点的值做比较：<code>if pre != nil &amp;&amp; node.Val &lt;= pre.Val &#123; return false &#125;</code><ul>\n<li>当 node &#x3D; root 时，pre &#x3D; root.Left，pre的值应永远小于node的值（满足二叉搜索树中，左子节点值 &lt; 根节点值）</li>\n<li>当 node &#x3D; root.Right时，pre &#x3D; root，pre的值应永远小于node的值（满足二叉搜索树中，根节点值 &lt; 右子节点值）</li>\n</ul>\n</li>\n<li>保存当前节点node到pre中，用于下层递归中做比较</li>\n<li>然后不断向右子树递归：<code>right := dfs(node.Right)</code></li>\n<li>最后返回：<code>return left &amp;&amp; right</code>，判断当前节点的左右子树是否分别是二叉搜索树</li>\n</ul>\n<h4 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS9kZXNjcmlwdGlvbi8=\">101. 对称二叉树</span></h4><p><strong>解法1 递归：</strong></p>\n<ul>\n<li>if 左节点和右节点均为空，说明遍历完了，返回 true</li>\n<li>否则说明左右两个节点并非同时为空，那么判断：if 左节点和右节点其中一个为空（也就是一个为空，一个非空，那肯定不对称），或者左节点值不等于右节点值（不对称），返回 false</li>\n<li>最后继续递归下探：<br><code>return recur(左节点的左子节点，右节点的右子节点) &amp;&amp; recur(左节点的右子节点，右节点的左子节点)</code></li>\n</ul>\n<p><strong>解法2 迭代：</strong><br>层序遍历：通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，其中的条件判断和递归的逻辑是一样的。</p>\n<h4 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">102. 二叉树的层序遍历</span></h4><p>BFS层序遍历使用 queue 队列（先进先出）</p>\n<ul>\n<li>初始化队列，并将非空根节点 root入队</li>\n<li>判断队列大小是否非零，非零则进入外层for循环 <code>for len(queue) &gt; 0 &#123;</code><ul>\n<li>由于需要按层返回二维数组结果集，因此要提前缓存当前这一层的节点数 <code>length := len(queue)</code>，并创建用于保存这一层结果的临时数组 subRes。</li>\n<li>进入内循环 <code>for i := 0; i &lt; length; i++ &#123;</code><ul>\n<li>获取队头节点 root &#x3D; queue[0]，将其 root.Val值保存到临时数组 subRes中，再将该节点出队（它的使命已完成）</li>\n<li>将 root的非空左子节点 root.Left和非空右子节点 root.Right入队</li>\n</ul>\n</li>\n<li>将保存当前这一层结果集的临时数组 subRes追加到二维数组 res中</li>\n</ul>\n</li>\n<li>返回保存最终结果集的二维数组 res</li>\n</ul>\n<h4 id=\"104-二叉树的最大深度-★\"><a href=\"#104-二叉树的最大深度-★\" class=\"headerlink\" title=\"104. 二叉树的最大深度 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==\">104. 二叉树的最大深度</span> <strong>★</strong></h4><ul>\n<li>递归法（dfs）</li>\n<li>迭代法（bfs）：利用队列（先进先出）。内层for循环保留上一层节点数，避免内层循环因为对queue进行append操作，导致队列元素个数发生变化</li>\n</ul>\n<h4 id=\"105-从前序与中序遍历序列构造二叉树-★★★\"><a href=\"#105-从前序与中序遍历序列构造二叉树-★★★\" class=\"headerlink\" title=\"105. 从前序与中序遍历序列构造二叉树 ★★★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24v\">105. 从前序与中序遍历序列构造二叉树</span> <strong>★★★</strong></h4><p>推荐掌握递归法，迭代法比较难理解，不过都需要作图理解和推敲：左右子树分别在 前序&#x2F;中序 遍历中的左右边界。</p>\n<p><strong>递归法：</strong><br>先通过遍历inorder数组，找到根节点（值为preorder[0]）位于中序遍历中的下标位置 i。然后，根据中序遍历中根节点的下标位置 i，分别构建root的左右子树 …</p>\n<ol>\n<li>分别确定”左子树”在前序和中序遍历中的左右边界<ul>\n<li>确定前序遍历中左子树的左右边界：<ul>\n<li>root &#x3D; preorder[0]是根节点，所以前序遍历中左子树的左边界是1；</li>\n<li>然后根据根节点在中序遍历中的下标 i，可知【中序遍历中左子树的范围是0~ i】，由此可确定中序遍历中左子树的长度是 i（其实 i 的值也等于 len(inorder[:i])，但为了便于理解及简化代码量，就使用 i 来作为左子树的长度），又因为前序遍历中左子树的左边界为1，所以可得前序遍历中左子树的右边界为：i+1（或 len(inorder[:i])+1）</li>\n</ul>\n</li>\n<li>确定中序遍历中左子树的左右边界：由上面的分析中的【中序遍历中左子树的范围是0~ i】可得：inorder[:i]</li>\n</ul>\n</li>\n</ol>\n<p>最后可得：<code>root.Left = buildTree(preorder[1:i+1], inorder[:i])</code></p>\n<ol start=\"2\">\n<li>分别确定”右子树”在前序和中序遍历中的左右边界<ul>\n<li>确定前序遍历中右子树的左右边界：<ul>\n<li>由 1.1 可知当前左子树的长度是 i（其实 i 的值也等于 len(inorder[:i])，但为了便于理解及简化代码量，就使用 i 来作为左子树的长度），且根节点也占一个位置，因此可得前序遍历中右子树的左边界为：i+1（或 len(inorder[:i])+1），右子树右边界一直到preorder末尾</li>\n</ul>\n</li>\n<li>确定中序遍历中右子树的左右边界：<ul>\n<li>由于之前已经找出根节点位于中序遍历中的下标位置是 i，所以 i+1就是中序遍历中右子树的左边界，右边界一直到inorder末尾</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>最后可得：<code>root.Right = buildTree(preorder[i+1:], inorder[i+1:])</code></p>\n<p><strong>迭代法：</strong><br>preorder第一个元素为root，在inorder里面找到root，在它之前的为左子树（长l1），之后为右子树（长l2）。preorder[1]到preorder[l1]为左子树,之后为右子树，分别递归。</p>\n<p>主要难点在于需要分别确定前序遍历和中序遍历中的左右子树的左右边界对应关系。</p>\n<h4 id=\"114-二叉树展开为链表-★★★\"><a href=\"#114-二叉树展开为链表-★★★\" class=\"headerlink\" title=\"114. 二叉树展开为链表 ★★★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lz9mYXZvcml0ZT0yY2t0a3Zq\">114. 二叉树展开为链表</span> <strong>★★★</strong></h4><ul>\n<li><strong>方法1：</strong> 先前序遍历 获得各节点被访问到的顺序，然后更新每个节点的左右子节点的信息，将二叉树展开为单链表。</li>\n<li><strong>方法2：</strong> 没理解这个递归逻辑，继续研究</li>\n</ul>\n<h4 id=\"124-二叉树中的最大路径和（hard题，暂时跳过）\"><a href=\"#124-二叉树中的最大路径和（hard题，暂时跳过）\" class=\"headerlink\" title=\"124. 二叉树中的最大路径和（hard题，暂时跳过）\"></a><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">124. 二叉树中的最大路径和</span></del>（hard题，暂时跳过）</h4><h4 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">226. 翻转二叉树</span></h4><h4 id=\"236-二叉树的最近公共祖先-★\"><a href=\"#236-二叉树的最近公共祖先-★\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24v\">236. 二叉树的最近公共祖先</span> <strong>★</strong></h4><p>求最小公共祖先，需要从底向上遍历。那么二叉树 只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</p>\n<h4 id=\"297-二叉树的序列化与反序列化（hard题，暂时跳过）\"><a href=\"#297-二叉树的序列化与反序列化（hard题，暂时跳过）\" class=\"headerlink\" title=\"297. 二叉树的序列化与反序列化（hard题，暂时跳过）\"></a><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLz9mYXZvcml0ZT0yY2t0a3Zq\">297. 二叉树的序列化与反序列化</span></del>（hard题，暂时跳过）</h4><h4 id=\"538-把二叉搜索树转换为累加树-★\"><a href=\"#538-把二叉搜索树转换为累加树-★\" class=\"headerlink\" title=\"538. 把二叉搜索树转换为累加树 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUvZGVzY3JpcHRpb24v\">538. 把二叉搜索树转换为累加树</span> <strong>★</strong></h4><p>以 反中序遍历（右中左）的方式不断累加并更新每个节点值即可</p>\n<h4 id=\"543-二叉树的直径-★\"><a href=\"#543-二叉树的直径-★\" class=\"headerlink\" title=\"543. 二叉树的直径 ★\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS9kZXNjcmlwdGlvbi8=\">543. 二叉树的直径</span> <strong>★</strong></h4><p>【前序遍历】思想：任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>\n<h4 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLz9mYXZvcml0ZT0yY2t0a3Zq\">617. 合并二叉树</span></h4><p>可用两种方式操作树：原地修改 or 新建树</p>\n<p><strong>新版 hot100 题目扩充（以下题目列表不断更新ing~）：</strong></p>\n<h4 id=\"LeetCode-108-将有序数组转换为二叉搜索树\"><a href=\"#LeetCode-108-将有序数组转换为二叉搜索树\" class=\"headerlink\" title=\"LeetCode 108. 将有序数组转换为二叉搜索树\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUvZGVzY3JpcHRpb24v\">LeetCode 108. 将有序数组转换为二叉搜索树</span></h4><ul>\n<li><p>二叉搜索树BST 的【中序遍历】是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树</p>\n</li>\n<li><p>虽然我们可以以升序序列中的任一个元素作为根节点</p>\n</li>\n<li><p>但是因为本题要求【高度平衡】，因此我们需要选择升序序列的【中间元素】作为根节点奥～</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8/ZmF2b3JpdGU9MmNrdGt2ag==\">94. 二叉树的中序遍历</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUvP2Zhdm9yaXRlPTJja3Rrdmo=\">98. 验证二叉搜索树</span> <strong>★★★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS9kZXNjcmlwdGlvbi8=\">101. 对称二叉树</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">102. 二叉树的层序遍历</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==\">104. 二叉树的最大深度</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwvZGVzY3JpcHRpb24v\">105. 从前序与中序遍历序列构造二叉树</span> <strong>★★★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lz9mYXZvcml0ZT0yY2t0a3Zq\">114. 二叉树展开为链表</span> <strong>★★★</strong></p>\n</li>\n<li><p><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1tYXhpbXVtLXBhdGgtc3VtL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">124. 二叉树中的最大路径和</span></del>（hard题，暂时跳过）</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">226. 翻转二叉树</span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUvZGVzY3JpcHRpb24v\">236. 二叉树的最近公共祖先</span> <strong>★</strong></p>\n</li>\n<li><p><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXJpYWxpemUtYW5kLWRlc2VyaWFsaXplLWJpbmFyeS10cmVlLz9mYXZvcml0ZT0yY2t0a3Zq\">297. 二叉树的序列化与反序列化</span></del>（hard题，暂时跳过）</p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LWJzdC10by1ncmVhdGVyLXRyZWUvZGVzY3JpcHRpb24v\">538. 把二叉搜索树转换为累加树</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFtZXRlci1vZi1iaW5hcnktdHJlZS9kZXNjcmlwdGlvbi8=\">543. 二叉树的直径</span> <strong>★</strong></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLz9mYXZvcml0ZT0yY2t0a3Zq\">617. 合并二叉树</span></p>\n</li>\n</ul>\n<p><strong>新版 hot100 题目扩充（以下题目列表不断更新ing~）：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1hcnJheS10by1iaW5hcnktc2VhcmNoLXRyZWUvZGVzY3JpcHRpb24v\">LeetCode 108. 将有序数组转换为二叉搜索树</span></li>\n</ul>\n<h3 id=\"三、DFS-BFS（共6题，含3道hard题）\"><a href=\"#三、DFS-BFS（共6题，含3道hard题）\" class=\"headerlink\" title=\"三、DFS&#x2F;BFS（共6题，含3道hard题）\"></a>三、DFS&#x2F;BFS（共6题，含3道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC9kZXNjcmlwdGlvbi8=\">79. 单词搜索</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXJlY3RhbmdsZS8/ZmF2b3JpdGU9MmNrdGt2ag==\">85. 最大矩形</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy9kZXNjcmlwdGlvbi8=\">200. 岛屿数量</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3Vyc2Utc2NoZWR1bGUvP2Zhdm9yaXRlPTJja3Rrdmo=\">207. 课程表</span></del> （hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtaW52YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">301. 删除无效的括号</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb25zLw==\">437. 路径总和 III</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"四、递归-回溯（共6题，含1道hard题）\"><a href=\"#四、递归-回溯（共6题，含1道hard题）\" class=\"headerlink\" title=\"四、递归&#x2F;回溯（共6题，含1道hard题）\"></a>四、递归&#x2F;回溯（共6题，含1道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">17. 电话号码的字母组合</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=\">22. 括号生成</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0vZGVzY3JpcHRpb24v\">39. 组合总和</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMvP2Zhdm9yaXRlPTJja3Rrdmo=\">46. 全排列</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzL2Rlc2NyaXB0aW9uLw==\">78. 子集</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1kaXZpc2lvbi9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">399. 除法求值</span></del> （hard题，暂时跳过）</li>\n</ul>\n<h3 id=\"五、Hash表-map（共3题）\"><a href=\"#五、Hash表-map（共3题）\" class=\"headerlink\" title=\"五、Hash表&#x2F;map（共3题）\"></a>五、Hash表&#x2F;map（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtL2Rlc2NyaXB0aW9uLw==\">1. 两数之和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy9kZXNjcmlwdGlvbi8=\">49. 字母异位词分组</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">128. 最长连续序列</span></li>\n</ul>\n<h3 id=\"六、位运算（共3题）\"><a href=\"#六、位运算（共3题）\" class=\"headerlink\" title=\"六、位运算（共3题）\"></a>六、位运算（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">136. 只出现一次的数字</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudGluZy1iaXRzL2Rlc2NyaXB0aW9uLw==\">338. 比特位计数</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYW1taW5nLWRpc3RhbmNlL2Rlc2NyaXB0aW9uLw==\">461. 汉明距离</span></li>\n</ul>\n<h3 id=\"七、数组（共5题）\"><a href=\"#七、数组（共5题）\" class=\"headerlink\" title=\"七、数组（共5题）\"></a>七、数组（共5题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">15. 三数之和</span></del> 待研究</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LXBlcm11dGF0aW9uL2Rlc2NyaXB0aW9uLw==\">31. 下一个排列</span> <strong>★★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50L2Rlc2NyaXB0aW9uLw==\">169. 多数元素</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmL2Rlc2NyaXB0aW9uLw==\">238. 除自身以外数组的乘积</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1udW1iZXJzLWRpc2FwcGVhcmVkLWluLWFuLWFycmF5L2Rlc2NyaXB0aW9uLw==\">448. 找到所有数组中消失的数字</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"八、二分查找（共5题，含1道hard题）\"><a href=\"#八、二分查找（共5题，含1道hard题）\" class=\"headerlink\" title=\"八、二分查找（共5题，含1道hard题）\"></a>八、二分查找（共5题，含1道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWRpYW4tb2YtdHdvLXNvcnRlZC1hcnJheXMvZGVzY3JpcHRpb24v\">4. 寻找两个正序数组的中位数</span> （hard题）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkvZGVzY3JpcHRpb24v\">33. 搜索旋转排序数组</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWFycmF5L2Rlc2NyaXB0aW9uLw==\">34. 在排序数组中查找元素的第一个和最后一个位置</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgtaWkvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">240. 搜索二维矩阵 II</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kdXBsaWNhdGUtbnVtYmVyL2Rlc2NyaXB0aW9uLw==\">287. 寻找重复数</span> <strong>★★</strong></li>\n</ul>\n<p><strong>新版 hot100 题目扩充（以下题目列表不断更新ing~）：</strong></p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW5zZXJ0LXBvc2l0aW9uL2Rlc2NyaXB0aW9uLw==\">LeetCode 35. 搜索插入位置</span></li>\n</ul>\n<h3 id=\"九、双指针-三指针（共3题）\"><a href=\"#九、双指针-三指针（共3题）\" class=\"headerlink\" title=\"九、双指针&#x2F;三指针（共3题）\"></a>九、双指针&#x2F;三指针（共3题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyL2Rlc2NyaXB0aW9uLw==\">11. 盛最多水的容器</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy9kZXNjcmlwdGlvbi8=\">75. 颜色分类</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy9kZXNjcmlwdGlvbi8=\">283. 移动零</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十、栈-单调栈（共6题，含2道hard题）\"><a href=\"#十、栈-单调栈（共6题，含2道hard题）\" class=\"headerlink\" title=\"十、栈&#x2F;单调栈（共6题，含2道hard题）\"></a>十、栈&#x2F;单调栈（共6题，含2道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8=\">20. 有效的括号</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLz9mYXZvcml0ZT0yY2t0a3Zq\">42. 接雨水</span></del> （hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vP2Zhdm9yaXRlPTJja3Rrdmo=\">84. 柱状图中最大的矩形</span></del> （hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2svZGVzY3JpcHRpb24v\">155. 最小栈</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL2Rlc2NyaXB0aW9uLw==\">394. 字符串解码</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kYWlseS10ZW1wZXJhdHVyZXMvZGVzY3JpcHRpb24v\">739. 每日温度</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十一、排序（共4题）\"><a href=\"#十一、排序（共4题）\" class=\"headerlink\" title=\"十一、排序（共4题）\"></a>十一、排序（共4题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">56. 合并区间</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWFuLWFycmF5L2Rlc2NyaXB0aW9uLw==\">215. 数组中的第K个最大元素</span> <strong>★★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3Atay1mcmVxdWVudC1lbGVtZW50cy9kZXNjcmlwdGlvbi8=\">347. 前 K 个高频元素</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydGVzdC11bnNvcnRlZC1jb250aW51b3VzLXN1YmFycmF5L2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">581. 最短无序连续子数组</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h3 id=\"十二、前缀和（共1题）\"><a href=\"#十二、前缀和（共1题）\" class=\"headerlink\" title=\"十二、前缀和（共1题）\"></a>十二、前缀和（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsvZGVzY3JpcHRpb24v\">560. 和为 K 的子数组</span></li>\n</ul>\n<h3 id=\"十三、字典树-前缀树（共1题）\"><a href=\"#十三、字典树-前缀树（共1题）\" class=\"headerlink\" title=\"十三、字典树&#x2F;前缀树（共1题）\"></a>十三、字典树&#x2F;前缀树（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS9kZXNjcmlwdGlvbi8=\">208. 实现 Trie (前缀树)</span> <strong>★★★</strong></li>\n</ul>\n<h3 id=\"十四、LRU缓存（共1题）\"><a href=\"#十四、LRU缓存（共1题）\" class=\"headerlink\" title=\"十四、LRU缓存（共1题）\"></a>十四、LRU缓存（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUvP2Zhdm9yaXRlPTJja3Rrdmo=\">146. LRU 缓存</span> <strong>★★★</strong></li>\n</ul>\n<h3 id=\"十五、动态规划（共23题，含6道hard题）\"><a href=\"#十五、动态规划（共23题，含6道hard题）\" class=\"headerlink\" title=\"十五、动态规划（共23题，含6道hard题）\"></a>十五、动态规划（共23题，含6道hard题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWd1bGFyLWV4cHJlc3Npb24tbWF0Y2hpbmcvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">10. 正则表达式匹配</span></del>（hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">32. 最长有效括号</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5L2Rlc2NyaXB0aW9uLw==\">53. 最大子数组和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMvZGVzY3JpcHRpb24v\">62. 不同路径</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLz9mYXZvcml0ZT0yY2t0a3Zq\">64. 最小路径和</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbGltYmluZy1zdGFpcnMvZGVzY3JpcHRpb24v\">70. 爬楼梯</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLz9mYXZvcml0ZT0yY2t0a3Zq\">72. 编辑距离</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy9kZXNjcmlwdGlvbi8=\">96. 不同的二叉搜索树</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrL2Rlc2NyaXB0aW9uLw==\">121. 买卖股票的最佳时机</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrLz9mYXZvcml0ZT0yY2t0a3Zq\">139. 单词拆分</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">152. 乘积最大子数组</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIvZGVzY3JpcHRpb24v\">198. 打家劫舍</span></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXItaWlpL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">337. 打家劫舍 III</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWFsLXNxdWFyZS9kZXNjcmlwdGlvbi8=\">221. 最大正方形</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJmZWN0LXNxdWFyZXMvZGVzY3JpcHRpb24v\">279. 完全平方数</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24v\">300. 最长递增子序列</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLXdpdGgtY29vbGRvd24vP2Zhdm9yaXRlPTJja3Rrdmo=\">309. 最佳买卖股票时机含冷冻期</span> <strong>★★★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8/ZmF2b3JpdGU9MmNrdGt2ag==\">312. 戳气球</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS9kZXNjcmlwdGlvbi8=\">322. 零钱兑换</span> <strong>★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tZXF1YWwtc3Vic2V0LXN1bS8/ZmF2b3JpdGU9MmNrdGt2ag==\">416. 分割等和子集</span></del>（middle题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXJnZXQtc3VtL2Rlc2NyaXB0aW9uLw==\">494. 目标和</span> <strong>★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzL2Rlc2NyaXB0aW9uLz9mYXZvcml0ZT0yY2t0a3Zq\">647. 回文子串</span> <strong>★★</strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy9kZXNjcmlwdGlvbi8=\">5. 最长回文子串</span></li>\n</ul>\n<h3 id=\"十六、滑动窗口（共4题，含2道hard题）\"><a href=\"#十六、滑动窗口（共4题，含2道hard题）\" class=\"headerlink\" title=\"十六、滑动窗口（共4题，含2道hard题）\"></a>十六、滑动窗口（共4题，含2道hard题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzL2Rlc2NyaXB0aW9uLw==\">3. 无重复字符的最长子串</span> <strong>★★★</strong></li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcvZGVzY3JpcHRpb24vP2Zhdm9yaXRlPTJja3Rrdmo=\">76. 最小覆盖子串</span></del>（hard题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLz9mYXZvcml0ZT0yY2t0a3Zq\">239. 滑动窗口最大值</span></del>（hard题，暂时跳过）</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWFsbC1hbmFncmFtcy1pbi1hLXN0cmluZy9kZXNjcmlwdGlvbi8/ZmF2b3JpdGU9MmNrdGt2ag==\">438. 找到字符串中所有字母异位词</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十七、贪心（共1题）\"><a href=\"#十七、贪心（共1题）\" class=\"headerlink\" title=\"十七、贪心（共1题）\"></a>十七、贪心（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUvZGVzY3JpcHRpb24v\">55. 跳跃游戏</span></li>\n</ul>\n<h3 id=\"十八、数学（共1题）\"><a href=\"#十八、数学（共1题）\" class=\"headerlink\" title=\"十八、数学（共1题）\"></a>十八、数学（共1题）</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uvc29sdXRpb25zLz9mYXZvcml0ZT0yY2t0a3Zq\">48. 旋转图像</span> <strong>★</strong></li>\n</ul>\n<h3 id=\"十九、其它（共2题，含1道力扣VIP专属题）\"><a href=\"#十九、其它（共2题，含1道力扣VIP专属题）\" class=\"headerlink\" title=\"十九、其它（共2题，含1道力扣VIP专属题）\"></a>十九、其它（共2题，含1道力扣VIP专属题）</h3><ul>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZWV0aW5nLXJvb21zLWlpLz9mYXZvcml0ZT0yY2t0a3Zq\">253. 会议室 II</span></del>（力扣VIP专属题，暂时跳过）</li>\n<li><del><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90YXNrLXNjaGVkdWxlci9zb2x1dGlvbnMvP2Zhdm9yaXRlPTJja3Rrdmo=\">621. 任务调度器</span></del>（middle题，暂时跳过）</li>\n</ul>\n<h2 id=\"以下middle题目我暂时跳过了，后面有精力再研究：\"><a href=\"#以下middle题目我暂时跳过了，后面有精力再研究：\" class=\"headerlink\" title=\"以下middle题目我暂时跳过了，后面有精力再研究：\"></a>以下middle题目我暂时跳过了，后面有精力再研究：</h2><ul>\n<li><ol start=\"406\">\n<li>根据身高重建队列</li>\n</ol>\n</li>\n<li><ol start=\"152\">\n<li>乘积最大子数组</li>\n</ol>\n</li>\n<li><ol start=\"416\">\n<li>分割等和子集</li>\n</ol>\n</li>\n<li><ol start=\"337\">\n<li>打家劫舍 III</li>\n</ol>\n</li>\n<li><ol start=\"581\">\n<li>最短无序连续子数组</li>\n</ol>\n</li>\n<li><ol start=\"253\">\n<li>会议室 II</li>\n</ol>\n</li>\n<li><ol start=\"621\">\n<li>任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"常见高频题：\"><a href=\"#常见高频题：\" class=\"headerlink\" title=\"常见高频题：\"></a>常见高频题：</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1zb3J0ZWQtYXJyYXkvZGVzY3JpcHRpb24v\">88. 合并两个有序数组</span>，倒序双指针，类似于 <a href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\">21. 合并两个有序链表</a></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21wcmVzcy1zdHJpbmctbGNjaS9kZXNjcmlwdGlvbi8=\">面试题 01.06. 字符串压缩</span>，类似于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctY29tcHJlc3Npb24vZGVzY3JpcHRpb24v\">443. 压缩字符串</span></li>\n</ul>\n<hr>\n<p><strong>版权声明：</strong> 本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p>\n<p><strong>原文链接：</strong> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjg1NzYyODM=\">https://blog.csdn.net/qq_37102984/article/details/128576283</span> </p>\n",
            "tags": [
                "算法",
                "力扣",
                "LeetCode",
                "刷题"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "https://120115.xyz/2025/07/21/java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "java高频面试题",
            "date_published": "2025-07-20T16:00:00.000Z",
            "content_html": "<h2 id=\"JavaSE\"><a href=\"#JavaSE\" class=\"headerlink\" title=\"JavaSE\"></a>JavaSE</h2><h3 id=\"1-什么是JAVA\"><a href=\"#1-什么是JAVA\" class=\"headerlink\" title=\"1. 什么是JAVA?\"></a>1. 什么是JAVA?</h3><p>Java 是一门面向对象的编程语言，吸收了 C++ 语言中大量的优点，但又抛弃了 C++ 中容易出错的地方，如垃圾回收、指针。比较重要的特点就是跨平台性，只需要在对应的平台上安装 JDK，就可以实现跨平台，在 Windows、macOS、Linux 操作系统上运行。还有面向对象、多线程，JVM等这些让Java变得高效。Java最适合用来做后端开发，有很多成熟的技术栈，比如Springboot,springcloud等。</p>\n<h3 id=\"2-Java-有哪些数据类型？\"><a href=\"#2-Java-有哪些数据类型？\" class=\"headerlink\" title=\"2. Java 有哪些数据类型？\"></a>2. Java 有哪些数据类型？</h3><p>基本数据类型和引用数据类型两大类。基本数据类型有：数值型（byte,short,int,long）、浮点型(float,double)、布尔型boolean。引用数据类型有类，数组和接口。</p>\n<h3 id=\"3-面向对象编程有哪些特性？\"><a href=\"#3-面向对象编程有哪些特性？\" class=\"headerlink\" title=\"3. 面向对象编程有哪些特性？\"></a>3. 面向对象编程有哪些特性？</h3><p>封装、继承和多态。封装就是把一些属性和方法捆在一起形成一个类，我们可以实例化这个类变成对象，对象可以设置和获取属性，调用方法。开发中就是对象之间的交互。继承就是子类获得父类的所有属性和方法，子类还可以进行扩充或者方法重写。多态就是java运行时可以根据对象类型产生不同的结果。子类需要继承父类并重写父类方法，父类引用指向子类对象。</p>\n<h3 id=\"4-抽象类和接口有什么区别？\"><a href=\"#4-抽象类和接口有什么区别？\" class=\"headerlink\" title=\"4. 抽象类和接口有什么区别？\"></a>4. 抽象类和接口有什么区别？</h3><p>一个类只能继承一个抽象类；但一个类可以实现多个接口。比如我们创建线程类的时候一般用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。抽象类符合 is-a 的关系，而接口更像是 has-a 的关系。比如说一个类可以序列化的时候，它只需要实现 Serializable 接口，代表它有这个功能，而不是继承一个序列化类。</p>\n<h3 id=\"5-和-equals-的区别？\"><a href=\"#5-和-equals-的区别？\" class=\"headerlink\" title=\"5. &#x3D;&#x3D;和 equals 的区别？\"></a>5. &#x3D;&#x3D;和 equals 的区别？</h3><p>&#x3D;&#x3D; 操作符和 equals() 方法用于比较两个对象：&#x3D;&#x3D;比较两个对象的引用，也就是说在内存中是不是同一份数据。对于基本数据类型（如 int, double, char 等），&#x3D;&#x3D; 比较的是值是否相等。equals比较的是两个对象的内容是否相等，默认跟&#x3D;&#x3D;相同，我们一般会对他重写来用于比较值（比如属性）是否相同而不是引用。</p>\n<h3 id=\"6-为什么重写-equals-时必须重写-hashCode-⽅法？\"><a href=\"#6-为什么重写-equals-时必须重写-hashCode-⽅法？\" class=\"headerlink\" title=\"6. 为什么重写 equals 时必须重写 hashCode ⽅法？\"></a>6. 为什么重写 equals 时必须重写 hashCode ⽅法？</h3><p>因为基于哈希的集合类（如 HashMap）需要使用hashCode和equals方法来存储和查找对象。存储时首先根据键的hashCode计算出在数组中的存储位置，每个位置可以存单个值、链表和红黑树，如果没有重写hashCode方法，两个相同的键可能出现不同的hashCode导致它们被存在数组中的不同位置，获取时就发生错误。发生哈希冲突时，键会被存在数组的同一个桶中，通过链表和红黑树解决哈希冲突问题，发生哈希冲突的桶中元素的hashCode值相同，必须再用equals比较值才能找出对应元素，如果没有重写equals()方法就找不到需要的元素。</p>\n<h3 id=\"7-String-和-StringBuilder、StringBuffer-的区别？\"><a href=\"#7-String-和-StringBuilder、StringBuffer-的区别？\" class=\"headerlink\" title=\"7. String 和 StringBuilder、StringBuffer 的区别？\"></a>7. String 和 StringBuilder、StringBuffer 的区别？</h3><p>它们都是用于处理字符串的，String底层用了final修饰是不可变的，每次修改都会创建一个新对象，开销很大，如果要频繁修改字符串可以用StringBuilder，它是在原对象上修改。StringBuffer跟StringBuilder相似，但是它的方法上都加了 synchronized 关键字，是线程安全的，这在单线程下效率比较低。</p>\n<h3 id=\"8-Java-中异常处理体系\"><a href=\"#8-Java-中异常处理体系\" class=\"headerlink\" title=\"8. Java 中异常处理体系?\"></a>8. Java 中异常处理体系?</h3><p>主要有两大类，错误和异常，错误指的是程序无法处理的严重错误，比如内存溢出，栈溢出，这些错误通常与 JVM 的运行状态有关。异常分为编译时异常和运行时异常，编译时异常可以被try-catch捕获处理或者throws抛出，比如IOException、SQLException，运行时异常通常是代码逻辑错误，比如数组越界，空指针等。</p>\n<h3 id=\"9-BIO、NIO、AIO-之间的区别？\"><a href=\"#9-BIO、NIO、AIO-之间的区别？\" class=\"headerlink\" title=\"9. BIO、NIO、AIO 之间的区别？\"></a>9. BIO、NIO、AIO 之间的区别？</h3><p>BIO：采用阻塞式 I&#x2F;O 模型，基于字节流或字符流文件读写，基于 Socket 和 ServerSocket 进行网络通信，适用于连接数较少的场景，每个连接，都需要创建一个单独的线程来处理读写操作。<br>NIO：采用非阻塞 I&#x2F;O 模型，线程在等待 I&#x2F;O 时可执行其他任务，主要用在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，适用于连接数多但连接时间短的场景。<br>AIO：使用异步 I&#x2F;O 模型，线程发起 I&#x2F;O 请求后立即返回，不需要等待，当 I&#x2F;O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p>\n<h3 id=\"10-🌟什么是反射？应用？原理？\"><a href=\"#10-🌟什么是反射？应用？原理？\" class=\"headerlink\" title=\"10. 🌟什么是反射？应用？原理？\"></a>10. 🌟什么是反射？应用？原理？</h3><p>反射就是在运行时动态地获取类的信息，然后使用它的属性和方法的技术。Spring 框架动态加载和管理 Bean、AOP的动态代理，还有Junit测试框架这些都用到了反射，我们可以用Class.forName通过类名获取一个类，然后调用newInstance方法创建实例对象，getMethod，invoke方法可以获取和调用方法，getDeclaredField可以获取属性，对于私有属性可以调用setAccessible(true); 让它可见。原理就是Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p>\n<h2 id=\"Java集合\"><a href=\"#Java集合\" class=\"headerlink\" title=\"Java集合\"></a>Java集合</h2><h3 id=\"1-常见集合有哪些？\"><a href=\"#1-常见集合有哪些？\" class=\"headerlink\" title=\"1. 常见集合有哪些？\"></a>1. 常见集合有哪些？</h3><p>集合有两大类，Collection 接口和Map 接口。Collection 接口下有List、Set,和Queue, List包含有序可重复的元素。实现类包括 ArrayList、LinkedList。Set是无序不重复的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。Queue是队列。实现类包括 PriorityQueue、ArrayDeque 等。Map 是表示键值对的集合。键不能重复。实现类包括 HashMap、LinkedHashMap、TreeMap 等。</p>\n<h3 id=\"2-哪些是线程安全的容器？\"><a href=\"#2-哪些是线程安全的容器？\" class=\"headerlink\" title=\"2. 哪些是线程安全的容器？\"></a>2. 哪些是线程安全的容器？</h3><p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。</p>\n<h3 id=\"3-ArrayList-和-LinkedList-有什么区别？\"><a href=\"#3-ArrayList-和-LinkedList-有什么区别？\" class=\"headerlink\" title=\"3. ArrayList 和 LinkedList 有什么区别？\"></a>3. ArrayList 和 LinkedList 有什么区别？</h3><p>ArrayList 底层是动态数组，内存是连续的，查找快，增删慢，适合经常通过索引访问，在末尾增删的场景，LinkedList 底层是双向链表，查找慢，增删快，适合频繁增删的场景。</p>\n<h3 id=\"4-ArrayList-的扩容机制了解吗？底层实现？\"><a href=\"#4-ArrayList-的扩容机制了解吗？底层实现？\" class=\"headerlink\" title=\"4. ArrayList 的扩容机制了解吗？底层实现？\"></a>4. ArrayList 的扩容机制了解吗？底层实现？</h3><p>当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就调用grow方法生成一个1.5倍容量的新数组，然后拷贝元素到新数组中。</p>\n<h3 id=\"5-ArrayList-怎么序列化的知道吗？\"><a href=\"#5-ArrayList-怎么序列化的知道吗？\" class=\"headerlink\" title=\"5. ArrayList 怎么序列化的知道吗？\"></a>5. ArrayList 怎么序列化的知道吗？</h3><p>它重写了writeObject 方法用于自定义序列化：只序列化有效数据，因为实际存储的元素数量一般小于elementData 数组的容量，声明的时候也加了 transient 关键字防止被默认序列化。</p>\n<h3 id=\"6-HashMap实现原理？-高频\"><a href=\"#6-HashMap实现原理？-高频\" class=\"headerlink\" title=\"6. HashMap实现原理？(高频)\"></a>6. HashMap实现原理？(高频)</h3><p>JDK8之前是数组+链表。之后是数组+链表+红黑树。存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：如果key相同，覆盖原值。 key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。它的初始容量16，加载因子0.75。创建时使用懒加载，不初始化容量。</p>\n<h3 id=\"7-HashMap的put方法的具体流程？-高频\"><a href=\"#7-HashMap的put方法的具体流程？-高频\" class=\"headerlink\" title=\"7. HashMap的put方法的具体流程？(高频)\"></a>7. HashMap的put方法的具体流程？(高频)</h3><p>第一步检查数组是否为空，首次put时，调用resize()初始化数组，默认容量为 16，负载因子为0.75。<br>第二步，计算键的哈希值，具体是将 键的hashCode 异或 hashCode 右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。<br>第三步，根据键的哈希值计算数组索引，具体是将键的哈希值 与上 数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高所以用与运算代替模运算，但前提是数组长度是2的N次幂）。<br>第四步，检查数组索引对应槽位的情况。如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。</p>\n<p>hashMap的寻址算法：扰动算法，通过hash方法，hashcode ^ hashcode &lt;&lt;&lt; 16。<br>首先计算键的hashCode,再调用hash方法进行二次哈希，hashCode右移16位再和hashCode进行异或运算，减少哈希冲突，最后用哈希值 与 容量 -1 得到索引。</p>\n<h3 id=\"8-讲一讲HashMap的扩容机制-高频\"><a href=\"#8-讲一讲HashMap的扩容机制-高频\" class=\"headerlink\" title=\"8. 讲一讲HashMap的扩容机制(高频)\"></a>8. 讲一讲HashMap的扩容机制(高频)</h3><p>当哈希表中元素个数超过阈值时会触发扩容resize方法，这个阈值是 数组容量 * 负载因子,数组容量初始是16，负载因子默认是0.75。<br>扩容时：<br>第一步，创建一个新数组，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。<br>第二步，迁移元素，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过e.hash &amp; (newCap新容量 - 1)计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为低位链和高位链，避免重新哈希带来性能损耗，如果 e.hash &amp; oldCap &#x3D;&#x3D; 0（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。</p>\n<p>为何HashMap的数组长度一定是2的次幂?<br>数组长度是 2 的幂次方时，hash % length和hash &amp; (length - 1)的计算结果是一样的。不过按位与运算在性能上更具优势。计算索引时效率更高，扩容时效率更高。</p>\n<h3 id=\"9-HashMap-是线程安全的吗？\"><a href=\"#9-HashMap-是线程安全的吗？\" class=\"headerlink\" title=\"9. HashMap 是线程安全的吗？\"></a>9. HashMap 是线程安全的吗？</h3><p>不是。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。多线程在进行 put 元素的时候，可能会导致元素丢失。因为put操作不是原子的。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素先插入的元素被覆盖而丢失put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get就可能获取不到元素。线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引 元素可能就 get 不到了。</p>\n<h3 id=\"1-怎么解决HashMap线程不安全问题？\"><a href=\"#1-怎么解决HashMap线程不安全问题？\" class=\"headerlink\" title=\"1. 怎么解决HashMap线程不安全问题？\"></a>1. 怎么解决HashMap线程不安全问题？</h3><p>早期的 JDK 版本中，可以用 <code>Hashtable</code> 来保证线程安全。<code>Hashtable</code> 在方法上加了 <code>synchronized</code> 关键字。但是它同步开销比较大、还不支持 null、扩容效率低，已经被淘汰。多线程场景下推荐使用 <code>ConcurrentHashMap</code>，它使用了分段锁优化，性能远超 <code>HashTable</code>。</p>\n<hr>\n<h2 id=\"并发与JUC高频面试题\"><a href=\"#并发与JUC高频面试题\" class=\"headerlink\" title=\"并发与JUC高频面试题\"></a>并发与JUC高频面试题</h2><h3 id=\"2-进程和线程的区别？\"><a href=\"#2-进程和线程的区别？\" class=\"headerlink\" title=\"2. 进程和线程的区别？\"></a>2. 进程和线程的区别？</h3><ul>\n<li><strong>进程</strong>：程序在操作系统中的一次执行，是系统进行资源分配和调度的基本单位，拥有独立内存空间和系统资源，进程间切换开销大。</li>\n<li><strong>线程</strong>：进程中的一个执行单元，是 CPU 调度的基本单位，共享所属进程的资源，线程间切换开销小。</li>\n<li><strong>并行</strong>：多个任务同时执行。</li>\n<li><strong>并发</strong>：多个任务通过时间片轮转在一段时间内交替执行。</li>\n</ul>\n<hr>\n<h3 id=\"3-线程创建的方式有哪些？\"><a href=\"#3-线程创建的方式有哪些？\" class=\"headerlink\" title=\"3. 线程创建的方式有哪些？\"></a>3. 线程创建的方式有哪些？</h3><p>有四种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口，线程池创建。</p>\n<p><strong>1. 继承 Thread 类</strong>：需要重写父类 Thread 的 run() 方法，然后调用 start() 方法启动线程。缺点是，如果 ThreadTask 已经继承了另外一个类，就不能再继承 Thread 类了，因为 Java 不支持多重继承。</p>\n<p><strong>2. 实现 Runnable 接口</strong>：重写 Runnable 接口的 run() 方法，然后把它作为参数传给 Thread类，最后调用 start() 方法启动线程。这种方式的优点是可以避免 Java 的单继承限制，缺点是没有返回值，拿不到线程执行结果并且不能抛出异常。</p>\n<p><strong>3. 实现 Callable 接口</strong>：重写 Callable 接口的 call() 方法，然后创建一个 CallableTask 对象，然后创建 FutureTask 对象，构造方法中以 CallableTask 实例传参；然后创建 Thread 对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CallableTask</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CallableTask</span>();</span><br><span class=\"line\">FutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(task);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask);</span><br><span class=\"line\">thread.start();</span><br></pre></td></tr></table></figure>\n\n<p><strong>4. 线程池创建</strong>：实现 Runnable 或 Callable 接口后，提交给线程池执行。</p>\n<hr>\n<h3 id=\"4-线程包括哪些状态，状态之间是如何变化的？\"><a href=\"#4-线程包括哪些状态，状态之间是如何变化的？\" class=\"headerlink\" title=\"4. 线程包括哪些状态，状态之间是如何变化的？\"></a>4. 线程包括哪些状态，状态之间是如何变化的？</h3><p>Thread类中有一个枚举类State，一共6种：</p>\n<ul>\n<li>新建(NEW)</li>\n<li>可运行(RUNNABLE)</li>\n<li>阻塞(BLOCKED)</li>\n<li>等待（WAITING）</li>\n<li>时间等待(TIMED_WAITING)</li>\n<li>终止(TERMINATED)</li>\n</ul>\n<p>状态转换：</p>\n<ul>\n<li>创建线程对象是新建状态</li>\n<li>调用了start()方法转变为可执行状态</li>\n<li>线程获取到了CPU的执行权，执行结束是终止状态</li>\n<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态</li>\n<li>如果没有获取锁(synchronized或lock)进入阻塞状态，获得锁再切换为可执行状态</li>\n<li>如果线程调用了wait()方法进入等待状态，其他线程调用notify(唤醒后可切换为可执行状态)</li>\n<li>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</li>\n</ul>\n<hr>\n<h3 id=\"5-在java中wait和sleep方法的不同\"><a href=\"#5-在java中wait和sleep方法的不同\" class=\"headerlink\" title=\"5. 在java中wait和sleep方法的不同\"></a>5. 在java中wait和sleep方法的不同</h3><ul>\n<li>都能让线程进入阻塞状态，并且都可以传一个时间参数等待相应毫秒数醒来，也都能被打断唤醒。</li>\n<li><strong>sleep方法</strong>是Thread类的静态方法，而<strong>wait方法</strong>是Object类的成员方法。</li>\n<li>wait方法可以被notify方法唤醒，如果没传时间参数也没被唤醒就一直等待。</li>\n<li><strong>锁不同</strong>：<ul>\n<li>wait方法的调用必须先获取wait对象的锁，wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu，但你们还可以用）。</li>\n<li>sleep调用不用获取锁，sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu，你们也用不了）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"6-如何停止一个正在运行的线程\"><a href=\"#6-如何停止一个正在运行的线程\" class=\"headerlink\" title=\"6. 如何停止一个正在运行的线程\"></a>6. 如何停止一个正在运行的线程</h3><p>三种方式：</p>\n<ul>\n<li><strong>使用退出标志</strong>，使线程正常退出，也就是当run方法完成后线程终止。</li>\n<li>使用<strong>stop方法强行终止</strong>（不推荐，方法已作废）。</li>\n<li>使用<strong>interrupt方法</strong>中断线程。<ul>\n<li>打断阻塞的线程（sleep，wait，join）的线程，线程会抛出InterruptedException异常。</li>\n<li>打断正常的线程，可以根据打断状态来标记是否退出线程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"7-线程中并发安全（高频，难答）\"><a href=\"#7-线程中并发安全（高频，难答）\" class=\"headerlink\" title=\"7. 线程中并发安全（高频，难答）\"></a>7. 线程中并发安全（高频，难答）</h3><h4 id=\"synchronized关键字的底层原理\"><a href=\"#synchronized关键字的底层原理\" class=\"headerlink\" title=\"synchronized关键字的底层原理\"></a>synchronized关键字的底层原理</h4><ul>\n<li>在jdk1.6之前，<code>synchronized</code>被称为<strong>重量级锁</strong>。底层核心是<strong>monitor（监视器）</strong>，它是 JVM 层面的对象，每个 Java 对象都会关联一个 monitor。当线程获取 synchronized 锁时，本质是获取对象关联的 monitor 所有权，其核心属性是owner、entrylist、waitset。</li>\n<li>owner关联当前持有锁的线程（同一时刻仅一个线程可持有）。</li>\n<li>entrylist关联等待获取锁的线程队列（这些线程处于阻塞状态）。</li>\n<li>waitset关联的调用<code>wait()</code>后进入等待状态的线程队列（需被<code>notify/notifyAll</code>唤醒后才会进入 entryList）。</li>\n</ul>\n<p><strong>锁升级：</strong></p>\n<ul>\n<li>jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了<strong>偏向锁</strong>和<strong>轻量级锁</strong>。</li>\n<li><strong>偏向锁</strong>：在对象头的<code>Mark Word</code>中记录获取锁的线程 ID，后续该线程再次获取锁时，只需判断 ID 是否在Mark Word，无需 CAS 操作。适用于锁长期被同一线程持有，无竞争的场景。当其他线程尝试获取锁时，偏向锁会被撤销，通过 CAS 竞争升级为轻量级锁。</li>\n<li><strong>轻量级锁</strong>：通过CAS操作在当前线程栈帧中创建“锁记录（Lock Record）”，将<code>Mark Word</code>复制到锁记录中，再尝试用CAS将<code>Mark Word</code>替换为指向锁记录的指针：<ul>\n<li>成功：获取轻量级锁，<code>Mark Word</code>标志位为<code>00</code>。</li>\n<li>失败：进入“自旋优化”（线程不阻塞，循环尝试获取锁，避免内核态切换）。<ul>\n<li><strong>自旋优化</strong>：若自旋一定次数（默认10次）后仍失败，升级为重量级锁。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>重量级锁</strong>：底层使用的Monitor实现，Monitor依赖操作系统互斥量（Mutex）实现，所以也叫互斥锁，涉及到了用户态和内核态的切换，开销巨大，适用于锁竞争激烈或持有锁时间长的场景。</li>\n</ul>\n<hr>\n<h3 id=\"8-你谈谈JMM-Java内存模型）\"><a href=\"#8-你谈谈JMM-Java内存模型）\" class=\"headerlink\" title=\"8. 你谈谈JMM(Java内存模型）\"></a>8. 你谈谈JMM(Java内存模型）</h3><p>JMM（Java 内存模型）是 JVM 定义的<strong>共享内存中多线程读写操作规范</strong>，保证指令正确性，它把内存分为主内存和本地内存。主内存公共区域存储共享变量，本地内存是线程私有存储共享变量的副本，线程间隔离，交互通过主内存。当某个线程更改了本地内存中共享变量的副本，jvm会写入主内存让所有线程可见。</p>\n<hr>\n<h3 id=\"9-CAS-你知道吗\"><a href=\"#9-CAS-你知道吗\" class=\"headerlink\" title=\"9. CAS 你知道吗\"></a>9. CAS 你知道吗</h3><p>CAS的全称是：CompareAndSwap(比较再交换);它体现的一种<strong>乐观锁</strong>的思想，在无锁状态下保证线程操作数据的<strong>原子性</strong>。CAS使用到的地方很多：AQS框架、AtomicXXX类，在操作共享变量的时候使用的<strong>自旋锁</strong>效率上更高一些，CAS的底层是调用的<strong>Unsafe类</strong>中的本地方法由C&#x2F;C++实现。</p>\n<hr>\n<h3 id=\"10-乐观锁和悲观锁的区别？\"><a href=\"#10-乐观锁和悲观锁的区别？\" class=\"headerlink\" title=\"10. 乐观锁和悲观锁的区别？\"></a>10. 乐观锁和悲观锁的区别？</h3><ul>\n<li><strong>乐观锁</strong>：操作数据时非常乐观，认为别的线程不会同时修改数据，因此不会上锁。通常在执行更新时，会判断在此期间数据是否被别人修改，若未修改则执行操作，否则放弃操作。主要实现方式有 CAS 机制和版本号机制，适用于<strong>竞争不激烈、读多写少</strong>的场景，如 Java 中<code>AtomicInteger</code>等原子类就运用了乐观锁思想。</li>\n<li><strong>悲观锁</strong>：操作数据时比较悲观，认为其他线程会同时修改数据，所以在操作数据前直接把数据锁住，直到操作完成后才释放锁，上锁期间其他线程不能修改数据。Java 中的<code>synchronized</code>关键字和<code>ReentrantLock</code>等都是悲观锁的实现，适合<strong>并发写入多、竞争激烈</strong>的场景。</li>\n</ul>\n<hr>\n<h3 id=\"11-什么是AQS？\"><a href=\"#11-什么是AQS？\" class=\"headerlink\" title=\"11. 什么是AQS？\"></a>11. 什么是AQS？</h3><p>AQS 是一个抽象类，一个共享变量 state 和一个线程等待队列，为 ReentrantLock 等类提供底层支持。如果被请求的<strong>共享资源</strong>处于空闲状态，当前线程就能成功<strong>获取锁</strong>；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。</p>\n<p>AQS 的源码阅读：</p>\n<ul>\n<li>状态 state 由 volatile 变量修饰，用于保证多线程之间的可见性。</li>\n<li><strong>同步队列</strong>由内部定义的 Node 类实现，每个 Node 包含了等待状态、前后节点、线程的引用等，是一个先进先出的双向链表。</li>\n<li>AQS 支持两种同步方式：<ul>\n<li>独占模式下：每次只能有一个线程持有锁，例如 ReentrantLock。</li>\n<li>共享模式下：多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。</li>\n</ul>\n</li>\n<li>acquire ：获取锁，失败进入等待队列；</li>\n<li>release ：释放锁，唤醒等待队列中的线程；</li>\n<li>acquireShared ：共享模式获取锁</li>\n<li>releaseShared ：共享模式释放锁。</li>\n<li>AQS 使用一个 CLH 队列来维护等待线程，是一种基于链表的自旋锁。当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。</li>\n</ul>\n<hr>\n<h3 id=\"12-ReentrantLock的实现原理\"><a href=\"#12-ReentrantLock的实现原理\" class=\"headerlink\" title=\"12. ReentrantLock的实现原理\"></a>12. ReentrantLock的实现原理</h3><p>ReentrantLock表示可重入锁，调用lock方法获取了锁之后，再次调用lock，是不会再阻塞。ReentrantLock主要利用CAS+AQS队列来实现，支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁。</p>\n<hr>\n<h3 id=\"13-synchronized-和-ReentrantLock-的区别\"><a href=\"#13-synchronized-和-ReentrantLock-的区别\" class=\"headerlink\" title=\"13. synchronized 和 ReentrantLock 的区别\"></a>13. synchronized 和 ReentrantLock 的区别</h3><ul>\n<li>synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。</li>\n<li>ReentrantLock 可以实现多路选择通知，绑定多个 Condition，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；</li>\n<li>synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。</li>\n<li>并发量大的情况下，推荐使用 ReentrantLock，因为：<ul>\n<li>提供了超时和公平锁等特性，可以应对更复杂的并发场景。</li>\n<li>允许更细粒度的锁控制，能有效减少锁竞争。</li>\n<li>支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"14-Lock-了解吗？\"><a href=\"#14-Lock-了解吗？\" class=\"headerlink\" title=\"14. Lock 了解吗？\"></a>14. Lock 了解吗？</h3><p>Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等。</p>\n<hr>\n<h3 id=\"15-ReentrantLock-的-lock-方法实现逻辑了解吗？\"><a href=\"#15-ReentrantLock-的-lock-方法实现逻辑了解吗？\" class=\"headerlink\" title=\"15. ReentrantLock 的 lock() 方法实现逻辑了解吗？\"></a>15. ReentrantLock 的 lock() 方法实现逻辑了解吗？</h3><p>lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS 的等待队列中。</p>\n<hr>\n<h3 id=\"16-请谈谈你对volatile的理解\"><a href=\"#16-请谈谈你对volatile的理解\" class=\"headerlink\" title=\"16. 请谈谈你对volatile的理解\"></a>16. 请谈谈你对volatile的理解</h3><ul>\n<li>JVM中的JIT即时编译器会对指令进行优化重排序，这可能导致一个线程对共享变量的修改其他线程不可见，用volatile修饰共享变量后，能够防止编译器等优化发生，保证共享变量的可见性。</li>\n<li>禁止进行指令重排序：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。</li>\n<li>volatile使用技巧：写变量让volatile修饰的变量的在代码最后位置，读变量让volatile修饰的变量的在代码最开始位置。</li>\n</ul>\n<hr>\n<h3 id=\"17-聊一下ConcurrentHashMap-？（高频很重要）\"><a href=\"#17-聊一下ConcurrentHashMap-？（高频很重要）\" class=\"headerlink\" title=\"17. 聊一下ConcurrentHashMap ？（高频很重要）\"></a>17. 聊一下ConcurrentHashMap ？（高频很重要）</h3><p>ConcurrentHashMap 是 HashMap 的线程安全版本。</p>\n<ul>\n<li>JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable，维护一个键值对数组HashEntry 它是一个单向链表。段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。</li>\n<li>JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。</li>\n<li>对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。</li>\n</ul>\n<hr>\n<h4 id=\"JDK-7-中-ConcurrentHashMap-的-put-get-流程\"><a href=\"#JDK-7-中-ConcurrentHashMap-的-put-get-流程\" class=\"headerlink\" title=\"JDK 7 中 ConcurrentHashMap 的 put&#x2F;get 流程\"></a>JDK 7 中 ConcurrentHashMap 的 put&#x2F;get 流程</h4><ol>\n<li>计算 key 的 hash，定位到段，段如果是空就先初始化；</li>\n<li>使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；</li>\n<li>遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。</li>\n<li>释放锁。</li>\n</ol>\n<p>Get时先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。<br>get 不用加锁，因为 value 是 volatile 的，所以线程读取 value 时不会出现可见性问题。</p>\n<hr>\n<h4 id=\"JDK-8-中-ConcurrentHashMap-的-put-get-流程\"><a href=\"#JDK-8-中-ConcurrentHashMap-的-put-get-流程\" class=\"headerlink\" title=\"JDK 8 中 ConcurrentHashMap 的 put&#x2F;get 流程\"></a>JDK 8 中 ConcurrentHashMap 的 put&#x2F;get 流程</h4><ul>\n<li>JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比 JDK 7 有了很大的提升。</li>\n<li>Put: 第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。插入的过程中会判断桶的哈希是否小于 0（f.hash &gt;&#x3D; 0），小于 0 说明是红黑树，大于等于 0 说明是链表。第三步，如果链表长度超过 8，转换为红黑树。第四步，在插入新节点后，会调用 addCount() 方法检查是否需要扩容。</li>\n<li>Get: get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用find方法查找。否则遍历链表查找匹配的键。如果都没找到，返回 null。</li>\n</ul>\n<hr>\n<h4 id=\"项目中怎么使用-ConcurrentHashMap-的？\"><a href=\"#项目中怎么使用-ConcurrentHashMap-的？\" class=\"headerlink\" title=\"项目中怎么使用 ConcurrentHashMap 的？\"></a>项目中怎么使用 ConcurrentHashMap 的？</h4><p>在技术派实战项目中，用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，使用了 ConcurrentHashMap 来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。</p>\n<hr>\n<h4 id=\"ConcurrentHashMap-怎么保证可见性？\"><a href=\"#ConcurrentHashMap-怎么保证可见性？\" class=\"headerlink\" title=\"ConcurrentHashMap 怎么保证可见性？\"></a>ConcurrentHashMap 怎么保证可见性？</h4><p>ConcurrentHashMap 中的 Node 节点中，value 和 next 都是 volatile 的，这样就可以保证对 value 或 next 的更新会被其他线程立即看到。</p>\n<hr>\n<h4 id=\"为什么-ConcurrentHashMap-比-Hashtable-效率高？\"><a href=\"#为什么-ConcurrentHashMap-比-Hashtable-效率高？\" class=\"headerlink\" title=\"为什么 ConcurrentHashMap 比 Hashtable 效率高？\"></a>为什么 ConcurrentHashMap 比 Hashtable 效率高？</h4><p>Hashtable 在任何时刻只允许一个线程访问整个 Map，是通过对整个 Map 加锁来实现线程安全的。比如 get 和 put 方法，是直接在方法上加的 synchronized 关键字。而 ConcurrentHashMap 在 JDK 8 中是采用 CAS + synchronized 实现的，仅在必要时加锁。比如说 put 的时候优先使用 CAS 尝试插入，如果失败再使用 synchronized 代码块加锁。get 的时候是完全无锁的，因为 value 是 volatile 变量 修饰的，保证了内存可见性。</p>\n<hr>\n<h4 id=\"CopyOnWriteArrayList-的实现原理\"><a href=\"#CopyOnWriteArrayList-的实现原理\" class=\"headerlink\" title=\"CopyOnWriteArrayList 的实现原理\"></a>CopyOnWriteArrayList 的实现原理</h4><p>CopyOnWriteArrayList 是 ArrayList 的线程安全版本，适用于读多写少的场景。它的核心思想是写操作时创建一个新数组，修改后再替换原数组，这样就能够确保读操作无锁，从而提高并发性能。内部使用 volatile 变量来修饰数组 array，以读操作的内存可见性。写操作的时候使用 ReentrantLock 来保证线程安全。缺点就是写操作的时候会复制一个新数组，如果数组很大，写操作的性能会受到影响。</p>\n<h3 id=\"1-阻塞队列的实现方式？\"><a href=\"#1-阻塞队列的实现方式？\" class=\"headerlink\" title=\"1. 阻塞队列的实现方式？\"></a>1. 阻塞队列的实现方式？</h3><p>阻塞队列是多线程环境下常用的数据结构，支持阻塞式的插入和删除，当队列满时，生产者线程会被阻塞直到有空间；当队列空时，消费者线程会被阻塞直到有元素。这种特性使其非常适合实现生产者 - 消费者模式。主要实现方式有3种：</p>\n<ul>\n<li>基于 synchronized+wait&#x2F;notify ，利用 Java 内置锁和 Object 类的等待机制。队列的 put 和 take 方法用 synchronized 修饰，当队列满时，生产者通过 wait () 进入等待状态；当队列空时，消费者同样 wait ()。操作完成后通过 notifyAll () 唤醒等待线程。优点是实现简单，缺点是功能单一，不支持公平性，且只有一个条件队列。</li>\n<li>基于 ReentrantLock+Condition 的实现。这是 JDK 标准库（如ArrayBlockingQueue）采用的方式，比 synchronized 更灵活。通过 ReentrantLock 保证线程安全，同时创建两个 Condition 对象（notEmpty 和 notFull）分别管理消费者和生产者的等待队列。当队列满时，生产者在 notFull 上 await ()；当队列空时，消费者在 notEmpty 上 await ()。操作完成后针对性地 signal () 对应条件队列的线程。这种方式支持公平锁配置，且能精确唤醒特定类型的线程。</li>\n<li>基于 CAS 操作的非阻塞实现。利用原子类（如 AtomicReference）通过 CAS 操作实现无锁化的并发控制，比如 ConcurrentLinkedQueue。通过循环重试的方式处理并发冲突，避免了线程阻塞和唤醒的开销，高并发场景下性能更好，但实现逻辑复杂，适合对性能要求极高的场景。</li>\n</ul>\n<p>这几种实现各有侧重：synchronized 方式适合简单场景；ReentrantLock+Condition 兼顾功能与性能，是 JDK 标准实现的首选；CAS 方式适合高并发低延迟的场景。实际开发中通常用 JDK 提供的阻塞队列（如 ArrayBlockingQueue、LinkedBlockingQueue），它们内部基于 ReentrantLock+Condition 实现，已经过充分优化和测试，能满足绝大多数并发场景的需求。</p>\n<hr>\n<h2 id=\"开放性问题\"><a href=\"#开放性问题\" class=\"headerlink\" title=\"开放性问题\"></a>开放性问题</h2><h3 id=\"1-先做个简单的自我介绍吧！\"><a href=\"#1-先做个简单的自我介绍吧！\" class=\"headerlink\" title=\"1. 先做个简单的自我介绍吧！\"></a>1. 先做个简单的自我介绍吧！</h3><p>面试官您好！我叫郝泽飞，是哈尔滨工程大学计算机专业的学生，现在在读研一，在校期间，我成绩专业排名前10%，大学期间参加了多个竞赛并取得奖项，通过了英语四六级。技术方面，大一期间我学习了计算机的基础知识，像数据结构，C++和JAVA的基础语法，大二以后开始学Java技术栈，比如Spring Boot、MyBatis-Plus、MySQL、Redis、RabbitMQ等，后来又做了一些项目，微服务架构的Pm-hub,大模型应用开发的派聪明。生活中我是一个比较积极乐观的人，我非常期待能在贵公司的开发岗位中，将所学的技术应用于实际业务，我的介绍完毕，谢谢！</p>\n<h3 id=\"2-说说你的这个pm-hub项目吧？\"><a href=\"#2-说说你的这个pm-hub项目吧？\" class=\"headerlink\" title=\"2. 说说你的这个pm-hub项目吧？\"></a>2. 说说你的这个pm-hub项目吧？</h3><p>（项目背景、解决问题、职责任务。2项目使用的技术栈、技术架构、是否使用微服务，项目具体功能细节。技术具体实现细节。项目存在的问题和完善解决方案。项目具体功能的优化（如查询是在数据库中扫表查询吗）项目最有挑战的模块，如何解决，项目增大10倍的qps，如何设计？项目上线后出现频繁fullGc，怎么解决？）<br>好的，这个项目是我（跟室友&#x2F;同学&#x2F;老师一起做的。&#x2F;参考开源项目做的一个二次开发），做这个项目是为了……，考虑到—所以项目中用到了***，当时我负责的部分是。发现速度&#x2F;可用性不够，进行了SQL优化，分布式锁，seata事务,skywalking监控等。第二个项目是……，因为最近AI比较流行，我就想学一些新技术，跟上时代的步伐，这个项目是参考开源项目，用了……技术栈，实现了……功能，优化，解决……问题。以上是我的项目介绍。</p>\n<h3 id=\"3-项目中遇到最大的困难？怎么解决的？\"><a href=\"#3-项目中遇到最大的困难？怎么解决的？\" class=\"headerlink\" title=\"3. 项目中遇到最大的困难？怎么解决的？\"></a>3. 项目中遇到最大的困难？怎么解决的？</h3><hr>\n<h3 id=\"4-平时是怎么学习的？\"><a href=\"#4-平时是怎么学习的？\" class=\"headerlink\" title=\"4. 平时是怎么学习的？\"></a>4. 平时是怎么学习的？</h3><p>比如我学一门新技术吧，首先看官方文档，如果晦涩难懂就会找教程&#x2F;视频，还会使用AI工具（豆包，chatGPT）详细解释辅助理解，然后做个demo用到项目中，大学期间我大多是在开源社区学习还有网课。</p>\n<h3 id=\"5-人生发展、最近五年职业规划\"><a href=\"#5-人生发展、最近五年职业规划\" class=\"headerlink\" title=\"5. 人生发展、最近五年职业规划\"></a>5. 人生发展、最近五年职业规划</h3><hr>\n<h3 id=\"6-什么时候能到岗？\"><a href=\"#6-什么时候能到岗？\" class=\"headerlink\" title=\"6. 什么时候能到岗？\"></a>6. 什么时候能到岗？</h3><h3 id=\"7-薪资要求？\"><a href=\"#7-薪资要求？\" class=\"headerlink\" title=\"7. 薪资要求？\"></a>7. 薪资要求？</h3><h2 id=\"反问：\"><a href=\"#反问：\" class=\"headerlink\" title=\"反问：\"></a>反问：</h2><h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><ol>\n<li>部门主营业务和使用的技术栈是什么？</li>\n<li>您觉得我的专业能力有哪些需要提升的？</li>\n<li>刚才关于xx问题，我想问下您的思路。</li>\n<li>面试一般多久会出通知和结果呢？</li>\n</ol>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><ol>\n<li>面试候选人，尤其是校招生的时候，最看重什么？</li>\n<li>您对进入您团队的成员的要求是什么？或者说需要怎样的品质胜任这个职位？</li>\n<li>我很好奇职位的晋升机制和发展路径。公司对信任的培养是怎么样的？</li>\n</ol>\n<h3 id=\"HR面-三面\"><a href=\"#HR面-三面\" class=\"headerlink\" title=\"HR面&#x2F;三面\"></a>HR面&#x2F;三面</h3><ul>\n<li>企业文化</li>\n<li>代表性产品</li>\n<li>历年薪资</li>\n</ul>\n",
            "tags": [
                "Hexo",
                "博客"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/",
            "url": "https://120115.xyz/2025/07/19/ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/",
            "title": "ArrayList底层的实现原理是什么？",
            "date_published": "2025-07-19T08:55:58.136Z",
            "content_html": "<p>摘要：<br>ArrayList底层是动态数组，支持自动扩容和高效随机访问。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>ArrayList底层是一个<strong>动态数组</strong>，<strong>初始容量是0</strong>，<strong>当第一次添加数据</strong>才会初始化容量为10，<strong>扩容</strong>是原来容量的1.5倍，每次扩容都需要<strong>拷贝数组</strong>。</p>\n<p>添加数据时：</p>\n<ul>\n<li>判断元素个数size+1后是否大于总容量，如果大于就调用grow方法扩容，把旧数组拷贝到扩容后的新数组中，再把新元素放在size位置上，返回true。</li>\n</ul>\n<p><strong>ArrayList list&#x3D;new ArrayList(10)中的list扩容几次?</strong><br>声明和实例了一个ArrayList，指定了容量为10，未扩容。构造方法中传参initCapcity,是多少就初始化多少容量。</p>\n<p><strong>如何实现数组和List之间的转换？</strong></p>\n<ul>\n<li>数组转List:           <strong>Arrays工具类的asList方法</strong></li>\n<li>List转数组，使用<strong>List的toArray方法</strong>。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组。</li>\n</ul>\n<p>面试官再问：</p>\n<ol>\n<li>用Arrays.asList转List后，如果修改了数组内容，list受影响吗？</li>\n<li>List用toArray转数组后，如果修改了List内容，数组受影响吗？</li>\n</ol>\n<p><strong>数组转List受影响</strong>，因为它的<strong>底层使用的Arrays类中的一个内部类ArrayList来构造的集合</strong>，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，<strong>最终指向的都是同一个内存地址</strong>。</p>\n<p><strong>List转数组不受影响</strong>，在底层是它是进行了数组的拷贝。</p>\n",
            "tags": [
                "实现原理",
                "ArrayList"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://120115.xyz/2025/07/19/HashSet%EF%BC%8CHashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "HashSet，HashTable与HashMap的区别",
            "date_published": "2025-07-19T08:55:48.002Z",
            "content_html": "<p>摘要：<br>对比HashSet、HashMap、HashTable三者的底层结构、线程安全性、常用方法及应用场景。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>数据结构上HashSet底层是一个HashMap，只存储键不存储值；HashMap是一个哈希表，由数组+链表+红黑树组成，存储键值对。HashSet不能重复，只允许一个null元素，实现了Set接口；HashMap键只有一个null值，值可以有多个，实现Map接口，它们性能一致。</p>\n<p>常用方法：</p>\n<ul>\n<li>HashSet：add, remove, contains, size</li>\n<li>HashMap: put(), get(), remove(), containsKey(), size()</li>\n</ul>\n<p>HashTable 是 Java 早期的线程安全哈希表实现，因同步开销大、设计局限性（如不支持 null、扩容效率低），已逐渐被淘汰。HashMap 作为更现代的实现，性能更优、功能更灵活，而多线程场景下推荐使用 ConcurrentHashMap（分段锁优化，性能远超 HashTable）。</p>\n<p>你能自己设计实现一个 HashMap 吗？</p>\n<ul>\n<li>第一步，实现一个 hash 函数，对键的 hashCode 进行扰动</li>\n<li>第二步，实现一个拉链法的方法来解决哈希冲突</li>\n<li>第三步，扩容后，重新计算哈希值，将元素放到新的数组中</li>\n</ul>\n<p>讲讲 LinkedHashMap 怎么实现有序的？<br>在 HashMap 的基础上维护了一个双向链表，通过 before 和 after 标识前置节点和后置节点。从而实现插入和访问有序。</p>\n",
            "tags": [
                "HashMap",
                "HashSet",
                "HashTable"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/",
            "url": "https://120115.xyz/2025/07/19/HashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/",
            "title": "HashMap 是线程安全的吗？",
            "date_published": "2025-07-19T08:55:34.536Z",
            "content_html": "<p>摘要：<br>HashMap 不是线程安全的，多线程环境下可能出现死循环、数据丢失等问题。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>HashMap 不是线程安全的。</p>\n<ol>\n<li><p>JDK7 中的 HashMap 使用的是<strong>头插法</strong>来处理链表，在<strong>多线程环境下扩容会出现环形链表，造成死循环</strong>。JDK 8 时通过<strong>尾插法修复</strong>了这个问题，扩容时会保持链表原来的顺序。</p>\n</li>\n<li><p>多线程在进行 <strong>put 元素</strong>的时候，<strong>可能会导致元素丢失</strong>。因为put操作<strong>不是原子的</strong>。当多个线程同时检查到 “槽位为空” 或 “键不存在” 时，可能都决定写入，这样就可能导致元素<strong>先插入的元素被覆盖而丢失</strong>。</p>\n</li>\n<li><p>put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元<strong>素个数超出阈值而扩容</strong>，线程 2 此时执行 get 就可能获取不到元素。线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 已经发生了改变，线程 2 去 get 索引元素可能就 get 不到了。</p>\n</li>\n</ol>\n",
            "tags": [
                "HashMap",
                "线程安全"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/",
            "url": "https://120115.xyz/2025/07/19/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F/",
            "title": "HashMap的put方法的具体流程？",
            "date_published": "2025-07-19T08:55:24.937Z",
            "content_html": "<p>摘要：<br>详细解析HashMap的put方法执行流程，包括哈希计算、索引定位、冲突处理、链表与红黑树转换等。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br><strong>第一步：检查数组是否为空</strong><br>首次<code>put</code>时，调用<code>resize()</code>初始化数组，默认容量为16，负载因子为0.75。</p>\n<p><strong>第二步：计算键的哈希值</strong><br>具体是将键的hashCode异或hashCode右移16位的值。这是为了减少哈希冲突，让元素分布更均匀。</p>\n<p><strong>第三步：根据键的哈希值计算数组索引</strong><br>具体是将键的哈希值与上数组长度-1（等价于哈希值模数组长度，因为与运算的效率更高，所以用与运算代替模运算，但前提是数组长度是2的N次幂）。</p>\n<p><strong>第四步：检查数组索引对应槽位的情况</strong><br>如果为空，直接插入；如果不为空，用equals判断对应位置键是否已经存在，存在则更新值。如果对应位置是红黑树，插入树结点。是链表就遍历链表逐个用equals检查键是否存在，存在则更新值，遍历完后发现不存在则插入链表尾部，如果链表长度≥8且数组长度≥64，链表转成红黑树。</p>\n<p><strong>只重写元素的equals方法没重写hashCode，put的时候会发生什么？</strong><br>如果只重写equals方法，没有重写hashCode方法，那么会导致equals相等的两个对象，hashCode不相等，这样的话，两个对象会被put到数组中不同的位置，导致get的时候，无法获取到正确的值。</p>\n",
            "tags": [
                "HashMap",
                "put方法"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/",
            "url": "https://120115.xyz/2025/07/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/",
            "title": "HashMap实现原理？",
            "date_published": "2025-07-19T08:55:15.936Z",
            "content_html": "<p>摘要：<br>HashMap底层是哈希表数据结构，Java8之前是数组+链表，之后是数组+链表+红黑树。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>HashMap底层是哈希表数据结构，Java8之前，是数组+链表。之后是数组+链表+红黑树。</p>\n<p>存储元素时，利用key的hashCode重新hash计算出元素在数组中的下标，如果两个key出现了相同的hash值（哈希冲突）：</p>\n<ul>\n<li>如果key相同，覆盖原值。</li>\n<li>key不同，把key-value放入链表或红黑树中，链表的长度大于8并且数组长度大于64时链表转成红黑树。扩容resize时，红黑树的结点≤6就退化成链表。</li>\n</ul>\n<p>获取元素时，直接找到hash值对应下标，再判断key是否相同来找到值。</p>\n<p>源码：初始容量16，加载因子0.75，扩容&#x3D;之积。懒加载，不初始化容量。</p>\n",
            "tags": [
                "HashMap",
                "实现原理"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/",
            "url": "https://120115.xyz/2025/07/19/%E8%AE%B2%E4%B8%80%E8%AE%B2HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/",
            "title": "讲一讲HashMap的扩容机制",
            "date_published": "2025-07-19T08:28:05.350Z",
            "content_html": "<p>摘要：<br>HashMap 在元素个数超过阈值时会触发扩容（resize）操作，这个阈值是数组容量 * 负载因子。扩容的过程包括新数组创建和元素迁移。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>当哈希表中元素个数超过阈值时会触发扩容 resize 方法，这个阈值是 数组容量 * 负载因子，数组容量初始是16，负载因子默认是0.75。</p>\n<p>扩容时：</p>\n<ol>\n<li><strong>创建一个新数组</strong>，容量为旧数组的2倍，具体是将旧容量左移1位得到新容量。</li>\n<li><strong>迁移元素</strong>，遍历旧数组的每个槽位，重新计算索引后放到新数组。如果槽位是单个节点，通过 <code>e.hash &amp; (newCap新容量 - 1)</code> 计算新索引；如果是红黑树节点，拆分处理。如果是链表节点，将链表拆分为<strong>低位链</strong>和<strong>高位链</strong>，避免重新哈希带来性能损耗。如果 <code>e.hash &amp; oldCap == 0</code>（元素哈希值与上旧容量等于0）就是低位链，索引不变。如果不为0，就是高位链，索引变成 旧索引 + 旧容量。</li>\n</ol>\n<p>通过这种方式，HashMap 能够高效地完成扩容和数据迁移，保证查询和插入的性能。</p>\n",
            "tags": [
                "HashMap",
                "扩容"
            ]
        },
        {
            "id": "https://120115.xyz/2025/07/18/hello-world/",
            "url": "https://120115.xyz/2025/07/18/hello-world/",
            "title": "你好，世界",
            "date_published": "2025-07-18T09:26:05.873Z",
            "content_html": "<p>摘要：<br>欢迎使用 Hexo！这是你的第一篇博客文章。</p>\n<span id=\"more\"></span>\n\n<p>正文：<br>你好，欢迎来到我的个人博客！</p>\n<p>这是我用 Hexo 搭建的第一个博客页面。你可以在这里记录生活、学习、技术心得等内容。</p>\n<p>如果你遇到任何问题，可以查阅 Hexo 官方文档，或者在评论区留言交流。</p>\n<p>祝你写作愉快！</p>\n",
            "tags": [
                "Hexo",
                "博客"
            ]
        },
        {
            "id": "https://120115.xyz/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/",
            "url": "https://120115.xyz/2024/07/21/LangChain4j%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-Java%E5%BC%80%E5%8F%91AI%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/",
            "title": "LangChain4j实战教程-Java开发AI项目，太爽了！",
            "date_published": "2024-07-21T04:00:00.000Z",
            "content_html": "<p>原文链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvN2NOaDduZGVpV2lIQmpua1Rrel9aZw==\">https://mp.weixin.qq.com/s/7cNh7ndeiWiHBjnkTkz_Zg</span><br>大家好，我是程序员鱼皮。现在 AI 应用开发可以说是程序员必备的技能了，求职时能够大幅增加竞争力。之前我用 Spring AI 带大家做过一个开源的 AI 超级智能体项目，这次我来带大家快速掌握另一个主流的 Java AI 应用开发框架 LangChain4j。</p>\n<p>这个教程也是我精心设计，拒绝枯燥的理论，而是用一个编程小助手项目带大家在实战中依次学习 LangChain 几乎所有主流的用法和特性。看完这个教程，你不仅学会了 LangChain，还直接多了一段项目经历，岂不美哉？</p>\n<p>文章近一万字，有点长，建议收藏，观看视频版体验更佳~</p>\n<p>完整视频教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iaWxpYmlsaS5jb20vdmlkZW8vQlYxWDRHR3ppRXly\">https://bilibili.com/video/BV1X4GGziEyr</span></p>\n<p>项目代码开源：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xpeXVwaS9haS1jb2RlLWhlbHBlcg==\">https://github.com/liyupi/ai-code-helper</span></p>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><p>我们要实现一个 AI 编程小助手，可以帮助用户答疑解惑，并且给出编程学习的指导建议，比如：</p>\n<ul>\n<li>编程学习路线</li>\n<li>项目学习建议</li>\n<li>程序员求职指南</li>\n<li>程序员常见面试题</li>\n</ul>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQtvia8yfz6ukkFwsZHhnHfnV7ia4LnanElUoS68nR5ichlZbHQyty9HVwQ/640?wx_fmt=png&from=appmsg&randomid=als75bj1&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>要实现这个需求，我们首先要能够调用 AI 完成基础对话，而且要支持实现多轮对话记忆。此外，如果想进一步增强 AI 的能力，需要让它能够使用工具来联网搜索内容；还可以让 AI 基于我们自己的知识库回答，给用户提供我们在编程领域沉淀的资源和经验。</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQel4e7wMeljibTCub9ELadNwqIHHMDvxglnibHhEZNThZqXcNTaYHXMPg/640?wx_fmt=png&from=appmsg&randomid=7m9qg0cr&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>如果要从 0 开始实现上述功能，还是很麻烦的，因此我们要使用 AI 开发框架来提高效率。</p>\n<h2 id=\"什么是-LangChain4j？\"><a href=\"#什么是-LangChain4j？\" class=\"headerlink\" title=\"什么是 LangChain4j？\"></a>什么是 LangChain4j？</h2><p>目前主流的 Java AI 开发框架有 Spring AI 和 LangChain4j，它们都提供了很多开箱即用的 API 来帮你调用大模型、实现 AI 开发常用的功能，比如我们今天要学的：</p>\n<ul>\n<li>对话记忆</li>\n<li>结构化输出</li>\n<li>RAG 知识库</li>\n<li>工具调用</li>\n<li>MCP</li>\n<li>SSE 流式输出</li>\n</ul>\n<p>就我个人体验下来，这两个框架的很多概念和用法都是类似的，也都提供了很多插件扩展，都支持和 Spring Boot 项目集成。虽然有一些编码上的区别，但孰好孰坏，使用感受也是因人而异的。</p>\n<p>实际开发中应该如何选择呢？</p>\n<p>我想先带你用 LangChain4j 开发完一个项目，最后再揭晓答案，因为那个时候你自己也会有一些想法。</p>\n<h2 id=\"AI-应用开发\"><a href=\"#AI-应用开发\" class=\"headerlink\" title=\"AI 应用开发\"></a>AI 应用开发</h2><h3 id=\"新建项目\"><a href=\"#新建项目\" class=\"headerlink\" title=\"新建项目\"></a>新建项目</h3><p>打开 IDEA 开发工具，新建一个 Spring Boot 项目，Java 版本选择 21（因为 LangChain4j 最低支持 17 版本）：</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQycl5RYAlTBorwbTI3PlIicqz4qgYAfF5VA8ZD6OqdOQfaqPsxMgr9ag/640?wx_fmt=png&from=appmsg&randomid=cdah2fh9&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>选择依赖，使用 3.5.x 版本的 Spring Boot，引入 Spring MVC 和 Lombok 注解库：</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQduuBrs4ibuHF2kGDvHeJjOYtYAFt8OyjpYjChNIGq6MRPe1AtrNprAg/640?wx_fmt=png&from=appmsg&randomid=g2rzqtq4&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>新建项目后，先修改配置文件后缀为 yml，便于后面填写配置。</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQibWyATuY1jEMNX4NBNtXws0s68icNdRQM6w7ZdiaBuUXDuyVoclxAP6Fw/640?wx_fmt=png&from=appmsg&randomid=8glbb5o8&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>这里我会建议大家创建一个 application-local.yml 配置文件，将开发时用到的敏感配置写到这里，并且添加到 .gitignore 中，防止不小心开源出来。</p>\n<h2 id=\"AI-对话-ChatModel\"><a href=\"#AI-对话-ChatModel\" class=\"headerlink\" title=\"AI 对话 - ChatModel\"></a>AI 对话 - ChatModel</h2><p>ChatModel 是最基础的概念，负责和 AI 大模型交互。</p>\n<p>首先需要引入至少一个 AI 大模型依赖，这里选择国内的阿里云大模型，提供了和 Spring Boot 项目的整合依赖包，比较方便：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>dev.langchain4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>langchain4j-community-dashscope-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.0-beta7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>需要到 阿里云百炼平台 获取大模型调用 key，注意不要泄露！</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQibTrFMyk56ic6p3qg6aCicKD6l5XeCMKIv8edXQ3omDEtyCplkCWXcfeQ/640?wx_fmt=png&from=appmsg&randomid=4t4d3x7n&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>回到项目，在配置文件中添加大模型配置，指定模型名称和 API Key：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">langchain4j:</span></span><br><span class=\"line\">  <span class=\"attr\">community:</span></span><br><span class=\"line\">    <span class=\"attr\">dashscope:</span></span><br><span class=\"line\">      <span class=\"attr\">chat-model:</span></span><br><span class=\"line\">        <span class=\"attr\">model-name:</span> <span class=\"string\">qwen-max</span></span><br><span class=\"line\">        <span class=\"attr\">api-key:</span> <span class=\"string\">&lt;You</span> <span class=\"string\">API</span> <span class=\"string\">Key</span> <span class=\"string\">here&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以按需选择模型名称，追求效果可以用 qwen-max，否则可以选择效果、速度、成本均衡的 qwen-plus。</p>\n<img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYK5rVrxmRUf1ibzQR638JNlQenuXgWvZOMQtpdquOdUJyyLASN2NkhUqk30Ozngn9SEmdUvFQxdbRg/640?wx_fmt=png&from=appmsg&randomid=8ac4s7h5&tp=webp&wxfrom=5&wx_lazy=1\" />\n\n<p>除了编写配置让 Spring Boot 自动构建 ChatModel 外，也可以通过构造器自己创建 ChatModel 对象。这种方式更灵活，在 LangChain4j 中我们会经常用到这种方式来构造对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChatModel</span> <span class=\"variable\">qwenModel</span> <span class=\"operator\">=</span> QwenChatModel.builder()</span><br><span class=\"line\">    .apiKey(<span class=\"string\">&quot;You API key here&quot;</span>)</span><br><span class=\"line\">    .modelName(<span class=\"string\">&quot;qwen-max&quot;</span>)</span><br><span class=\"line\">    .enableSearch(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .temperature(<span class=\"number\">0.7</span>)</span><br><span class=\"line\">    .maxTokens(<span class=\"number\">4096</span>)</span><br><span class=\"line\">    .stops(List.of(<span class=\"string\">&quot;Hello&quot;</span>))</span><br><span class=\"line\">    .build();</span><br></pre></td></tr></table></figure>\n\n<p>有了 ChatModel 后，创建一个 AiCodeHelper 类，引入自动注入的 qwenChatModel，编写简单的对话代码，并利用 Lombok 注解打印输出结果日志：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AiCodeHelper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ChatModel qwenChatModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">chat</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UserMessage</span> <span class=\"variable\">userMessage</span> <span class=\"operator\">=</span> UserMessage.from(message);</span><br><span class=\"line\">        <span class=\"type\">ChatResponse</span> <span class=\"variable\">chatResponse</span> <span class=\"operator\">=</span> qwenChatModel.chat(userMessage);</span><br><span class=\"line\">        <span class=\"type\">AiMessage</span> <span class=\"variable\">aiMessage</span> <span class=\"operator\">=</span> chatResponse.aiMessage();</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;AI 输出：&quot;</span> + aiMessage.toString());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> aiMessage.text();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写单元测试，向 AI 打个招呼吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AiCodeHelperTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AiCodeHelper aiCodeHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">chat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        aiCodeHelper.chat(<span class=\"string\">&quot;你好，我是程序员鱼皮&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 Debug 模式运行单元测试，成功运行并查看输出：</p>\n<!-- 省略后续内容，继续按上述格式处理全文 --> ",
            "tags": [
                "AI",
                "Java",
                "LangChain4j",
                "实战教程"
            ]
        },
        {
            "id": "https://120115.xyz/2024/07/21/%E7%89%9B%E5%AE%A2%E7%A5%9E%E5%93%81%E5%85%AB%E8%82%A1/",
            "url": "https://120115.xyz/2024/07/21/%E7%89%9B%E5%AE%A2%E7%A5%9E%E5%93%81%E5%85%AB%E8%82%A1/",
            "title": "神品八股-付费14元",
            "date_published": "2024-07-21T04:00:00.000Z",
            "content_html": "<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2lzc3VlL3R1dG9yaWFsP3podWFubGFuSWQ9TVE3NW5CJnV1aWQ9NzVhM2Y1ZGEwODZmNDE3ODk3YTg0NjdlZjY2ZGRlYjQ=\">https://www.nowcoder.com/issue/tutorial?zhuanlanId=MQ75nB&amp;uuid=75a3f5da086f417897a8467ef66ddeb4</span><br>面经陪练：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djNTI5MDY1L2FydGljbGUvZGV0YWlscy8xNDg3NjAzMDY=\">https://blog.csdn.net/wc529065/article/details/148760306</span></p>\n<p>京东 后端开发 暑期实习一面面经<br>Java集合<br>别用互联网思维写国企简历，这些模块要调整😧<br>Java SE<br>神品八股 | 专栏简介 | 基于1759篇面经、24139道八股题，精准提炼真实高频八股<br>JUC<br>JVM<br>Spring<br>MySQL<br>Redis<br>RabbitMQ<br>操作系统<br>计算机网络<br>设计模式 </p>\n",
            "tags": [
                "八股",
                "牛客"
            ]
        },
        {
            "id": "https://120115.xyz/2024/07/21/%E5%AD%A6%E4%B9%A0%E7%89%88%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/",
            "url": "https://120115.xyz/2024/07/21/%E5%AD%A6%E4%B9%A0%E7%89%88%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/",
            "title": "学习版游戏网站",
            "date_published": "2024-07-21T04:00:00.000Z",
            "content_html": "<p>以下均为电脑游戏</p>\n<p>gamebox：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9meTZiLmxhbnpvdXEuY29tL2lhTTQxMW9kODl3ZA==\">https://fy6b.lanzouq.com/iaM411od89wd</span></p>\n<p>game520：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2FtZXI1MjAuY29tLw==\">https://www.gamer520.com/</span></p>\n<p>GBT乐赏游戏空间：<span class=\"exturl\" data-url=\"aHR0cDovL2didGdhbWUueXNlcGFuLmNvbS8=\">http://gbtgame.ysepan.com/</span></p>\n<p>byrutor：<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVieXJ1dC5vcmcv\">https://thebyrut.org/</span></p>\n<p>小叽游戏：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGVhbXpnLmNvbS8=\">https://steamzg.com/</span></p>\n<p>wavse：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93YXZzZS5jb20v\">https://wavse.com/</span></p>\n<p>注意，网站内的广告切勿相信，直接忽略就好。以免造成不必要的损失！</p>\n",
            "tags": [
                "游戏",
                "Steam"
            ]
        }
    ]
}